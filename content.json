{"meta":{"title":"PengLaiDoll网安学习心得","subtitle":"","description":"","author":"PengLaiDoll","url":"http://penglaidoll.xyz","root":"/"},"pages":[{"title":"关于个人","date":"2021-02-24T08:09:19.080Z","updated":"2021-02-24T08:09:19.080Z","comments":true,"path":"about/index.html","permalink":"http://penglaidoll.xyz/about/index.html","excerpt":"","text":"PengLaiDoll一个苦逼但仍在不断努力的共和国预备警官(笑)Wechat:wxpenglaidoll欢迎前来交流(笑)小站简陋但定实时更新敬请谅解"},{"title":"分类","date":"2021-02-19T12:04:00.000Z","updated":"2021-02-19T12:11:14.290Z","comments":true,"path":"categories/index.html","permalink":"http://penglaidoll.xyz/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-02-19T12:07:14.000Z","updated":"2021-02-19T12:11:30.960Z","comments":true,"path":"tags/index.html","permalink":"http://penglaidoll.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"AT&T汇编语法","slug":"PE#3","date":"2021-04-04T03:34:00.000Z","updated":"2021-04-04T03:39:00.783Z","comments":true,"path":"posts/af3cdccb/","link":"","permalink":"http://penglaidoll.xyz/posts/af3cdccb/","excerpt":"","text":"AT&amp;T汇编和8086汇编(INTEL)其实差不多，只是表达方式不同 1.大小写INTEL汇编指令通常采用大写字母，如： 1MOV EAX,EBX AT&amp;T则通常采用小写字母来表示，如： 1movl %ebx,%eax 2.操作数赋值方向INTEL语法中，第一个表示目的操作数，第二个表示源操作数，如： 1MOV EAX，EBX；&#x2F;&#x2F;将EBX的内容移入EAX 而在AT&amp;T语法中，第一个表示源操作数，第二个表示目的操作数 1movl %eax,%ebx;&#x2F;&#x2F;将eax中的内容移入ebx 3.前缀INTEL语法中不需要前缀，如： 1MOV EAX,1 AT&amp;T语法则需要前缀，规则如下： 符号常数直接引用，不需要加前缀，如： 1movl value,%eax(value为一个常数) 前缀%加在寄存器名前 前缀$表示引用符号地址，如： 1movl $value,%ebx&#x2F;&#x2F;是将value的地址放入ebx中 前缀’lock’表示总线锁定，在linux核心代码中’lock’前缀很常见，特别是SMP代码，当总线锁定后CPU不能存取锁定地址处的内存单元 远程跳转指令和子过程调用指令要加前缀’|’分别为 1|jmp |call |ret 4.间接寻址语法INTEL语法中偏移地址通常用[]来括住，处理复杂操作数的语法为 1Segreg:[base+index*scale+disp] AT&amp;T中偏移地址则用()，处理复杂操作数的语法为 1$segreg:disp(base,index,scale) 其中上面所有的base,index,scale,disp都是可选的，scale默认为1 5.后缀AT&amp;T语法大部分指令操作码最后一个字母表示操作数大小,’b’表示’byte’,’w’表示’word’，’l’表示’long’，如: 1movl %eax,%ebx INTEL语法较少加后缀,但比如 1MOV eax,dword ptr [ebx] 这样的就规定了后缀来表示转移的数据长度 如果表示符号扩展和零扩展，在INTEL语法中表示为 1movsx,movzx AT&amp;T中表示为 1movs,movz 因此,movsbl %al,%ebx表示对寄存器al中的字节数据进行字节到长字的符号扩展，下面是一些扩展后缀 bl——字节-&gt;长字 bw——字节-&gt;字 wl——字-&gt;长字 跳转指令标号后的后缀表示跳转方向，如： 1jmp 1f ‘f’表示向前(forword)，’b’表示向后(behind)","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://penglaidoll.xyz/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"AT&T","slug":"AT-T","permalink":"http://penglaidoll.xyz/tags/AT-T/"}]},{"title":"从.c到.exe","slug":"PE#2","date":"2021-03-31T13:16:33.000Z","updated":"2021-04-01T12:13:39.729Z","comments":true,"path":"posts/c704601a/","link":"","permalink":"http://penglaidoll.xyz/posts/c704601a/","excerpt":"","text":"用C语言五步生成一个可执行文件我们都知道，利用gcc可以让一个C的源文件(.c)变成一个可执行文件(.exe) 123&#x2F;&#x2F;如何编译和运行一个.c源文件$gcc hello.c$.&#x2F;a.out 过程大概如下： 编写代码（人干的）（手动滑稽） 预编译 编译 汇编 链接 第一步——编写代码咱都懂 12345#include &lt;stdio.h&gt;void main()&#123; printf(&quot;Hello World!&quot;);&#125; 如上，没啥可说的，都会写，写完之后保存便生成了.c的C源文件 之后的四步，是gcc干的是，我们要来研究研究这个 第二步——预编译这里先大致概括一下《程序员的自我修养》上给的解释： 预编译过程主要处理那些源代码文件中的以“#”开始的预编译指令，主要处理规则规则如下： 删除所有的#define指令，展开所有的宏定义 处理所有的预编译指令 处理#include预编译指令，并将包含的文件插入该预编译指令的位置（这里是递归进行的） 删除所有的注释 在文件开头加上文件名标识，如(#2 “hello.c” 2) 为每一行添加行号，以方便编译器在调试时弹出错误信息能对应到具体的行 保留所有#pragma编译器指令，以便编译器使用 生成.i文件 上面是书中给出的预编译的过程，虽然已经讲的很清楚，但也有些地方需要进一步解释 123&#x2F;&#x2F;利用gcc实现预编译$gcc -E hello.c -o hello.i&#x2F;&#x2F;将hello.c预编译生成hello.i 预处理指令就是我们在.c开头使用的带有#的指令 主要分为三类 宏定义 文件包含 条件编译 其中宏定义和文件包含最常见，分别为#define和#include 预编译的作用主要就是针对预处理指令对.c语言变成.exe文件做初步的准备，比如将宏展开以便下一步的编译和将其他引入的文件（一般为头文件）引入以便于编译器对其进行分析 另外，条件编译我们用的较少，以下给出一些其他预编译指令的常见用法，不做多的讲解 指令 用途 #undef 未定义宏 #if 如果给定条件为真，则编译下面代码 #ifdef 如果宏被定义，则编译下面代码 #ifndef 如果宏未被定义，则编译下面的代码 #elif 如果前面的#if给定条件不为真，当前条件为真，则编译下面代码 #enif 结束一个#if…#else条件编译块 #error 停止编译并显示错误信息 #line 改变编译器用来指出警告和错误信息的文件号和行号 #pragma 为编译程序提供非常规的控制流信息 来源于网络，侵删 预处理指令的作用大概就是对于编译器的编程，让编译器有选择性的编译，将不必要的代码不进行编译。 特殊符号在网上我查到了一些神奇的东西，在书中好像并没有提及到，就是这个特殊符号，例如在源程序中出现的LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称。预编译程序对于在源程序中出现的这些串将用合适的值进行替换。具体操作也没有找到。 总而言之，预处理相当于帮助我们完成了编程的后续部分。 第三步——编译1234&#x2F;&#x2F;利用gcc将.s文件编译$gcc -c hello.s -o hello.o&#x2F;&#x2F;也就可以直接编译$gcc -c hello.c -o hello.o 这一部分应该是整个编译部分最困难的部分，因为涉及到编译原理，我能力不足也无法过多涉及。 这一部分编译器大致以下进行几个部分 词法分析 语法分析 语义分析 优化处理 经过预处理，程序中只剩下了：常量，变量，字符串(误),数字以及各种关键字、符号等 这一部分编译所做的工作就是通过分析这些个东西先判断是否符合语法规则，之后将其按照事先定好的规则翻译为等价的中间代码或汇编语言，最后进行优化 词法分析主要是利用扫描器词句进行分析，利用特殊的算法将其归类为关键字、标识符、字面量和特殊符号。并将其存放到对应的表中，以备后用。 语法分析利用语法分析器通过对上面生成的表中的记号进行分析，产生语法树，来分析语法的正误 语义分析利用语义分析器来分析语法树，对不同的数据类型进行标注等 生成中间语言和目标代码的生成和优化第四步——汇编这一步主要就是将上面的.s文件中的代码（汇编代码）转换为机器码(010101)，产生的目标文件,一般有两个段（代码段，数据段），其实这玩意就是平时在逆向时看到的代码，只不过我们在平时可以看到调用的其他的API （我个人理解为这个是一个差不多程序领空一样的东西，甚至小于程序领空） 第五步——链接我个人认为这步很重要，主要就是将我们的文件和所调用的其他比如头文件啦、Win32API啦什么的链接起来，让主程序正常能够调用 链接方式主要有两种： 静态链接 动态链接 关于链接这一块涉及到PE文件结构，并不太懂，只能粗略的说一下个人见解（不一定准确） 静态链接相当于你把所需要的函数名称、定义什么的在连接过程中加入到了文件之中，文件会变得大一点，但我们无论将这个文件移到什么地方，都可以正常执行 而动态链接只是在链接时将有关你所需要的外部函数所在的dll文件的相关信息存放在了文件的输入表当中，当需要时，会根据相关信息去寻找并输出，也就是说，只有当该文件执行时，才将输入表中的函数信息借助输入表使用loadlibrary()找到相关函数对应的dll并映射到对应虚拟内存中去，然后借助导入表用getprocessaddress()函数找到对应的函数来调用，这样会更节省内存，但会因为得需要现加载所以执行较慢，效率较低","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"c语言编译","slug":"c语言编译","permalink":"http://penglaidoll.xyz/tags/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91/"}]},{"title":"PE文件格式","slug":"PE#1","date":"2021-03-28T05:21:53.000Z","updated":"2021-03-28T06:00:54.906Z","comments":true,"path":"posts/16e2846c/","link":"","permalink":"http://penglaidoll.xyz/posts/16e2846c/","excerpt":"","text":"PE文件大致格式 **DOS头 ** **DOS **stub **PE签名 ** **PE文件头 ** **PE可选头 ** **Section table（节表） ** **.idata ** **.text ** **.data ** DOS头：用来兼容MS-DOS系统，主要目的是在MS-DOS上运行时提示This program cannot be run in DOS mode.另外就是指明到真正的PE文件头的位置的作用。 格式大概如下： 12345678910111213141516171819202122232425262728293031323334353637383940typedef struct_IMAGE_DOS_ &#123; // DOS .EXE header// offset: 0HWORD e_magic; // Magic number// offset: 2HWORD e_cblp; // Bytes on last page of file// offset: 4HWORD e_cp; // Pages infile// offset: 6HWORD e_crlc; // Relocations// offset: 8HWORD e_cparhdr; // Size of header in paragraphs// offset: AHWORD e_minalloc; // Minimumextra paragraphs needed// offset: CHWORD e_maxalloc; // Maximumextra paragraphs needed// offset: EHWORD e_ss; // Initial(relative) SS value// offset: 10HWORD e_sp; // Initial SPvalue// offset: 12HWORD e_csum; // Checksum// offset: 14hWORD e_ip; // Initial IPvalue// offset: 16HWORD e_cs; // Initial(relative) CS value// offset: 18HWORD e_lfarlc; // File address of relocation table// offset: 1AHWORD e_ovno; // Overlaynumber// offset: 1CHWORD e_res[4]; // Reservedwords// offset: 24HWORD e_oemid; // OEMidentifier (for e_oeminfo)// offset: 26HWORD e_oeminfo; // OEMinformation; e_oemid specific// offset: 28HWORD e_res2[10]; // Reservedwords// offset: 3CHLONG e_lfanew; // File address of new exe header&#125;IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; 其中需关注两个域： 第一个域——e_magic.exe文件第一个域一定为e_magic域，通常可执行文件在此域的值为’MZ’(16进制为0x4D5A) 最后一个域——e_lfanew看上文最后一个long型变量的注释：存储PE头的地址；32位可执行文件的扩展域，通常指向NT头相对文件起始位置的偏移 如下图所示： 4D 5A为DOS MZ header 80 00 00 00为最后一个域，如图，恰好指向0080h的PE头 补充：DOS头下，NT头上，这一部分为DOS stub，是由编译器所生成的当不支持PE文件的操作系统执行文件时输出This program cannot be run in DOS mode.通常不予理会，如上图所示。 NT头：NT头包含了PE文件的主要信息，包含 一个’PE’字样的签名 PE文件头(IMAGE_FILE_HEADER) PE可选头(IMAGE_OPTIONAL_HEADER32) 12345678typedef struct _IMAGE_NT_HEADERS&#123;// offset: 0HDWORD Signature;// offset: 4HIMAGE_FILE_HEADER FileHeader;// offset: 18HIMAGE_OPTIONAL_HEADER32 OptionalHeader;&#125; IMAGE_NT_HEADERS32,*PIMAGE_NT_HEADERS32; 如上所示 其中需要关注两个域 Signature类似于DOS头中的e_magic，高16位为0，低16位为0x4550,用字符表示就是’PE’ IMAGE_FILE_HEADER这个就是PE文件头，C语言定义如下 123456789typedefstruct _IMAGE_FILE_HEADER &#123;+4H WORD Machine;+6H WORD NumberOfSections;+8H DWORD TimeDateStamp;+CH DWORD PointerToSymbolTable;+10HDWORD NumberOfSymbols;+14HWORD SizeOfOptionalHeader;+16HWORD Characteristics;&#125;IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 具体位置如下 每个域的具体含义： Machine该文件的运行平台，是x86、x64还是I64等等，可以是下面值里的某一个。 123456789101112131415161718192021222324252627282930#define IMAGE_FILE_MACHINE_UNKNOWN 0#define IMAGE_FILE_MACHINE_I386 0x014c // Intel 386.#define IMAGE_FILE_MACHINE_R3000 0x0162 // MIPS little-endian, 0x160big-endian#define IMAGE_FILE_MACHINE_R4000 0x0166 // MIPS little-endian#define IMAGE_FILE_MACHINE_R10000 0x0168 // MIPS little-endian#define IMAGE_FILE_MACHINE_WCEMIPSV2 0x0169 // MIPS little-endian WCE v2#define IMAGE_FILE_MACHINE_ALPHA 0x0184 // Alpha_AXP#define IMAGE_FILE_MACHINE_SH3 0x01a2 // SH3 little-endian#define IMAGE_FILE_MACHINE_SH3DSP 0x01a3#define IMAGE_FILE_MACHINE_SH3E 0x01a4 // SH3E little-endian#define IMAGE_FILE_MACHINE_SH4 0x01a6 // SH4 little-endian#define IMAGE_FILE_MACHINE_SH5 0x01a8 // SH5#define IMAGE_FILE_MACHINE_ARM 0x01c0 // ARM Little-Endian#define IMAGE_FILE_MACHINE_THUMB 0x01c2#define IMAGE_FILE_MACHINE_AM33 0x01d3#define IMAGE_FILE_MACHINE_POWERPC 0x01F0 // IBM PowerPC Little-Endian#define IMAGE_FILE_MACHINE_POWERPCFP 0x01f1#define IMAGE_FILE_MACHINE_IA64 0x0200 // Intel 64#define IMAGE_FILE_MACHINE_MIPS16 0x0266 // MIPS#define IMAGE_FILE_MACHINE_ALPHA64 0x0284 //ALPHA64#define IMAGE_FILE_MACHINE_MIPSFPU 0x0366 // MIPS#define IMAGE_FILE_MACHINE_MIPSFPU16 0x0466 // MIPS#define IMAGE_FILE_MACHINE_AXP64 IMAGE_FILE_MACHINE_ALPHA64#define IMAGE_FILE_MACHINE_TRICORE 0x0520 // Infineon#define IMAGE_FILE_MACHINE_CEF 0x0CEF#define IMAGE_FILE_MACHINE_EBC 0x0EBC // EFI Byte Code#define IMAGE_FILE_MACHINE_AMD64 0x8664 // AMD64 (K8)#define IMAGE_FILE_MACHINE_M32R 0x9041 // M32R little-endian#define IMAGE_FILE_MACHINE_CEE 0xC0EE 也就是说，machine的值，代表了运行的平台 NumberOfSections该PE文件中有多少个节，也就是节表中的项数。 TimeDateStampPE文件的创建时间，一般有连接器填写。表明文件是何时被创建的。这个值是自1970年1月1日以来用格林威治时间（GMT）计算的秒数，这个值是比文件系统（FILESYSTEM）的日期时间更加精确的指示器。 PointerToSymbolTableCOFF文件符号表在文件中的偏移，主要指向调式信息 NumberOfSymbols符号表的数量。 SizeOfOptionalHeader紧随其后的可选头的大小,对于32位系统，通常为0X00E0H,64位系统为0X00F0H。 Characteristics 可执行文件的属性 具体定义在winnt.h头文件中 IMAGE_OPTIONAL_HEADER32/64这个是PE可选头，虽名为可选头，但必不可少，不同平台下其往往不同 下面以32位为例 123456789101112131415161718192021222324252627282930313233343536typedef struct _IMAGE_OPTIONAL_HEADER &#123;// 必选部分+18H WORD Magic;+1AH BYTE MajorLinkerVersion;+1BH BYTE MinorLinkerVersion;+1CH DWORD SizeOfCode;+20H DWORD SizeOfInitializedData;+24H DWORD SizeOfUninitializedData;+28H DWORD AddressOfEntryPoint;+2CH DWORD BaseOfCode;+30H DWORD BaseOfData;// 可选部分+34H DWORD ImageBase;+38H DWORD SectionAlignment;+3CH DWORD FileAlignment;+40H WORD MajorOperatingSystemVersion;+42H WORD MinorOperatingSystemVersion;+44H WORD MajorImageVersion;+46H WORD MinorImageVersion;+48H WORD MajorSubsystemVersion;+4AH WORD MinorSubsystemVersion;+4CH DWORD Win32VersionValue;+50H DWORD SizeOfImage;+54H DWORD SizeOfHeaders;+58H DWORD CheckSum;+5CH WORD Subsystem;+5EH WORD DllCharacteristics;+60H DWORD SizeOfStackReserve;+64H DWORD SizeOfStackCommit;+68H DWORD SizeOfHeapReserve;+6CH DWORD SizeOfHeapCommit;+70H DWORD LoaderFlags;+74H DWORD NumberOfRvaAndSizes;+78H IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32,*PIMAGE_OPTIONAL_HEADER32; **必选部分Magic表示可选头的类型,也可以看成创建文件的系统的位数 1234#define IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10b &#x2F;&#x2F; 32位PE可选头#define IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b &#x2F;&#x2F; 64位PE可选头#define IMAGE_ROM_OPTIONAL_HDR_MAGIC 0x107 MajorLinkerVersion链接器的版本号 MinorLinkerVersion链接器的版本号 SizeOfCode代码段的长度，如果有多个代码段，则是代码段长度的总和。 SizeOfInitializedData初始化的数据长度。 SizeOfUninitializedData未初始化的数据长度。 AddressOfEntryPoint 程序入口的RVA，对于exe可以理解为WinMain的RVA。对于DLL可以理解为DllMain的RVA，对于驱动程序，可以理解为DriverEntry的RVA。当然，实际上入口点并非是WinMain，DllMain和DriverEntry，在这些函数之前还有一系列初始化要完成。 BaseOfCode代码段起始地址的RVA。 BaseOfData数据段起始地址的RVA。 可选字段部分ImageBase介绍：映象（加载到内存中的PE文件）的基地址，这个基地址是建议，对于DLL来说，如果无法加载到这个地址，系统会自动为其选择地址。链接器产生可执行文件的时候对应这个地址来生成机器码，所以当文件被装入这个地址时不需要进行重定位操作，装入的速度最快。当文件被装载到其他地址时，进行重定位操作，会慢一点。 对于EXE文件来说，由于每个文件总是使用独立的虚拟地址空间，优先装入地址不可能被其他模块占据，所以EXE总是能够按照这个地址装入。 这也意味着EXE文件不再需要重定位信息。对于DLL文件来说，由于多个DLL文件全部使用宿主EXE文件的地址空间，不能保证优先装入地址没有被其他的DLL使用，所以DLL文件中必须包含重定位信息以防万一。 因此，在前面介绍的 IMAGE_FILE_HEADER 结构的 Characteristics 字段中，DLL 文件对应的 IMAGE_FILE_RELOCS_STRIPPED 位总是为0，而EXE文件的这个标志位总是为1，即DLL中不删除重定位信息，EXE文件中删除重定位信息。 也就是说，这个位置是对应物理内存的地址，再利用RSA，便可以找到真实地址 补：123#define IMAGE_FILE_RELOCS_STRIPPED 0x0001//Relocation info stripped from file.（从文件中删除重定位信息。） 在链接的时候，可以通过对link.exe指定/base:address选项来自定义优先装入地址，如果不指定这个选项的话，一般EXE文件的默认优先装入地址被定为00400000h，而DLL文件的默认优先装入地址被定为10000000h。 SectionAlignment节对齐，PE中的节被加载到内存时会按照这个域指定的值来对齐，比如这个值是0x1000，那么每个节的起始地址的低12位都为0。 FileAlignment节在文件中按此值对齐，SectionAlignment必须大于或等于FileAlignment。 MajorOperatingSystemVersion所需操作系统的版本号，随着操作系统版本越来越多，这个好像不是那么重要了。 MinorOperatingSystemVersion所需操作系统的版本号，随着操作系统版本越来越多，这个好像不是那么重要了。 MajorImageVersion映象的版本号，这个是开发者自己指定的，由连接器填写。 MinorImageVersion映象的版本号，这个是开发者自己指定的，由连接器填写。 MajorSubsystemVersion所需子系统版本号。 MinorSubsystemVersion所需子系统版本号。 Win32VersionValue保留，必须为0。 SizeOfImage映象的大小，PE文件加载到内存中空间是连续的，这个值指定占用虚拟空间的大小。 SizeOfHeaders所有文件头（包括节表）的大小，这个值是以FileAlignment对齐的。 CheckSum映象文件的校验和。 Subsystem运行该PE文件所需的子系统，可以是下面定义中的某一个： DllCharacteristicsDLL的文件属性，只对DLL文件有效，可以是下面定义中某些的组合： 12345678#define IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 0x0040 // DLL can move.#define IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY 0x0080 // Code Integrity Image#define IMAGE_DLLCHARACTERISTICS_NX_COMPAT 0x0100 // Image is NX compatible#define IMAGE_DLLCHARACTERISTICS_NO_ISOLATION 0x0200 // Image understands isolation and doesn&#x27;t want it#define IMAGE_DLLCHARACTERISTICS_NO_SEH 0x0400 // Image does not use SEH. No SE handler may reside in this image#define IMAGE_DLLCHARACTERISTICS_NO_BIND 0x0800 // Do not bind this image.// 0x1000 // Reserved.#define IMAGE_DLLCHARACTERISTICS_WDM_DRIVER 0x2000 //Driver uses WDM model// 0x4000 // Reserved.#define IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE 0x8000 SizeOfStackReserve运行时为每个线程栈保留内存的大小。 SizeOfStackCommit运行时每个线程栈初始占用内存大小。 SizeOfHeapReserve运行时为进程堆保留内存大小。 SizeOfHeapCommit运行时进程堆初始占用内存大小。 LoaderFlags保留，必须为0。 NumberOfRvaAndSizes数据目录的项数，即下面这个数组的项数。 DataDirectory数据目录，这是一个数组，数组的项定义如下： 1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; DWORD Size;&#125; IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;VirtualAddress 是一个RVA，Size：是一个大小。这两个数有什么用呢？一个是地址，一个是大小，可以看出这个数据目录项定义的是一个区域。那他定义的是什么东西的区域呢？前面说了，DataDirectory是个数组，数组中的每一项对应一个特定的数据结构，包括导入表，导出表等等，根据不同的索引取出来的是不同的结构，头文件里定义各个项表示哪个结构，如下面的代码所示： 节（块）表(Section Table)节表是PE文件后续节的描述，Windows根据节表的描述加载每个节。PE文件中所有节的属性都被定义在节表中，节表由一系列的IMAGE_SECTION_HEADER结构排列而成，每个结构用来描述一个节，结构的排列顺序和它们描述的节在文件中的排列顺序是一致的。全部有效结构的最后以一个空的IMAGE_SECTION_HEADER结构作为结束，所以节表中IMAGE_SECTION_HEADER结构数量等于节的数量加一。 节表总是被存放在紧接在PE文件头的地方。节表中 IMAGE_SECTION_HEADER结构的总数总是由PE文件头IMAGE_NT_HEADERS 结构中的FileHeader.NumberOfSections 字段来指定的。 123456789101112131415typedef struct_IMAGE_SECTION_HEADER &#123; BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union &#123; DWORD PhysicalAddress; DWORD VirtualSize; &#125; Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORDPointerToRelocations; DWORDPointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics;&#125; IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER; 需要关注的几个域Name区块名。这是一个由8个ASCII码组成，用来定义区块的名称的数组。多数区块名都习惯性以一个“.”作为开头（例如：.text），这个“.”实际上是不是必须的。值得我们注意的是，如果区块名达到8 个字节，后面就没有0字符了。前边带有一个“$” 的区块名字会从连接器那里得到特殊的待遇，前边带有“$”的相同名字的区块在载入时候将会被合并，在合并之后的区块中，他们是按照“$”后边的字符的字母顺序进行合并的。每个区块的名称都是唯一的，不能有同名的两个区块。但事实上节的名称不代表任何含义，他的存在仅仅是为了正规统一编程的时候方便程序员查看方便而设置的一个标记而已。所以将包含代码的区块命名为“.Data”或者说将包含数据的区块命名为“.Code”都是合法的。当我们要从PE 文件中读取需要的区块时候，不能以区块的名称作为定位的标准和依据，正确的方法是按照IMAGE_OPTIONAL_HEADER32 结构中的数据目录字段结合进行定位。 VirtualSize对表对应的区块的大小，这是区块的数据在没有进行对齐处理前的实际大小。 VirtualAddress该区块装载到内存中的RVA地址。这个地址是按照内存页来对齐的，因此它的数值总是SectionAlignment的值的整数倍。 PointerToRawData指出节在磁盘文件中所处的位置。这个数值是从文件头开始算起的偏移量。 SizeOfRawData该区块在磁盘中所占的大小，这个数值等于VirtualSize字段的值按照FileAlignment的值对齐以后的大小。 Characteristics该区块的属性。该字段是按位来指出区块的属性（如代码/数据/可读/可写等）的标志。 装载过程依靠PointerToRawData，SizeOfRawData，VirtualAddress，VirtualSize这4个字段的值，装载器就可以从PE文件中找出某个节(从PointerToRawData偏移开始的SizeOfRawData字节)的数据，并将它映射到内存中去(映射到从模块基地址偏移VirtualAddress的地方，并占用以VirtualSize的值按照页的尺寸对齐后的空间大小)。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"PE File","slug":"PE-File","permalink":"http://penglaidoll.xyz/tags/PE-File/"},{"name":"逆向","slug":"逆向","permalink":"http://penglaidoll.xyz/tags/%E9%80%86%E5%90%91/"}]},{"title":"常见OPE","slug":"re#2","date":"2021-03-27T15:32:00.000Z","updated":"2021-03-28T05:26:19.296Z","comments":true,"path":"posts/2a1f355e/","link":"","permalink":"http://penglaidoll.xyz/posts/2a1f355e/","excerpt":"","text":"五种常见语言的OEP特征：C++ （Microsoft Visual C++ 6.0）1234567891011121314151617181920212223242526270040577C &gt;&#x2F;$ 55 PUSH EBP (C的入口)0040577D |. 8BEC MOV EBP,ESP0040577F |. 6A FF PUSH -100405781 |. 68 30B24000 PUSH EasyClea.0040B23000405786 |. 68 84704000 PUSH EasyClea.00407084 ; SE 句柄安装0040578B |. 64:A1 0000000&gt;MOV EAX,DWORD PTR FS:[0]00405791 |. 50 PUSH EAX00405792 |. 64:8925 00000&gt;MOV DWORD PTR FS:[0],ESP00405799 |. 83EC 58 SUB ESP,580040579C |. 53 PUSH EBX0040579D |. 56 PUSH ESI0040579E |. 57 PUSH EDI0040579F |. 8965 E8 MOV [LOCAL.6],ESP004057A2 |. FF15 ECB04000 CALL DWORD PTR DS:[&lt;&amp;KERNEL32.GetVersion&gt;; kernel32.GetVersion -——————————————————————————————————————————– E语言这个和C极度像,要分清 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162630040389F &gt;&#x2F;$ 55 PUSH EBP004038A0 |. 8BEC MOV EBP,ESP004038A2 |. 6A FF PUSH -1004038A4 |. 68 F8724000 PUSH CrackMe.004072F8004038A9 |. 68 04554000 PUSH CrackMe.00405504 ; SE 处理程序安装004038AE |. 64:A1 0000000&gt;MOV EAX,DWORD PTR FS:[0]004038B4 |. 50 PUSH EAX004038B5 |. 64:8925 00000&gt;MOV DWORD PTR FS:[0],ESP004038BC |. 83EC 58 SUB ESP,58004038BF |. 53 PUSH EBX004038C0 |. 56 PUSH ESI004038C1 |. 57 PUSH EDI004038C2 |. 8965 E8 MOV DWORD PTR SS:[EBP-18],ESP004038C5 |. FF15 48704000 CALL DWORD PTR DS:[&lt;&amp;KERNEL32.GetVersion&gt;; kernel32.GetVersion004038CB |. 33D2 XOR EDX,EDX004038CD |. 8AD4 MOV DL,AH004038CF |. 8915 94BA4000 MOV DWORD PTR DS:[40BA94],EDX004038D5 |. 8BC8 MOV ECX,EAX004038D7 |. 81E1 FF000000 AND ECX,0FF004038DD |. 890D 90BA4000 MOV DWORD PTR DS:[40BA90],ECX004038E3 |. C1E1 08 SHL ECX,8004038E6 |. 03CA ADD ECX,EDX004038E8 |. 890D 8CBA4000 MOV DWORD PTR DS:[40BA8C],ECX004038EE |. C1E8 10 SHR EAX,10004038F1 |. A3 88BA4000 MOV DWORD PTR DS:[40BA88],EAX004038F6 |. 33F6 XOR ESI,ESI004038F8 |. 56 PUSH ESI004038F9 |. E8 7A030000 CALL CrackMe.00403C78004038FE |. 59 POP ECX004038FF |. 85C0 TEST EAX,EAX00403901 |. 75 08 JNZ SHORT CrackMe.0040390B00403903 |. 6A 1C PUSH 1C -——————————————————————————————————————————– Delphi （Borland Delphi 6.0 - 7.0）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667004F2F68 &gt; $ 55 PUSH EBP004F2F69 . 8BEC MOV EBP,ESP004F2F6B . 83C4 F0 ADD ESP,-10004F2F6E . 53 PUSH EBX004F2F6F . B8 102B4F00 MOV EAX,Unpacked.004F2B10004F2F74 . E8 EF3BF1FF CALL Unpacked.00406B68004F2F79 . 8B1D F4505000 MOV EBX,DWORD PTR DS:[5050F4] ; Unpacked.00506C14004F2F7F . 8B03 MOV EAX,DWORD PTR DS:[EBX]004F2F81 . E8 56ACF8FF CALL Unpacked.0047DBDC004F2F86 . 8B03 MOV EAX,DWORD PTR DS:[EBX]004F2F88 . BA F42F4F00 MOV EDX,Unpacked.004F2FF4 ; ASCII &quot; Hide Private File Pro&quot;004F2F8D . E8 32A8F8FF CALL Unpacked.0047D7C4004F2F92 . 8B0D 904E5000 MOV ECX,DWORD PTR DS:[504E90] ; Unpacked.00509144004F2F98 . 8B03 MOV EAX,DWORD PTR DS:[EBX]004F2F9A . 8B15 70E44E00 MOV EDX,DWORD PTR DS:[4EE470] ; Unpacked.004EE4BC004F2FA0 . E8 4FACF8FF CALL Unpacked.0047DBF4004F2FA5 . 8B0D 3C525000 MOV ECX,DWORD PTR DS:[50523C] ; Unpacked.0050909C004F2FAB . 8B03 MOV EAX,DWORD PTR DS:[EBX]004F2FAD . 8B15 48B14E00 MOV EDX,DWORD PTR DS:[4EB148] ; Unpacked.004EB194004F2FB3 . E8 3CACF8FF CALL Unpacked.0047DBF4004F2FB8 . 8B0D 0C535000 MOV ECX,DWORD PTR DS:[50530C] ; Unpacked.005090A4004F2FBE . 8B03 MOV EAX,DWORD PTR DS:[EBX]004F2FC0 . 8B15 7CB34E00 MOV EDX,DWORD PTR DS:[4EB37C] ; Unpacked.004EB3C8004F2FC6 . E8 29ACF8FF CALL Unpacked.0047DBF4004F2FCB . 8B0D 30505000 MOV ECX,DWORD PTR DS:[505030] ; Unpacked.005090D4004F2FD1 . 8B03 MOV EAX,DWORD PTR DS:[EBX]004F2FD3 . 8B15 B0BF4E00 MOV EDX,DWORD PTR DS:[4EBFB0] ; Unpacked.004EBFFC004F2FD9 . E8 16ACF8FF CALL Unpacked.0047DBF4004F2FDE . 8B03 MOV EAX,DWORD PTR DS:[EBX]004F2FE0 . E8 8FACF8FF CALL Unpacked.0047DC74004F2FE5 . 5B POP EBX004F2FE6 . E8 7115F1FF CALL Unpacked.0040455C004F2FEB . 00FF ADD BH,BH004F2FED FF DB FF -——————————————————————————————————————————– VB （Microsoft Visual Basic 5.0 / 6.0）123456789101112131415161718192021222324252627282930313233343536373839404100410400 &gt; 68 4C744100 PUSH Unpack_.0041744C ; ASCII &quot;VB5!6&amp;*&quot;00410405 E8 EEFFFFFF CALL &lt;JMP.&amp;msvbvm60.ThunRTMain&gt;0041040A 16 PUSH SS0041040B 0000 ADD BYTE PTR DS:[EAX],AL0041040D 0000 ADD BYTE PTR DS:[EAX],AL0041040F 0030 ADD BYTE PTR DS:[EAX],DH00410411 0000 ADD BYTE PTR DS:[EAX],AL00410413 0038 ADD BYTE PTR DS:[EAX],BH00410415 0000 ADD BYTE PTR DS:[EAX],AL00410417 0000 ADD BYTE PTR DS:[EAX],AL00410419 0000 ADD BYTE PTR DS:[EAX],AL0041041B 0060 9C ADD BYTE PTR DS:[EAX-64],AH0041041E F0:E2 CF LOCK LOOPD SHORT Unpack_.004103F0 ; 不允许锁定前缀00410421 BE 3D439505 MOV ESI,595433D00410426 E1 06 LOOPDE SHORT Unpack_.0041042E00410428 18A5 05D40000 SBB BYTE PTR SS:[EBP+D405],AH0041042E 0000 ADD BYTE PTR DS:[EAX],AL00410430 0000 ADD BYTE PTR DS:[EAX],AL00410432 0100 ADD DWORD PTR DS:[EAX],EAX00410434 0000 ADD BYTE PTR DS:[EAX],AL00410436 9E SAHF -——————————————————————————————————————————– BC++ （Borland C++ 1999）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606100401000 &gt; &#x2F;EB 10 JMP SHORTXXXXXXX.0040101200401002 |66:623A BOUND DI,DWORD PTR DS:[EDX]00401005 |43 INC EBX00401006 |2B2B SUB EBP,DWORD PTR DS:[EBX]00401008 |48 DEC EAX00401009 |4F DEC EDI0040100A |4F DEC EDI0040100B |4B DEC EBX0040100C |90 NOP0040100D -|E9 AC334800 JMP 008843BE00401012 \\A1 9F334800 MOV EAX,DWORD PTR DS:[48339F]00401017 C1E0 02 SHL EAX,20040101A A3 A3334800 MOV DWORD PTR DS:[4833A3],EAX0040101F 52 PUSH EDX00401020 6A 00 PUSH 000401022 E8 11110800 CALL &lt;JMP.&amp;KERNEL32.GetModuleHandleA&gt;00401027 8BD0 MOV EDX,EAX00401029 E8 3A1B0600 CALLXXXXXXX.00462B680040102E 5A POP EDX0040102F E8 981A0600 CALLXXXXXXX.00462ACC00401034 E8 6F1B0600 CALLXXXXXXX.00462BA800401039 6A 00 PUSH 00040103B E8 782E0600 CALLXXXXXXX.00463EB800401040 59 POP ECX00401041 68 48334800 PUSHXXXXXXX.0048334800401046 6A 00 PUSH 000401048 E8 EB100800 CALL &lt;JMP.&amp;KERNEL32.GetModuleHandleA&gt;0040104D A3 A7334800 MOV DWORD PTR DS:[4833A7],EAX00401052 6A 00 PUSH 000401054 E9 6B900600 JMPXXXXXXX.0046A0C400401059 &gt; E9 A62E0600 JMPXXXXXXX.00463F04 -——————————————————————————————————————————– Dasm:汇编123456789101112131415161700401000 &gt;&#x2F;$ 6A 00 PUSH 0 ; &#x2F;pModule &#x3D; NULL00401002 |. E8 C50A0000 CALL &lt;JMP.&amp;KERNEL32.GetModuleHandleA&gt; ; \\GetModuleHandleA00401007 |. A3 0C354000 MOV DWORD PTR DS:[40350C],EAX0040100C |. E8 B50A0000 CALL &lt;JMP.&amp;KERNEL32.GetCommandLineA&gt; ; [GetCommandLineA00401011 |. A3 10354000 MOV DWORD PTR DS:[403510],EAX00401016 |. 6A 0A PUSH 0A ; &#x2F;Arg4 &#x3D; 0000000A00401018 |. FF35 10354000 PUSH DWORD PTR DS:[403510] ; |Arg3 &#x3D; 000000000040101E |. 6A 00 PUSH 0 ; |Arg2 &#x3D; 0000000000401020 |. FF35 0C354000 PUSH DWORD PTR DS:[40350C] ; |Arg1 &#x3D; 00000000 另一种： 12345678910111213141516171819202100401025 &gt;&#x2F;$ 6A F6 PUSH -0A 00401027 |. E8 A0000000 CALL &lt;JMP.&amp;kernel32.GetStdHandle&gt; 0040102C |. A3 00304000 MOV DWORD PTR DS:[403000],EAX00401031 |. 6A F5 PUSH -0B 00401033 |. E8 94000000 CALL &lt;JMP.&amp;kernel32.GetStdHandle&gt; 00401038 |. A3 04304000 MOV DWORD PTR DS:[403004],EAX0040103D |. 6A 01 PUSH 1 0040103F |. 68 00104000 PUSH EchoLine.00401000 00401044 |. E8 8F000000 CALL &lt;JMP.&amp;kernel32.SetConsoleCtrlHandle&gt;00401049 |. 6A 07 PUSH 7 0040104B |. FF35 00304000 PUSH DWORD PTR DS:[403000] Vc++8.012345678910111213141516171819202100403A30 &gt; $ E8 6E270000 call VC8.004061A300403A35 .^ E9 79FEFFFF jmp VC8.004038B300403A3A &#x2F;$ 55 push ebp00403A3B |. 8BEC mov ebp,esp00403A3D |. 83EC 08 sub esp,0x800403A40 |. 897D FC mov [local.1],edi ; ntdll.7C93022800403A43 |. 8975 F8 mov [local.2],esi00403A46 |. 8B75 0C mov esi,[arg.2]00403A49 |. 8B7D 08 mov edi,[arg.1] ; VC8.&lt;ModuleEntryPoint&gt;00403A4C |. 8B4D 10 mov ecx,[arg.3]00403A4F |. C1E9 07 shr ecx,0x7 转载自52论坛https://www.52pojie.cn/thread-139728-1-1.html","categories":[{"name":"逆向学习——OD","slug":"逆向学习——OD","permalink":"http://penglaidoll.xyz/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94OD/"}],"tags":[{"name":"脱壳","slug":"脱壳","permalink":"http://penglaidoll.xyz/tags/%E8%84%B1%E5%A3%B3/"},{"name":"oep","slug":"oep","permalink":"http://penglaidoll.xyz/tags/oep/"}]},{"title":"UPX壳与Aspack壳脱壳","slug":"re#1","date":"2021-03-27T15:32:00.000Z","updated":"2021-03-27T15:41:38.549Z","comments":true,"path":"posts/b3843843/","link":"","permalink":"http://penglaidoll.xyz/posts/b3843843/","excerpt":"","text":"UPX壳： 单步步进法 ESP定理 全栈入栈，单步步进，发现只有ESP寄存器发生改变，跟随ESP寄存器到数据窗口，下硬件断点，执行文件，到断点处发现全栈出栈指令，应该是到oep了。 查找法（有限制） 既然有pushad，肯定有popad，在当前块直接查找popad，说不定就找到了 二次内存镜像法 在第一个.rsrc段下字节断点，运行，随后在00401000处下段点，运行，之后便接近oep了 Aspack壳： 单步步进发 ESP定理 查找法 二次内存镜像法 模拟跟踪法 找到内存中的sfx部分，输入指令tc eip&lt;(该段地址)执行到指定部分，便到了oep SFX 打开调试设置，找到SFX，利用OD自动找到oep","categories":[{"name":"逆向学习——OD脱壳","slug":"逆向学习——OD脱壳","permalink":"http://penglaidoll.xyz/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94OD%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"脱壳","slug":"脱壳","permalink":"http://penglaidoll.xyz/tags/%E8%84%B1%E5%A3%B3/"},{"name":"OD","slug":"OD","permalink":"http://penglaidoll.xyz/tags/OD/"},{"name":"UPX壳","slug":"UPX壳","permalink":"http://penglaidoll.xyz/tags/UPX%E5%A3%B3/"},{"name":"Aspack壳","slug":"Aspack壳","permalink":"http://penglaidoll.xyz/tags/Aspack%E5%A3%B3/"}]},{"title":"global和nonlocal的使用","slug":"python#12","date":"2021-03-24T15:04:14.000Z","updated":"2021-03-28T05:59:55.548Z","comments":true,"path":"posts/6d738442/","link":"","permalink":"http://penglaidoll.xyz/posts/6d738442/","excerpt":"","text":"global关键字如下一段代码： 12345678910111213count = 1def main(): count count+=1 print(count) main() 我们会发现程序报错而无法正常执行，这是因为count变量是全局变量，而在局部中是无法修改全局变量的 如果我们改成下面这样 ` 1234567891011count = 1def main(): global count count+=1 print(count)main() ` 程序可以正常执行了！ 这里global关键字可以让全局变量在局部中进行更改，只需要声明就行。 假如不进行声明也不修改呐？ 12345678910111213count = 1def main(): count count+=1 print(count)main() 是可以正常运行的 nonlocal关键字假如我们在一段函数定义中再引入一个函数定义而形成嵌套 12345678910111213def main(): count = 1 def pp(): nonlocal count print(count) pp()main() 这里可以看出，nonlocal声明是针对在嵌套函数的上一个函数的声明的使用 输出为 11","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python中对于文件的操作","slug":"python#11","date":"2021-03-19T15:57:01.000Z","updated":"2021-03-28T05:59:51.350Z","comments":true,"path":"posts/140ab620/","link":"","permalink":"http://penglaidoll.xyz/posts/140ab620/","excerpt":"","text":"对于文件的更改：Open函数：python中利用open函数来实现对文件的读取和更改举个栗子： 1234def main(): a &#x3D; open(&#39;a.txt&#39;,&#39;w&#39;,encoding&#x3D;utf-8) printf(a.read()) a.close() 这里我们用open()函数打开一个文件，注意open函数的返回值为一个对象，之后，我们对这个对象使用read方法来实现对文档的读取下面是对于传入的第二个参数的解释，其决定了open的操作模式| 操作模式 | 具体含义 || ——– | ——————————– || &#39;r&#39; | 读取 （默认） || &#39;w&#39; | 写入（会先截断之前的内容） || &#39;x&#39; | 写入，如果文件已经存在会产生异常 || &#39;a&#39; | 追加，将内容写入到已有文件的末尾 || &#39;b&#39; | 二进制模式 || &#39;t&#39; | 文本模式（默认） || &#39;+&#39; | 更新（既可以读又可以写） | With open as:当我们使用Open函数以后，我们不得不用close方法来对文件进行关闭，我们更常用的是这个 123def main(): with open(&#39;a.txt&#39;,&#39;w&#39;,encoding&#x3D;utf-8) as a: printf(a.read()) With open as 可以根据我们的使用情况(上下文环境)而适时关闭文件 Try:继续上面的代码，当我们当前目录的文件夹中无a.txt文件时，程序会报错，那么怎么避免这种情况呐 12345678910111213def main(): try: with open(&#39;a.txt&#39;,&#39;w&#39;,encoding&#x3D;utf-8) as a: printf(a.read()) except FileNotFoundError: print(&#39;无法打开指定的文件!&#39;) except LookupError: print(&#39;指定了未知的编码!&#39;) except UnicodeDecodeError: print(&#39;读取文件时解码错误!&#39;) finally: if a: print(&#39;Complete!&#39;) 这里引入了try except finally函数，这个函数可以根据不同的报错情况来选择性输出，属于选择结构，最后的finally又叫做“总要执行”，无论上述出现什么情况，这一语句总要执行，多用这个语句来保证程序的正确执行 For I in a.readlines():这一语句是用来整行遍历要读取的文件的内容","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python面向对象编程进阶③","slug":"python#10","date":"2021-03-19T14:47:37.000Z","updated":"2021-03-28T05:59:45.967Z","comments":true,"path":"posts/e04534a6/","link":"","permalink":"http://penglaidoll.xyz/posts/e04534a6/","excerpt":"","text":"静态方法与类方法静态方法：使用@staticmethod装饰器进行装饰可以直接被类调用而不用实例化假如我们要判定一个三角形是不是三角形 12345678910111213class San(): def __init__(self,a,b,c): self.__a &#x3D; a self.__b &#x3D; b self.__c &#x3D; c @staticmethod def is_right(a,b,c): if ((a+b&gt;c)&amp;(a+c&gt;b)&amp;(b+c&gt;a)): return True else: return Falses &#x3D; San(3,4,5)s.is_right() 这样我们会发现报错，显示 1is_right() missing 3 required positional arguments: &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; 这里我们就能看出，静态方法是不传入实例化参数的这样一来，我们可以在三角形S实例化之前用该方法判断S的三个边能否组成一个三角形静态方法的调用与实例化无关，只与该类和其定义有关 类方法使用@classmethod装饰器进行装饰传入的参数第一个必须为cls(表示传入类它自己)别的和普通方法差不多 三种方法的主要区别：普通方法第一个传入的参数是self，表示该方法引用的的有可能是类属性/方法，也有可能是实例属性/方法，实例的优先级大于类的类方法第一个传入的参数为cls，表示该方法引用的是类属性/方法静态方法类似于函数定义，只传入定义的东西","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"typedef与#define","slug":"CCpp#6","date":"2021-03-18T08:52:33.000Z","updated":"2021-03-28T06:00:32.062Z","comments":true,"path":"posts/3cbd2c1d/","link":"","permalink":"http://penglaidoll.xyz/posts/3cbd2c1d/","excerpt":"","text":"Typedef与#define几个区别： 1.typeof只能为类型定义一个别的符号名称，(#define)不仅能为类型定义别名，还能为数值定义别名2.typedef由编译器执行解释，(#define)由预编译器处理3.(#define)可以用其他类型说明符进行补充，而typeof不行 栗子： 1234#define p int;unsigned p n;&#x2F;&#x2F;可以typedef int p;unsigned p n;&#x2F;&#x2F;不可以 （这里可以看出，#define实际上起的是等量代换作用，而typedef不是）4.连续定义变量中#define的弱点栗子： 12#define a char *;a b,c; 等效于 1char *b,c; 也就是说，只有b被定义为了指针，c仍为字符变量 12typedef char* a;a b,c; 这里，可以将b,c都定义为字符变量指针","categories":[{"name":"C/C++语言学习","slug":"C-C-语言学习","permalink":"http://penglaidoll.xyz/categories/C-C-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"巧用异或交换数","slug":"CCpp#5","date":"2021-03-18T08:46:46.000Z","updated":"2021-03-28T06:00:28.153Z","comments":true,"path":"posts/994d2d1d/","link":"","permalink":"http://penglaidoll.xyz/posts/994d2d1d/","excerpt":"","text":"利用异或交换两个变量中存储的数正常情况下，我们通常定义swap利用地址交换两个变量中的值但如果我们只是交换两个整型变量的值呐？这里可以用到异或的小性质了 假设两个整形8bit的2进制数a,b交换的原理为 12a&#96;&#x3D;(a^b)^bb&#96;&#x3D;(a^b)^a&#96; 说说第一个的原理 12345a b a^b a&#96;1 1 0 11 0 1 10 1 1 00 0 0 0 由上推出，一个数，被同一个数异或两遍，数的大小不变","categories":[{"name":"C/C++语言学习","slug":"C-C-语言学习","permalink":"http://penglaidoll.xyz/categories/C-C-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"逻辑运算的短路性","slug":"CCpp#4","date":"2021-03-18T08:44:30.000Z","updated":"2021-03-28T06:00:24.786Z","comments":true,"path":"posts/d11843d/","link":"","permalink":"http://penglaidoll.xyz/posts/d11843d/","excerpt":"","text":"逻辑运算的短路性（表达式1）&amp;&amp;（表达式2）若表达式1为假，总式子一定为假，表达式2被短路（表达式1）||（表达式2）若表达式1为真，总式子一定为真，表达式2被短路 补充一下应用在网络上看到一个微软的面试题：求 1 + 2 + 3 + … + n要求：不能用乘除法，不能用if,while, switch,case, 不能用(a &lt; b ? a : b)三目运算符程序如下： 1234567891011121314#include &lt;stdio.h&gt;int fun(int n) &#123; int p&#x3D;0; int sum&#x3D;0; p &#x3D; n &amp;&amp; (sum&#x3D;n+fun(n-1)); return sum;&#125;int main() &#123; int a&#x3D;3,b; b &#x3D; fun(a); printf(&quot;%d&quot;,b); return 0; &#125; 这里面非常巧妙地用到了逻辑运算的短路原理，当n为0时，便不再执行后续语句，这上面的p只起到存储过程量的作用，可以忽略不看 原帖点这里","categories":[{"name":"C/C++语言学习","slug":"C-C-语言学习","permalink":"http://penglaidoll.xyz/categories/C-C-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"数据结构入门","slug":"data str#1","date":"2021-03-16T15:26:15.000Z","updated":"2021-03-16T15:47:36.098Z","comments":true,"path":"posts/4729e793/","link":"","permalink":"http://penglaidoll.xyz/posts/4729e793/","excerpt":"","text":"最近一段时间开始为了提高编程本领而开始学习数据结构了，据说学习好了不仅编程技巧直线上升，考试不挂科了，对Reverse也有好处(笑)便开始了万里长征的第一步 在网上搜索了一下关于数据结构的内容，大致这门课是学习如何更好的存储数据，据我自己感觉，学数据结构最大的作用就是让我们去获得更好的编程逻辑，以及我们日常用的如py中的dict,list，C中的链表，汇编经常用的栈等的实现原理也就是说，不学这个并不影响你去编程，但会决定你是不是一个好的程序员，而且，有了这些底层的理解，我们就更容易去理解他人的程序抱着成为更好的自己的信念，努力吧！ 数据结构的理解数据结构有两个要素，一个是数据元素的集合，另一个是关系的集合形式上，通常用二元组来表示 分类按照元素关系不同，分为以下四种 1234|--集合结构(元素属于同一集合)|--线性结构(元素一对一的关系)(常见列表，队列，栈等)|--树形结构(元素一对多的关系)(常见二叉树，二叉查找树，平衡二叉查找树等)|--图形结构(元素多对多的关系) 按照存储方式不同，分为以下两种 12|--顺序存储结构(数据元素在存储器中连续存储)|--链式存储结构(每个元素里设置了指向下一个元素的指针) 算法复杂度：时间频度，指算法中语句的执行次数，一般用T(n)表示，n为问题的规模有时，时间频度的表示方法过于复杂，于是又引入了时间复杂度，这个只关心算法中最耗时的部分，通常用时间频度中最能决定其大小的简单函数来表示空间复杂度指运行该算法所占用的存储空间大小，记为S(n)","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://penglaidoll.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://penglaidoll.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"记录一次作业","slug":"CCpp#3","date":"2021-03-14T23:26:54.000Z","updated":"2021-03-28T06:00:21.275Z","comments":true,"path":"posts/f5d29790/","link":"","permalink":"http://penglaidoll.xyz/posts/f5d29790/","excerpt":"","text":"学校开了C语言课，老师布置了一个简单的小程序，输入一个三位整数，然后分别输出这个数的个位，十位，百位，为了写出一个比较完善的代码，花了不少心思，也学了不少东西，在此记录一下： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void main() &#123; &#x2F;&#x2F;定义字符数组，以存储输入的数字 char strin[1024]; &#x2F;&#x2F;定义一个指针，以确保strlen函数的正常运行 char *strin_ptr; &#x2F;&#x2F;将i初始化为零，以防初始化导致i的随机定义进而导致内存中混进莫名的东西 &#x2F;&#x2F;其实这里也可以不初始化，因为if的第一个判断条件已经避免这个问题了 int i&#x3D;0,p; strin_ptr &#x3D; strin; &#x2F;&#x2F;do while将先执行一遍传入需要的数字，然后进行判断，若符合要求，则不再执行循环 do &#123; &#x2F;&#x2F;清空缓冲区 fflush(stdin); printf(&quot;Please input 3 integer:\\n&quot;); scanf(&quot;%d&quot;,&amp;i); &#x2F;&#x2F;itoa将整形转换为字符，以便存储和计数 itoa(i,strin,10); &#x2F;&#x2F;利用strlen判断输入数字的位数 p &#x3D; strlen(strin_ptr); &#x2F;&#x2F;判断位数、类型是否符合 if ((t &#x3D;&#x3D; 0)|| (strin[0]&#x3D;&#x3D;&#39;0&#39;) || (p !&#x3D; 3)) &#123; printf(&quot;This is ont a right integer,please input again!\\n&quot;); &#125; &#125; while ((t &#x3D;&#x3D; 0) || (strin[0]&#x3D;&#x3D;&#39;0&#39;) || (p !&#x3D; 3)); printf(&quot;Hundred position &#x3D; %c\\n&quot;,strin[0]); printf(&quot;Ten position &#x3D; %c\\n&quot;,strin[1]); printf(&quot;Individual position &#x3D; %c\\n&quot;,strin[2]); system(&quot;pause&quot;);&#125; 缓冲区问题：fflush(stdin)在此之前，我的代码是直接用的while循环且没有fflush(stdin)这一语句，如下： 1234while (((int)i!&#x3D;i) || (strin[0]&#x3D;&#x3D;&#39;0&#39;) || (p !&#x3D; 3)) &#123; printf(&quot;This is ont a right integer,please input again!\\n&quot;); scanf(&quot;%d,&amp;i&quot;); &#125; 大概就是上面这个样子造成的一个问题就是当第一次输入如abc这样不符合条件的字符类型的东西的时候，缓冲区存入‘abc’三个字符，第一个scanf读入因不符合类型要求而无法读取缓冲区的内容，之后执行while循环语句，输出“请重新输入”并再次执行scanf语句，我原本想着利用第二个scanf语句更改输入，结果scanf“不讲武德”，因为缓冲区已经有东西了(我们输入的不符合类型的内容)，所以scanf默认直接读取缓冲区的东西，导致进入了死循环为了解决上面这个问题，我改用了do while并在第一句直接加上了fflush(stdin)语句来清空标准输入的缓冲区，这样，每一次执行循环的开始，都会清空输入的缓冲区，防止进入死循环 字符串与字符问题：Gets():C语言中，其实不存在字符串这个东西，只有char类型来存储字符，能勉强算上存储字符的变量只有字符数组了，一个字符数组的名称相当于指向其首字母元素的指针，但很可惜，字符数组并不能作为变量传入scanf，会报错。所以，为了将缓冲区的字符串传入，不能用scanf,要用gets(),并将要传入的字符数组作为参数传入 判断类型是否正确：刚开始在while中我用了一个强制类型转换(int)i!=i来判断i是不是输入了正确类型，其实意义不大，因为在scanf中也有，只会读取缓冲区中的整型，如果我们输入了错误的类型，scanf压根不会读取，这里我们就要用到scanf的返回值了 scanf的返回值：scanf函数其实是存在返回值的，他返回读取到的匹配字符数目，比如我们输了3个%d,恰好缓冲区有三个整型的数与之匹配，那么就返回3，如果没有匹配的类型，scanf就不会读取缓冲区的任何内容，并返回0.在这里重新说一下scanf的作用，其读取缓冲区中的内容并将其赋值到传入的后续参数中去，读取的内容与传入的第一个参数中的%+字母有关，其决定了读取内容的类型 判断字符数组的长度我也不知道怎么回事，我试着将字符数组a作为参数传入strlen函数却发现编译器报错，后来查了一下,strlen函数的声明是这样的 1unsigned int strlen(char *s); 其传入的参数是指针，但理应传入数组应该也不会报错，最终我又加了一个指针来防止它报错 strlen函数和sizeof函数的区别sizeof函数和strlen函数一样，传入的参数类型须是指针，当然，当一个字符串被赋值进入一个指针后，该指针就指向了一个字符串，也可以说，字符串就相当于了一个指针的地位，所以可以直接作为参数传入这两个函数中去。strlen读取并返回字符串实际长度,而sizeof返回包括0/在内的所有字符细节，也就是在内存中的长度——————————————————对于上面的后续补充：get()函数有一个大缺点，他会无限读取stdin中的字符串直到遇见/0或换行符，也就是说，如果读取的字符串长度大于字符数组的长度，就会发生内存越界的坏情况为了防止这种情况，我们最好使用fget函数 1234格式fget(char* char,int n,FILE* stream)栗子fget(strlist,sizeof(strlist),stdin) 传入的第一个参数为指向字符串存储的变量的指针，第二个参数为读取字符串的长度，通常用sizeof来限制，传入的第三个参数为文件指针，以stdin使其读取输入缓冲区","categories":[{"name":"C/C++语言学习","slug":"C-C-语言学习","permalink":"http://penglaidoll.xyz/categories/C-C-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python基础进阶——list与dict","slug":"python#9","date":"2021-03-10T03:21:16.876Z","updated":"2021-03-28T05:59:41.648Z","comments":true,"path":"posts/8a0f52d1/","link":"","permalink":"http://penglaidoll.xyz/posts/8a0f52d1/","excerpt":"","text":"再补充一下关于list和dict的一些基础知识 不可变对象与可变对象：Str,dict的key等都是不可变对象比如我们调用replace函数 123&gt;&gt;A &#x3D; &#39;abc&#39;&gt;&gt;A.replace(&#39;a&#39;,&#39;A&#39;)&#39;Abc&#39; 看上去是变了，但当我们再次输入A时，我们发现： 12&gt;&gt;A&#39;abc&#39; 换种方式来看看： 123&gt;&gt;B &#x3D; A.replace(&#39;a&#39;,&#39;A&#39;)&gt;&gt;B&#39;Abc&#39; 为什么呢，因为str是不可变对象，当我们对一个str对象调用任何方法时，都不会改变这个不可变对象，而是创建新的不同的对象并返回现在我们去理解dict的key为什么时不可变对象 list和dict的优缺点：在理解key为不可变对象之前，我们先看一下list与dict的优缺点和list相比，dict查找和插入对象的速度更快，但消耗的内存更高，更浪费内存，也就是说,dict牺牲了内存来换取速度，之所以这个样子，就要谈到dict的原理了 关于list与链表以下的内容是我在网上查阅大佬资料时找到的list其实是用链表的方式存储的。假如我们有一个列表a =[1,2,3]，我们知道，链表的名称存储第一个元素的地址，也就是相当于名称是指向第一个元素的指针，第一个元素的指针再指向第二个元素，以此类推，我们便实现了元素的顺序排列。当我们想插入或删除一个元素，比如我们想在第一个和第二个元素之间插入一个5，我们可以直接通过链表的形式来实现。先通过添加一个链节5，让第一个元素的指针指向该链节，再让该链节的指针指向原来的第二个元素，这样便实现了插入，也就是说，在内存中，这些元素不一定是顺序排列的，但也可以实现顺序访问当我们想要查找某个元素时，因为是链表，所以我们不得不从头开始遍历，这也就是为什么list查找这么慢的原因 关于dict与哈希表dict的存储方式与list截然不同，dict采用了一种哈希算法，将key值利用哈希算法转换为一个数，再利用这个数找到相对应的值，不同的key通过哈希算法得到的值有很大概率不同，所以不同的key存储的地方不同，这才有了一一对应的原则。举个栗子：有一个字典{‘a’:1,’b’:2,’c’:3},我们想利用key’c’来查找，首先利用哈希算法将key’c’算出一个值，咱假设为233，再在内存空间开辟一个大空间0-1000出来，然后根据算出来的值将’c’的value存进对应的内存空间中去，所有的键值对都是这样存储的，因此，当我们想要取一个key的value时，没必要全部遍历，直接用哈希算法去算，然后找到对应的就可以了，所以dict的查找速度很快,但我们不得不得提前开辟一个大空间，所以dict又很消耗内存由上，我们可以推知为什么key为不可变对象了,dict通过key来存储值，假如key变了，那么下一次寻找时寻到的地址不同了，整个dict不就乱了吗补充一点：不同的key通过哈希算法得到的值有很大概率不同，也就是说，有小概率是相同的，这就要求设计哈希表时要尽量减少冲突，这个就是设计编译器的事情了。","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python面向对象编程进阶②","slug":"python#8","date":"2021-03-10T03:17:27.799Z","updated":"2021-03-28T05:59:36.541Z","comments":true,"path":"posts/794c651c/","link":"","permalink":"http://penglaidoll.xyz/posts/794c651c/","excerpt":"","text":"对于类的定制：str:用于返回当前类的自定义名称举个栗子： 1234class pp(): name &#x3D; &#39;ff&#39; passprint(pp()) 这样的话，会输出以下内容 1&lt;__main__.pp object at 0x0000023A8A958E50&gt; 假如说，我们加入__str__方法： 12345class pp(): name &#x3D; &#39;ff&#39; def __str__(self): return &#39;pp(name:%s)&#39; % &#39;ff&#39;print(pp()) 这样我们返回的就是： 1pp(name:ff) 也就是说，我们通过定义__str__方法，并返回我们想要输出的内容，那么当我们想要直接访问这个类时，系统会主动调用__str__方法，返回的不是类类型的标志语，而是我们自定义的内容 对于可迭代对象和迭代器的补充：之前我们说过，能被for直接作用的是可迭代对象，能使用next()方法的是迭代器，这里我们完善一下我们知道，一个对象中往往含有许多方法和属性，而dir函数可以帮助我们查看这些方法和属性。当我们对一个迭代器使用dir函数查看时，我们能看到其中有iter()和next()方法，这个很关键。在python中，若一个对象含有iter()方法，那么这个方法会返回一个可迭代对象，而若再含有__next__方法，那么这个对象就可以被调用next()方法，那么该对象就是迭代器由此，可迭代对象和迭代器都有__iter__方法，都可被for循环调用，迭代器中多了__next__方法，可用next()方法迭代由此，我们可以创建自己的可迭代对象了：以斐波那契数列为例： 12345678910class Fib(object): def __init__(self): self.a, self.b &#x3D; 0, 1 # 初始化两个计数器a，bdef __iter__(self): return self # 实例本身就是迭代对象，故返回自己def __next__(self): self.a, self.b &#x3D; self.b, self.a + self.b # 计算下一个值 if self.a &gt; 100: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 栗子中，我们定义了iter__方法使类实例化过程中返回一个可迭代对象，用__next__（）方法定义发生迭代的过程对于这个例子进行简单分析：__iter__使得一个对象成为可迭代对象__next__定义了该迭代器发生一次迭代的过程和结果StopIteration(终止异常):让一个迭代器终止迭代发生异常比如for循环自带异常处理，所以我们在遍历列表时不会因索引过大报错导致的程序终止,while循环则没有异常处理，所以我们在自定义可迭代对象时，为了防止无休止的迭代，要加上stopiteration异常，使之迭代到一定程度时触发异常，转而让异常处理来处理，从而终止迭代。在此处，并不是真的发生错误了，而是相当于换了一种方式告诉调用者已经迭代完毕。以上，我们发现自己所定义的迭代器并不支持索引调用其中的元素，这时，我们加入__getitem()方法的定义，这样，我们就可以通过访问下标索引的方式来访问可迭代对象中的元素 __getitem__方法当实例对象使用[]运算符取值时，会自动调用调用内建函数（方法）getitem()，并将[]中的内容作为一个参数传入__getitem__方法中。由此看出，当我们想通过访问下标的方式让自定义实例对象返回对应列表等可迭代对象或字典中的目标内容时，只需定义__getitem__对象使其返回就可举个栗子： 123456789class DataBase: def __init__(self): &#39;&#39;&#39;初始化方法&#39;&#39;&#39; self.lt &#x3D; [3,6,9] def __getitem__(self, key): return self.lt[key] data &#x3D; DataBase()print(data[1]) 输出： 1&gt;&gt;6 不难想到，列表的实现方式与这个如出一辙 __dict__属性之前我们用dir函数查看对象所含有或继承的方法和属性，现在我们介绍一个内置的__dict__属性，用它来查看某一对象自己的属性和方法，(当然，其作为对象的一个属性，它的作用之一也是存储这些信息)在这里，与dir有几点不同：1.dir函数生成的是list结构，其中只包括属性和方法的名称__dict__则展示了其作为dict的结构，key对应名称，value对应具体的值或方法定义2.dir函数生成全部的属性和方法(包括继承的)__dict__属性只展示部分属性或方法(不包括继承的)3.利用__dict__可以更改对象的属性，而dir不可栗子： 1Classname.__dict__[key] &#x3D; value 和正常的字典赋值差不多，就是多了一个类或实例访问另外，实例对象和类的__dict__属性有所不同举个栗子： 1234567891011class DataBase: def __init__(self): &#39;&#39;&#39;初始化方法&#39;&#39;&#39; self.lt &#x3D; [3,6,9] def __getitem__(self, key): return self.lt[key] def ff(self): return self.lt[2]data &#x3D; DataBase()print(data.__dict__)print(DataBase.__dict__) 返回 12&#123;&#39;lt&#39;: [3, 6, 9]&#125;&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;__init__&#39;: &lt;function DataBase.__init__ at 0x0000018994282040&gt;, &#39;__getitem__&#39;: &lt;function DataBase.__getitem__ at 0x00000189942820D0&gt;, &#39;ff&#39;: &lt;function DataBase.ff at 0x0000018994282160&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;DataBase&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;DataBase&#39; objects&gt;, &#39;__doc__&#39;: None&#125; 可见实例对象的__dict__属性仅包含self.xxx等的实例化属性，而类则相对包括更多的属性方法等(包括类函数，静态函数，全局变量等) 注意：如int,list,dict等的内置数据类型无__dict__属性 部分总结自点这里","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"几种特殊的数据类型","slug":"CCpp#2","date":"2021-03-08T02:52:23.000Z","updated":"2021-03-28T06:00:17.563Z","comments":true,"path":"posts/85a1c1ed/","link":"","permalink":"http://penglaidoll.xyz/posts/85a1c1ed/","excerpt":"","text":"size_t全称为size type,属于一种整型类型，能够保存一个整数，这个整数往往是一个大小(size)，也就是说，size_t是用来记录大小的数据类型类似的还有wchar_t,ptrdiff_t wchar_t即wide char type,是一种记录一个宽字符的数据类型 ptrdiff_t即pointer difference type,用来记录两个指针之间的距离的数据类型 补充：一般来说，以上三种数据类型均需要typedef来实现，而程序员们为了方便使用和记忆而人为规定了这么几种，但在较新的C/C++标准中，wchar_t已经被涵盖在数据类型中了可以直接使用了，其他的数据类型可以在其他常见的头文件的代码中看到定义","categories":[{"name":"C/C++语言学习","slug":"C-C-语言学习","permalink":"http://penglaidoll.xyz/categories/C-C-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python内置函数总结","slug":"python#7","date":"2021-03-04T01:08:21.000Z","updated":"2021-03-28T05:59:33.052Z","comments":true,"path":"posts/cf4bdb1c/","link":"","permalink":"http://penglaidoll.xyz/posts/cf4bdb1c/","excerpt":"","text":"Python内置的函数及其用法。 分类为了方便记忆，已经有很多开发者将这些内置函数进行了如下分类： 数学运算(7个)类型转换(24个)序列操作(8个)对象操作(7个)反射操作(8个)变量操作(2个)交互操作(2个)文件操作(1个)编译执行(4个)装饰器(3个) 汇总数学运算abs 求数值的绝对值divmod 返回两个数值的商和余数max 返回可迭代对象中的元素中的最大值或者所有参数的最大值min 返回可迭代对象中的元素中的最小值或者所有参数的最小值pow 返回两个数值的幂运算值或其与指定整数的模值round 对浮点数进行四舍五入求值sum 对元素类型是数值的可迭代对象中的每个元素求和 类型转换bool 根据传入的参数逻辑值，创建一个新的布尔值int 根据传入的参数，创建一个新的整数float 根据传入的参数，创建一个新的浮点数complex 根据传入参数，创建一个新的复数str 返回一个对象的字符串表现形式(给用户)bytearray 根据传入的参数，创建一个新的字节数组bytes 根据传入的参数，创建一个新的不可变字节数组memoryview 根据传入的参数，创建一个新的内存查看对象ord 返回Unicode字符对应的整数chr 返回整数所对应的Unicode字符bin 将整数转换成2进制字符串oct 将整数转化成8进制数字符串hex 将整数转换成16进制字符串tuple 根据传入的参数，创建一个新的元组list 根据传入的参数，创建一个新的列表dict 根据传入的参数，创建一个新的字典set 根据传入的参数，创建一个新的集合frozenset 根据传入的参数，创建一个新的不可变集合enumerate 根据可迭代对象创建枚举对象range 根据传入的参数，创建一个新的range对象iter 根据传入的参数，创建一个新的可迭代对象slice 根据传入的参数，创建一个新的切片对象super 根据传入的参数，创建一个新的子类和父类关系的代理对象object 创建一个新的object对象 序列操作all 判断可迭代对象的每个元素是否都为True值any 判断可迭代对象的元素是否有为True值的元素filter 使用指定方法过滤可迭代对象的元素map 使用指定方法去作用传入的每个可迭代对象的元素，生成新的可迭代对象next 返回可迭代对象中的下一个元素值reversed 反转序列生成新的可迭代对象sorted 对可迭代对象进行排序，返回一个新的列表zip 聚合传入的每个迭代器中相同位置的元素，返回一个新的元组类型迭代器 对象操作help 返回对象的帮助信息dir 返回对象或者当前作用域内的属性列表id 返回对象的唯一标识符hash 获取对象的哈希值type 返回对象的类型，或者根据传入的参数，创建一个新的类型len 返回对象的长度ascii 返回对象的可打印表字符串表现方式format 格式化显示值 反射操作vars 返回当前作用域内的局部变量，和其值组成的字典，或者返回对象的属性列表isinstance 判断对象是否是类或者类型元组中任意类元素的实例issubclass 判断类是否是另外一个类或者类型元组中任意类元素的子类hasattr 检查对象是否含有属性getattr 获取对象的属性值setattr 设置对象的属性值delattr 删除对象的属性callable 检测对象是否可被调用 变量操作globals 返回当前作用域内的全局变量，和其值组成的字典locals 返回当前作用域内的局部变量，和其值组成的字典 交互操作print 向标准输出对象打印输出input 读取用户输入值 文件操作open 使用指定的模式和编码打开文件，返回文件读写对象 编译执行compile 将字符串编译为代码或者AST对象，使之能够通过exec语句来执行或者eval进行求值eval 执行动态表达式求值exec 执行动态语句块repr 返回一个对象的字符串表现形式(给解释器) 装饰器property 标示属性的装饰器classmethod 标示方法为类方法的装饰器staticmethod 标示方法为静态方法的装饰器具体每个函数的解析如下： 数学运算abs：求数值的绝对值 1234&gt;&gt;&gt; abs(-1)1&gt;&gt;&gt; abs(1)1 divmod：返回两个数值的商和余数 1234&gt;&gt;&gt; divmod(5,2)(2, 1)&gt;&gt; divmod(5.5,2)(2.0, 1.5) max：返回可迭代对象中的元素中的最大值或者所有参数的最大值 12345678&gt;&gt;&gt; max(1,2) # 传入参数 取较大者2&gt;&gt;&gt; max(&#39;123&#39;) # 传入1个可迭代对象，取其最大元素值&#39;3&#39;&gt;&gt;&gt; max(-1,0) # 数值默认取数值较大者0&gt;&gt;&gt; max(-1,0,key &#x3D; abs) # 传入了求绝对值函数，则参数都会进行求绝对值后再取较大者-1min：返回可迭代对象中的元素中的最小值或者所有参数的最小值 12345678&gt;&gt;&gt; min(1,2) # 传入3个参数 取3个中较小者1&gt;&gt;&gt; min(&#39;123&#39;) # 传入1个可迭代对象，取其最小元素值&#39;1&#39;&gt;&gt;&gt; min(-1,-2) # 数值默认去数值较小者-2&gt;&gt;&gt; min(-1,-2,key &#x3D; abs) # 传入了求绝对值函数，则参数都会进行求绝对值后再取较小者-1 pow：返回两个数值的幂运算值或其与指定整数的模值 12345&gt;&gt;&gt; pow(2,3)&gt;&gt;&gt; 2**3&gt;&gt;&gt; pow(2,3,4)&gt;&gt;&gt; pow(2,3)%4 round：对浮点数进行四舍五入求值 12&gt;&gt;&gt; round(1.16,1)1.1 sum：对元素类型是数值的可迭代对象中的每个元素求和 123# 传入可迭代对象，要求是数字&gt;&gt;&gt; sum((1,2,3))6 ————————————————本文转载自CSDN大佬「Holidaylovesam」的博客原文链接：点这里```","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python面向对象编程进阶①","slug":"python#6","date":"2021-03-03T15:00:05.000Z","updated":"2021-03-28T05:59:28.520Z","comments":true,"path":"posts/e4b558a/","link":"","permalink":"http://penglaidoll.xyz/posts/e4b558a/","excerpt":"","text":"鸭子类型：存在于动态语言的一种现象，不用严格遵循继承体系也就是说，只要调用的对象中含有对应的方法，不用继承也可以实现多态的现象：如： 1234567891011121314class Person(): def wang(self): print(&#39;wang wang wang!&#39;) passclass Dog(): def wang(self): print(&#39;wang wang wang&#39;) passdef jiao(thing): thing.wang()p &#x3D; Dog()r &#x3D; Person()jiao(p)jiao(r) 其中，一个带感叹号，一个不带输出可以发现，二者均输出 12wang wang wangwang wang wang! 由此可知，python这样的动态语言注重的是方法，而不是繁杂的继承，有对应的方法就可以调用 1“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” 这就是鸭子测试 dir()函数——获得传入类内所有的属性和方法 实例属性和类属性：在类定义时定义的属性为类属性实例化时称为实例属性类属性归类所有，所有的实例均可访问若实例化时没有赋值那么默认属性则被赋值为类属性的值如有定义那么就赋值为实例属性的值 __slots__变量：给类绑定方法和属性：例子如下： 123456789class pp(): passpp.name &#x3D; &#39;pp&#39;o1 &#x3D; pp()print(o1.name)o1.tall &#x3D; 114514print(o1.tall)o2 &#x3D; pp()print(o2.tall) 如果我们将上面的代码输入，就可以观察到最后一行报错原因是tall实际上绑定到的是o1的实例而不是o类，所以实例化的o2没有tall属性，而name属性就是绑定到类上，所有实例化都可用 12345def f(self,x,y): print(x+y)from types import MethodType #从types包中引入methodtype函数，利用这个函数来绑定o1.f &#x3D; MethodType(f,o1) #函数的具体使用o1.f(3,5) 之后，我们再输入以上代码，向o1动态绑定f方法，同上面一样，这个是实例方法，无法在同类变量中使用，除非另行绑定加入我们想让一个类只能绑定我们规定好的属性或方法而无法绑定其他的属性或方法，该怎么办呢 __slots__变量：这个属于系统变量，用来限制该类能绑定的属性或方法举个栗子： 123456789class pp(): __slots__ &#x3D; (&#39;name&#39;) passpp.name &#x3D; &#39;pp&#39;def f(self,x,y): print(x+y)o1 &#x3D; pp()print(o1.name)o1.sound &#x3D; 114514 #(恶臭) 还是上面的代码，只不过我们加入了__slots__变量并规定了一个元组，其中包括了pp类可以绑定的name属性，当我们执行到o1.sound语句时，编译器报错，因为我们规定了除了name属性，其他都无法动态绑定再补充一点:__slots__变量只对当前类有用，对其子类无法起作用，除非子类再定义一个__slots__。如果子类再定义了，那么作为其父类中的__slots__也会得到继承，那么子类可以规定的属性和方法就是它及其父类__slots__变量中的和了 输入参数的检查：我们刚刚得知了给类绑定方法和属性的方法，可如果我们要求绑定的属性有个范围该怎么办呢。举个检查输入参数是否为int类型的例子吧 12if not isinstance(value,int) printf(&#39;error&#39;) isinstance函数可以帮助我们检验一个值是否为某一个类型，并返回true或false @property@property是python中的装饰器，可以用来创建只读属性，将一个方法转换为相同名称的只读属性 1.修饰方法，将其转换可以像属性一样访问1234class pp(): @property def ppff(self): return &#39;pp&#39; 假如没有@property,我们要想输出pp，则需输入 1pp().ppff() 但是有了@property，可以简化为 1pp().ppff 注意，用装饰器修改完之后，ppff函数将变成只读状态，无法再传入任何参数，如输入 1pp().ppff() 将会报错 2.与私有属性连用，防止私有属性被修改在之前我们先看一下私有属性的特点 123456class pp(): def __init__(self,name): self.__name &#x3D; name passp &#x3D; pp(&#39;p&#39;)print(p.__name) 以上，我们定义了一个私有属性__name在后面执行print语句时报错，说明我们无法访问__name这个私有属性，只能另行通过定义函数来返回__name属性的值，但如果我们在print语句前，pp类实例化语句之后加上这么一句 1p.__name &#x3D; &#39;pp&#39; 再执行后面的print语句，你会惊奇的发现，print语句正常执行了，我个人猜测，这个赋值语句改变了__name的私有属性状态而变成了普通的类属性为了防止其私有属性状态的改变和其值被更改，我们可以用@property 12345678910111213class DataSet(object): def __init__(self): self._images &#x3D; 1 self._labels &#x3D; 2 #定义属性的名称 @property def images(self): #方法加入@property后，这个方法相当于一个属性，这个属性可以让用户进行使用，而且用户有没办法随意修改。 return self._images @property def labels(self): return self._labelsl &#x3D; DataSet()#用户进行属性调用的时候，直接调用images即可，而不用知道属性名_images，因此用户无法更改属性，从而保护了类的属性。print(l.images) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（） 上面的例子我们可以将那两个方法改成其他的函数从而隐藏属性的名字而进行调用，让人以为是属性，而其实是方法变成的属性哒！","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"生成器与迭代器基础","slug":"python#5","date":"2021-03-01T14:25:20.000Z","updated":"2021-03-28T05:59:21.412Z","comments":true,"path":"posts/3d4ca4e0/","link":"","permalink":"http://penglaidoll.xyz/posts/3d4ca4e0/","excerpt":"","text":"列表生成式：当我们在用for循环来输出列表时，会很麻烦，特别是生成一些复杂的列表，除此之外，我们可以利用列表生成式如：要生成 1[1&#x3D;1,2&#x3D;2,3&#x3D;3.....] 可以用 1[x&#x3D;x for x in range(1,...)] 这样的式子我们称之为列表生成式还可以在第一个for后面跟上更多的循环来生成更复杂的全排列灵活运用列表生成式可以简化代码列表生成式的if：如: 1[x for x in range(1,11) if x%2&#x3D;&#x3D;0] 可以输出1到11的偶数这里if起的是筛选作用注意后面不可跟else，否则会报错如果在for前面放if则必须跟else表示条件不同，就一以不同的形式输出 生成器：上面我们解释了列表生成式，是把for循环放在列表标识符中的([]),如果我们把列表标识符改成()并且讲其赋值到一个变量中去，像是生成了一个元组一样，但实际上是创建了一个生成器(generator)并将其赋值到了变量之中生成器，顾名思义，可以将一种算法赋值到一个变量之中，根据算法来取到所需要的值。与列表生成器不同，不需要将所有元素都计算出来，而只在需要的时候才算出对应的元素，省去不必要的元素以节省空间使用next(generator)函数来求出下一个元素最好使用for循环来求出所需的元素举个栗子： 123g &#x3D; (x for x in range(1,10000))for i in g: print(i) 在这里，刚刚生成1到10000时，并不是直接占用了所有的内存，二十后面一步一步推算出来的这里之所以能用for，是因为生成器也是可迭代对象生成器的作用非常强大，可以实现算法的迭代当一个算法过于复杂而for列表生成器无法应对的时候比如生成斐波那契数列常规写法： 1234567def fib(max): n,a,b&#x3D;0,0,1 while n&lt;max: print(a) a,b &#x3D; b,a+b n&#x3D;n+1return &#39;done&#39; 由此观察a,b=b,a+b逻辑和生成器相近，都是走一步算一步（雾生成器写法： 1234567def fib(max): n,a,b&#x3D;0,0,1 while n&lt;max: yield b a,b&#x3D;b,a+b n&#x3D;n+1return &#39;done&#39; 解释：在函数定义过程中，只要加上了yield，就可以将函数变成生成器，正常函数为顺序执行，而生成器则会一直执行到首次遇见yield语句，并输出yield语句后面的参数，使用next()语句使其从当前的yield语句执行到下一条yield语句举个简单栗子： 12345def odd(): print &#39;step1&#39; yield 1 print &#39;step2&#39; yield(3) 调用时： 1234567&gt;&gt;o &#x3D; odd()&gt;&gt;next(o)step11&gt;&gt;next(o)step23 如上 注意：调用一个生成器时，会返回一个generate对象就像map一样，生成的是迭代器迭代器和可迭代对象：能被for循环直接作用的，我们称为可迭代对象而像生成器那样的，可以用next()函数调用并返回下一个值的我们称为迭代器，如map,generator。(迭代器也是可迭代对象)可以利用isinstance()来判断一个变量是否为迭代器迭代器对象表示的是一个数据流，我们不知道其有多长，知道数据全部输出完毕就会报错，而不是迭代器的可迭代对象我们往往知道其长度","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"C语言指针相关","slug":"CCpp#1","date":"2021-02-28T09:01:18.000Z","updated":"2021-03-28T06:00:12.264Z","comments":true,"path":"posts/34311c5c/","link":"","permalink":"http://penglaidoll.xyz/posts/34311c5c/","excerpt":"","text":"C指针：指针是一类储存地址的变量 指针数组：如果想让一个数组存储一组指向某一特定数据类型的地址，那么就能定义一个指针数组如：int *ptr[3];int var[]={10,100,200};for (i=0;i&lt;3;i++) { ptr[i] = var[i];}通过以上这段代码，var数组的每个值的每个地址都被存储在指针数组ptr中了 补充：“指针数组”和“数组指针”的区别：“指针数组”顾名思义，是指针的数组，他是元素均为指针的一个数组变量“数组指针”，则是指一个指向数组的指针变量，通常地址为数组第一个元素的地址。 指针函数：一个返回值为指针的函数C语言默认在调用函数时不可返回地址，除非讲局部变量定义为static变量具体的使用过程为——在函数定义声明返回值为指针，然后return一个相同类型的指针(具体的返回值为地址)例如： 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int * fhptr(int i) &#123; static int *s; s &#x3D; &amp;i; return s;&#125;void main() &#123; int *p; p &#x3D; fhptr(5); printf(&quot;%d %p&quot;,*p,p);&#125; 至于为什么要求局部变量要定义为static变量则是因为局部变量存储在内存的栈区，函数调用结束后，内存释放，函数内的变量便不再拥有那个内存地址，故指针无法返回。而static变量值存放在静态栈区，静态区只会在最初时初始化一回，之后便不会改变。 函数指针：指向函数的指针函数在编译后会占一部分内存，函数名则是函数的首地址(类似于数组)将一个指针赋以函数名的值则能让这个特殊的指针指向函数举个栗子： 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void func(int a) &#123; printf(&quot;%d&quot;,a);&#125;void main() &#123; int (*funcpointer)(int); funcpointer &#x3D; &amp;func; funcpointer(6);&#125; 注意：指向函数的指针不可自增运算也就是说，你能在此处通过调用函数指针来获得和调用该函数一样的效果(脱了裤子放屁)还记得当函数作为参数传入函数时需要将其转换为指针的形式吗，函数指针的真正作用则是用在这里 完善一下上面的例子： 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;&#x2F;&#x2F;定义一个 指向 返回类型为void，传入参数为一个Int类型的函数类型 的指针类型typedef void (*hhh) (int);void func(int a) &#123; printf(&quot;%d&quot;,a);&#125;void main() &#123; hhh p; p &#x3D; func; p(6);&#125; 函数指针数组：例子如下： 1int (*function_pointer)[N](int,int); 这个是其通用形式，分开来看 1Int (*function_pointer) [n] (int,int); 首先它是一个指针，指向的是一个数组，什么数组呢，存了n个 参数为两个int类型，返回值为int的函数 的地址","categories":[{"name":"C/C++语言学习","slug":"C-C-语言学习","permalink":"http://penglaidoll.xyz/categories/C-C-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python中的类，模块，包","slug":"python#4","date":"2021-02-24T07:38:16.000Z","updated":"2021-03-28T05:59:10.253Z","comments":true,"path":"posts/8a35e780/","link":"","permalink":"http://penglaidoll.xyz/posts/8a35e780/","excerpt":"","text":"类：Python被设计为一门面向对象的编程语言，同其他面向对象的编程语言一样，它也有类这个概念：类可以认为是一个集合，用来容纳众多的相近的属性和方法，方便随时调用其中的变量和函数；对象则是类的实例化(把类赋值到一个变量中)，一个对象(也可以说一个类)有其对应的属性和方法；属性可以认为是类中定义的变量，分为类的属性和实例对象的属性；方法则是在类中定义的函数；一个简单的类实例： 12345678910class Pp: def __init__(self,a,b): self.a &#x3D; a self.b &#x3D; b self.c &#x3D; a + b print(&quot;初始化完毕！&quot;) def outsc(self): print(self.c)X &#x3D; Pp(2,3)x.outsc() 关于init:在把对象实例化之后会默认执行__init__方法，结合对__init__方法的定义，通常用来对对象初始化。除此之外，若想在对象实例化时就传入参数，必须调用__init__方法，不带__init__方法的类默认无法传入参数。 对于self的解释：类在定义方法时，传入的参数第一个必须是self，即使没有参数时，也要传入self，这里有一种解释，比如上例，Pp类实例化为x，这里self的作用实际上是把变量x在类内以self指代，所以类不管实例化为什么，self总是能把变量的名称传入类内以便调用。 模块：在Python中，一个模块可以认为是一个.py文件，它可以被其他.py文件用import函数引入，以便使用之前定义好的函数，类，变量什么的。 包：当多个用处相近的模块组合在一起，放在同一个文件夹这样的文件夹可以称为一个包。多个这样的文件夹合成一个大文件夹也可以称为一个包，则小文件夹又称为子包。包同样可以用import引入，其往往是一些制作者为了提供一系列的模块所制成，以方便调用。包内必须要有init.py文件、一个包的组成往往如下：Package1:|-init.py|-Module1.py|-Module2.py|-……调用方法为: 1From package1 import module1: 或 1Import package1.module1: 若包中一个模块需调用其他目录的模块，可在当前包目录下的init.py文件中添加sys.path.append(‘调用模块位置’)，然后再import __init__就可以了。","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"格式化字符串的三种方法","slug":"python#3","date":"2021-02-24T07:26:07.000Z","updated":"2021-03-28T05:58:56.872Z","comments":true,"path":"posts/6d69b5ea/","link":"","permalink":"http://penglaidoll.xyz/posts/6d69b5ea/","excerpt":"","text":"最古老的方法：——%-formatting格式化字符串类似于C语言，它是这么用的： 输入： 123Name &#x3D; &#39;world&#39;Id &#x3D; &#39;10&#39;Print(&#39;Hello %s,id&#x3D;%s&#39; % (name,id)) 输出： 1&#39;Hello world,id&#x3D;10&#39; 对于字典，同样适用：格式(%(key)s/d/g) 输入： 1Print(&#39;Hello %(name)s,id&#x3D;%(name)s&#39; % &#123;&#39;id&#39;:10 , &#39;name&#39; : &#39;world&#39;&#125;) 输出： 1Hello World,id&#x3D;10 后来的方法：——str.format()方法格式化字符串常规方法：输入： 12Name &#x3D; &#39;World&#39;Print(&#39;Hello &#123;&#125;&#39; % (name)) 输出： 1Hello World 通过位置访问的方法：输入： 1Print(&#39;&#123;2&#125;,&#123;1&#125;,&#123;0&#125;&#39;.format(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) 输出： 1C,b,a 通过关键字访问的方法：输入： 1Print(&#39;hi &#123;name&#125;&#39;.format(name &#x3D; &#39;howdy!&#39;)) 输出： 1Hi howdy! 新的方法：f-string格式化字符串Python3.6版本更新这一种方法，性能更优： 输入: 12345name &#x3D; &#39;hello world!&#39;D &#x3D; &#123;&#39;id&#39;:&#39;1&#39;,&#39;page&#39;:&#39;2&#39;&#125;Print(f&#39;print &#123;name&#125;&#39;)Print(f&#39;print &#123;name.upper()&#125;)Print(f&#39;turn to &#123;d[&quot;page&quot;]&#125;) 输出： 123Print hello worldPrint HELLO WORLDTurn to 2","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python中的交叉排序问题","slug":"python#2","date":"2021-02-22T03:12:17.000Z","updated":"2021-03-28T05:58:45.317Z","comments":true,"path":"posts/51641b53/","link":"","permalink":"http://penglaidoll.xyz/posts/51641b53/","excerpt":"","text":"在计蒜客中学习Python时，遇到了一个很有趣的排序问题： 输入一行 kk 个用空格分隔开的整数，依次为 n_1, n_2 … n_kn 1 ,n 2…n k。请将所有下标不能被 3 但可以被 2 整除的数在这些数字原有的位置上进行升序排列，此外，将余下下标能被 3 整除的数在这些数字原有的位置上进行降序排列。输出包括一行，与输入相对应的若干个整数，为排序后的结果，整数之间用空格分隔。 自己琢磨了很长时间，其中也发现了各种各样的问题，下面分享一下： 输入例：1 5 4 3 10 7 19输出例：1 3 7 5 10 4 19 程序样例1234567891011121314151617181920212223242526272829n = [int(x) for x in input().split(&#x27; &#x27;)]n1 = []n2 = []n3 = []nc= []# 将满足下标不同条件的列表中的数放入不同的空列表中for index in range(len(n)): if ((index+1) % 3 != 0) and ((index+1) % 2 == 0): n1.append(n[index]) elif ((index+1) % 3 ==0): n2.append(n[index]) else: n3.append(n[index])# 列表排序n1.sort()n2.sort(reverse = True)# 再将列表元素按照原序依次放回for index in range(len(n)): if ((index+1) % 3 != 0) and ((index+1) % 2 == 0) and n1: nc.append(n1.pop(0)) elif ((index+1) % 3 ==0) and n2: nc.append(n2.pop(0)) elif n3: nc.append(n3.pop(0))# 按照格式输出for i in range(len(n)): print(nc[i],end=&#x27; &#x27;) 格式化输入比如以空格相间隔的数据的输入：100 200 300可以用下面的方式读取 12345678# example 1x = [int(i) for i in input().split(&#x27; &#x27;)# exapmle 2x = map(int,input().split(&#x27; &#x27;)) 其中，input().split(‘ ‘)是将输入的数据以split函数传入的参数为标志进行分割并返回分割后的列表(注：split函数返回的列表为字符串列表！！！）example 2是一种比较巧妙的方法 判断列表是否为空1234567a = []if a: print(&#x27;YES&#x27;)else: print(&#x27;NO&#x27;) 以上只是个例子，是为了说明若一个列表为空，则其对应布尔值为False可以利用这个来判断一个列表是否为空程序例子中使用这个判断来防止列表空时pop()函数对空列表使用报错 参考：点这里 [点这里](https://blog.csdn.net/weixin_43113241/article/details/109965485）","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python中的_name_属性","slug":"python#1","date":"2021-02-19T11:36:03.000Z","updated":"2021-03-28T05:58:33.191Z","comments":true,"path":"posts/e599f77d/","link":"","permalink":"http://penglaidoll.xyz/posts/e599f77d/","excerpt":"","text":"刚开始学习python，接触到 1If _name_ == &#x27;_main_&#x27;: 这句话并不是很了解，以下是解答： Python中的模块与C,C++的头文件python如同C，C++等其他编程语言相似，可以引入(import)外部文件，在python中，引入的每个文件，以及自身的代码文件又叫模块，不同于C和C++，python中的模块可以独立运行，而C和C++中的头文件会首先执行 _name_属性1.name_是一个系统定义的变量，用来存储模块的名字或状态，假如一个模块为主函数(通常为引入其他模块的模块)则其模块内包含的_name_变量被赋值为“_main_”；若该模块是被引入的模块，则其_name_变量被赋值为(模块名无后缀)2.通过判断_name_所被赋的值的方式，可以判断该模块是否被引入或为主函数3.通常与if _name ==’main‘结合使用减少bug 总结自：点这里","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"逆向学习——OD","slug":"逆向学习——OD","permalink":"http://penglaidoll.xyz/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94OD/"},{"name":"逆向学习——OD脱壳","slug":"逆向学习——OD脱壳","permalink":"http://penglaidoll.xyz/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94OD%E8%84%B1%E5%A3%B3/"},{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C/C++语言学习","slug":"C-C-语言学习","permalink":"http://penglaidoll.xyz/categories/C-C-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"算法学习","slug":"算法学习","permalink":"http://penglaidoll.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://penglaidoll.xyz/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"AT&T","slug":"AT-T","permalink":"http://penglaidoll.xyz/tags/AT-T/"},{"name":"c语言编译","slug":"c语言编译","permalink":"http://penglaidoll.xyz/tags/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91/"},{"name":"PE File","slug":"PE-File","permalink":"http://penglaidoll.xyz/tags/PE-File/"},{"name":"逆向","slug":"逆向","permalink":"http://penglaidoll.xyz/tags/%E9%80%86%E5%90%91/"},{"name":"脱壳","slug":"脱壳","permalink":"http://penglaidoll.xyz/tags/%E8%84%B1%E5%A3%B3/"},{"name":"oep","slug":"oep","permalink":"http://penglaidoll.xyz/tags/oep/"},{"name":"OD","slug":"OD","permalink":"http://penglaidoll.xyz/tags/OD/"},{"name":"UPX壳","slug":"UPX壳","permalink":"http://penglaidoll.xyz/tags/UPX%E5%A3%B3/"},{"name":"Aspack壳","slug":"Aspack壳","permalink":"http://penglaidoll.xyz/tags/Aspack%E5%A3%B3/"},{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"},{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://penglaidoll.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}