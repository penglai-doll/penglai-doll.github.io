{"meta":{"title":"PengLaiDoll网安学习心得","subtitle":"","description":"","author":"PengLaiDoll","url":"http://penglaidoll.xyz","root":"/"},"pages":[{"title":"关于个人","date":"2021-02-24T08:09:19.080Z","updated":"2021-02-24T08:09:19.080Z","comments":true,"path":"about/index.html","permalink":"http://penglaidoll.xyz/about/index.html","excerpt":"","text":"PengLaiDoll一个苦逼但仍在不断努力的共和国预备警官(笑)Wechat:wxpenglaidoll欢迎前来交流(笑)小站简陋但定实时更新敬请谅解"},{"title":"分类","date":"2021-02-19T12:04:00.000Z","updated":"2021-02-19T12:11:14.290Z","comments":true,"path":"categories/index.html","permalink":"http://penglaidoll.xyz/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-02-19T12:07:14.000Z","updated":"2021-02-19T12:11:30.960Z","comments":true,"path":"tags/index.html","permalink":"http://penglaidoll.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Python基础进阶——list与dict","slug":"python#9","date":"2021-03-10T03:21:16.876Z","updated":"2021-03-10T03:23:07.366Z","comments":true,"path":"posts/8a0f52d1/","link":"","permalink":"http://penglaidoll.xyz/posts/8a0f52d1/","excerpt":"","text":"再补充一下关于list和dict的一些基础知识 不可变对象与可变对象：Str,dict的key等都是不可变对象比如我们调用replace函数 123&gt;&gt;A &#x3D; &#39;abc&#39;&gt;&gt;A.replace(&#39;a&#39;,&#39;A&#39;)&#39;Abc&#39; 看上去是变了，但当我们再次输入A时，我们发现： 12&gt;&gt;A&#39;abc&#39; 换种方式来看看： 123&gt;&gt;B &#x3D; A.replace(&#39;a&#39;,&#39;A&#39;)&gt;&gt;B&#39;Abc&#39; 为什么呢，因为str是不可变对象，当我们对一个str对象调用任何方法时，都不会改变这个不可变对象，而是创建新的不同的对象并返回现在我们去理解dict的key为什么时不可变对象 list和dict的优缺点：在理解key为不可变对象之前，我们先看一下list与dict的优缺点和list相比，dict查找和插入对象的速度更快，但消耗的内存更高，更浪费内存，也就是说,dict牺牲了内存来换取速度，之所以这个样子，就要谈到dict的原理了 关于list与链表以下的内容是我在网上查阅大佬资料时找到的list其实是用链表的方式存储的。假如我们有一个列表a =[1,2,3]，我们知道，链表的名称存储第一个元素的地址，也就是相当于名称是指向第一个元素的指针，第一个元素的指针再指向第二个元素，以此类推，我们便实现了元素的顺序排列。当我们想插入或删除一个元素，比如我们想在第一个和第二个元素之间插入一个5，我们可以直接通过链表的形式来实现。先通过添加一个链节5，让第一个元素的指针指向该链节，再让该链节的指针指向原来的第二个元素，这样便实现了插入，也就是说，在内存中，这些元素不一定是顺序排列的，但也可以实现顺序访问当我们想要查找某个元素时，因为是链表，所以我们不得不从头开始遍历，这也就是为什么list查找这么慢的原因 关于dict与哈希表dict的存储方式与list截然不同，dict采用了一种哈希算法，将key值利用哈希算法转换为一个数，再利用这个数找到相对应的值，不同的key通过哈希算法得到的值有很大概率不同，所以不同的key存储的地方不同，这才有了一一对应的原则。举个栗子：有一个字典{‘a’:1,’b’:2,’c’:3},我们想利用key’c’来查找，首先利用哈希算法将key’c’算出一个值，咱假设为233，再在内存空间开辟一个大空间0-1000出来，然后根据算出来的值将’c’的value存进对应的内存空间中去，所有的键值对都是这样存储的，因此，当我们想要取一个key的value时，没必要全部遍历，直接用哈希算法去算，然后找到对应的就可以了，所以dict的查找速度很快,但我们不得不得提前开辟一个大空间，所以dict又很消耗内存由上，我们可以推知为什么key为不可变对象了,dict通过key来存储值，假如key变了，那么下一次寻找时寻到的地址不同了，整个dict不就乱了吗补充一点：不同的key通过哈希算法得到的值有很大概率不同，也就是说，有小概率是相同的，这就要求设计哈希表时要尽量减少冲突，这个就是设计编译器的事情了。","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python面向对象编程进阶②","slug":"python#8","date":"2021-03-10T03:17:27.799Z","updated":"2021-03-10T03:21:05.687Z","comments":true,"path":"posts/794c651c/","link":"","permalink":"http://penglaidoll.xyz/posts/794c651c/","excerpt":"","text":"对于类的定制：str:用于返回当前类的自定义名称举个栗子： 1234class pp(): name &#x3D; &#39;ff&#39; passprint(pp()) 这样的话，会输出以下内容 1&lt;__main__.pp object at 0x0000023A8A958E50&gt; 假如说，我们加入__str__方法：class pp(): 1234 name &#x3D; &#39;ff&#39; def __str__(self): return &#39;pp(name:%s)&#39; % &#39;ff&#39;print(pp()) 这样我们返回的就是： 1pp(name:ff) 也就是说，我们通过定义__str__方法，并返回我们想要输出的内容，那么当我们想要直接访问这个类时，系统会主动调用__str__方法，返回的不是类类型的标志语，而是我们自定义的内容 对于可迭代对象和迭代器的补充：之前我们说过，能被for直接作用的是可迭代对象，能使用next()方法的是迭代器，这里我们完善一下我们知道，一个对象中往往含有许多方法和属性，而dir函数可以帮助我们查看这些方法和属性。当我们对一个迭代器使用dir函数查看时，我们能看到其中有iter()和next()方法，这个很关键。在python中，若一个对象含有iter()方法，那么这个方法会返回一个可迭代对象，而若再含有__next__方法，那么这个对象就可以被调用next()方法，那么该对象就是迭代器由此，可迭代对象和迭代器都有__iter__方法，都可被for循环调用，迭代器中多了__next__方法，可用next()方法迭代由此，我们可以创建自己的可迭代对象了：以斐波那契数列为例： 12345678910class Fib(object): def __init__(self): self.a, self.b &#x3D; 0, 1 # 初始化两个计数器a，bdef __iter__(self): return self # 实例本身就是迭代对象，故返回自己def __next__(self): self.a, self.b &#x3D; self.b, self.a + self.b # 计算下一个值 if self.a &gt; 100: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 栗子中，我们定义了iter__方法使类实例化过程中返回一个可迭代对象，用__next__（）方法定义发生迭代的过程对于这个例子进行简单分析：__iter__使得一个对象成为可迭代对象__next__定义了该迭代器发生一次迭代的过程和结果StopIteration(终止异常):让一个迭代器终止迭代发生异常比如for循环自带异常处理，所以我们在遍历列表时不会因索引过大报错导致的程序终止,while循环则没有异常处理，所以我们在自定义可迭代对象时，为了防止无休止的迭代，要加上stopiteration异常，使之迭代到一定程度时触发异常，转而让异常处理来处理，从而终止迭代。在此处，并不是真的发生错误了，而是相当于换了一种方式告诉调用者已经迭代完毕。以上，我们发现自己所定义的迭代器并不支持索引调用其中的元素，这时，我们加入__getitem()方法的定义，这样，我们就可以通过访问下标索引的方式来访问可迭代对象中的元素 __getitem__方法当实例对象使用[]运算符取值时，会自动调用调用内建函数（方法）getitem()，并将[]中的内容作为一个参数传入__getitem__方法中。由此看出，当我们想通过访问下标的方式让自定义实例对象返回对应列表等可迭代对象或字典中的目标内容时，只需定义__getitem__对象使其返回就可举个栗子： 123456789class DataBase: def __init__(self): &#39;&#39;&#39;初始化方法&#39;&#39;&#39; self.lt &#x3D; [3,6,9] def __getitem__(self, key): return self.lt[key] data &#x3D; DataBase()print(data[1]) 输出： 1&gt;&gt;6 不难想到，列表的实现方式与这个如出一辙 __dict__属性之前我们用dir函数查看对象所含有或继承的方法和属性，现在我们介绍一个内置的__dict__属性，用它来查看某一对象自己的属性和方法，(当然，其作为对象的一个属性，它的作用之一也是存储这些信息)在这里，与dir有几点不同：1.dir函数生成的是list结构，其中只包括属性和方法的名称__dict__则展示了其作为dict的结构，key对应名称，value对应具体的值或方法定义2.dir函数生成全部的属性和方法(包括继承的)__dict__属性只展示部分属性或方法(不包括继承的)3.利用__dict__可以更改对象的属性，而dir不可栗子： 1Classname.__dict__[key] &#x3D; value 和正常的字典赋值差不多，就是多了一个类或实例访问另外，实例对象和类的__dict__属性有所不同举个栗子： 1234567891011class DataBase: def __init__(self): &#39;&#39;&#39;初始化方法&#39;&#39;&#39; self.lt &#x3D; [3,6,9] def __getitem__(self, key): return self.lt[key] def ff(self): return self.lt[2]data &#x3D; DataBase()print(data.__dict__)print(DataBase.__dict__) 返回 12&#123;&#39;lt&#39;: [3, 6, 9]&#125;&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;__init__&#39;: &lt;function DataBase.__init__ at 0x0000018994282040&gt;, &#39;__getitem__&#39;: &lt;function DataBase.__getitem__ at 0x00000189942820D0&gt;, &#39;ff&#39;: &lt;function DataBase.ff at 0x0000018994282160&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;DataBase&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;DataBase&#39; objects&gt;, &#39;__doc__&#39;: None&#125; 可见实例对象的__dict__属性仅包含self.xxx等的实例化属性，而类则相对包括更多的属性方法等(包括类函数，静态函数，全局变量等) 注意：如int,list,dict等的内置数据类型无__dict__属性","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"几种特殊的数据类型","slug":"CCpp#2","date":"2021-03-08T02:52:23.000Z","updated":"2021-03-08T03:09:48.468Z","comments":true,"path":"posts/85a1c1ed/","link":"","permalink":"http://penglaidoll.xyz/posts/85a1c1ed/","excerpt":"","text":"size_t全称为size type,属于一种整型类型，能够保存一个整数，这个整数往往是一个大小(size)，也就是说，size_t是用来记录大小的数据类型类似的还有wchar_t,ptrdiff_t wchar_t即wide char type,是一种记录一个宽字符的数据类型 ptrdiff_t即pointer difference type,用来记录两个指针之间的距离的数据类型 补充：一般来说，以上三种数据类型均需要typedef来实现，而程序员们为了方便使用和记忆而人为规定了这么几种，但在较新的C/C++标准中，wchar_t已经被涵盖在数据类型中了可以直接使用了，其他的数据类型可以在其他常见的头文件的代码中看到定义","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python内置函数总结","slug":"python#7","date":"2021-03-04T01:08:21.000Z","updated":"2021-03-08T02:59:48.837Z","comments":true,"path":"posts/cf4bdb1c/","link":"","permalink":"http://penglaidoll.xyz/posts/cf4bdb1c/","excerpt":"","text":"Python内置的函数及其用法。 分类为了方便记忆，已经有很多开发者将这些内置函数进行了如下分类： 数学运算(7个)类型转换(24个)序列操作(8个)对象操作(7个)反射操作(8个)变量操作(2个)交互操作(2个)文件操作(1个)编译执行(4个)装饰器(3个) 汇总数学运算abs 求数值的绝对值divmod 返回两个数值的商和余数max 返回可迭代对象中的元素中的最大值或者所有参数的最大值min 返回可迭代对象中的元素中的最小值或者所有参数的最小值pow 返回两个数值的幂运算值或其与指定整数的模值round 对浮点数进行四舍五入求值sum 对元素类型是数值的可迭代对象中的每个元素求和 类型转换bool 根据传入的参数逻辑值，创建一个新的布尔值int 根据传入的参数，创建一个新的整数float 根据传入的参数，创建一个新的浮点数complex 根据传入参数，创建一个新的复数str 返回一个对象的字符串表现形式(给用户)bytearray 根据传入的参数，创建一个新的字节数组bytes 根据传入的参数，创建一个新的不可变字节数组memoryview 根据传入的参数，创建一个新的内存查看对象ord 返回Unicode字符对应的整数chr 返回整数所对应的Unicode字符bin 将整数转换成2进制字符串oct 将整数转化成8进制数字符串hex 将整数转换成16进制字符串tuple 根据传入的参数，创建一个新的元组list 根据传入的参数，创建一个新的列表dict 根据传入的参数，创建一个新的字典set 根据传入的参数，创建一个新的集合frozenset 根据传入的参数，创建一个新的不可变集合enumerate 根据可迭代对象创建枚举对象range 根据传入的参数，创建一个新的range对象iter 根据传入的参数，创建一个新的可迭代对象slice 根据传入的参数，创建一个新的切片对象super 根据传入的参数，创建一个新的子类和父类关系的代理对象object 创建一个新的object对象 序列操作all 判断可迭代对象的每个元素是否都为True值any 判断可迭代对象的元素是否有为True值的元素filter 使用指定方法过滤可迭代对象的元素map 使用指定方法去作用传入的每个可迭代对象的元素，生成新的可迭代对象next 返回可迭代对象中的下一个元素值reversed 反转序列生成新的可迭代对象sorted 对可迭代对象进行排序，返回一个新的列表zip 聚合传入的每个迭代器中相同位置的元素，返回一个新的元组类型迭代器 对象操作help 返回对象的帮助信息dir 返回对象或者当前作用域内的属性列表id 返回对象的唯一标识符hash 获取对象的哈希值type 返回对象的类型，或者根据传入的参数，创建一个新的类型len 返回对象的长度ascii 返回对象的可打印表字符串表现方式format 格式化显示值 反射操作vars 返回当前作用域内的局部变量，和其值组成的字典，或者返回对象的属性列表isinstance 判断对象是否是类或者类型元组中任意类元素的实例issubclass 判断类是否是另外一个类或者类型元组中任意类元素的子类hasattr 检查对象是否含有属性getattr 获取对象的属性值setattr 设置对象的属性值delattr 删除对象的属性callable 检测对象是否可被调用 变量操作globals 返回当前作用域内的全局变量，和其值组成的字典locals 返回当前作用域内的局部变量，和其值组成的字典 交互操作print 向标准输出对象打印输出input 读取用户输入值 文件操作open 使用指定的模式和编码打开文件，返回文件读写对象 编译执行compile 将字符串编译为代码或者AST对象，使之能够通过exec语句来执行或者eval进行求值eval 执行动态表达式求值exec 执行动态语句块repr 返回一个对象的字符串表现形式(给解释器) 装饰器property 标示属性的装饰器classmethod 标示方法为类方法的装饰器staticmethod 标示方法为静态方法的装饰器具体每个函数的解析如下： 数学运算abs：求数值的绝对值 1234&gt;&gt;&gt; abs(-1)1&gt;&gt;&gt; abs(1)1 divmod：返回两个数值的商和余数 1234&gt;&gt;&gt; divmod(5,2)(2, 1)&gt;&gt; divmod(5.5,2)(2.0, 1.5) max：返回可迭代对象中的元素中的最大值或者所有参数的最大值 12345678&gt;&gt;&gt; max(1,2) # 传入参数 取较大者2&gt;&gt;&gt; max(&#39;123&#39;) # 传入1个可迭代对象，取其最大元素值&#39;3&#39;&gt;&gt;&gt; max(-1,0) # 数值默认取数值较大者0&gt;&gt;&gt; max(-1,0,key &#x3D; abs) # 传入了求绝对值函数，则参数都会进行求绝对值后再取较大者-1min：返回可迭代对象中的元素中的最小值或者所有参数的最小值 12345678&gt;&gt;&gt; min(1,2) # 传入3个参数 取3个中较小者1&gt;&gt;&gt; min(&#39;123&#39;) # 传入1个可迭代对象，取其最小元素值&#39;1&#39;&gt;&gt;&gt; min(-1,-2) # 数值默认去数值较小者-2&gt;&gt;&gt; min(-1,-2,key &#x3D; abs) # 传入了求绝对值函数，则参数都会进行求绝对值后再取较小者-1pow：返回两个数值的幂运算值或其与指定整数的模值 12345&gt;&gt;&gt; pow(2,3)&gt;&gt;&gt; 2**3 &gt;&gt;&gt; pow(2,3,4)&gt;&gt;&gt; pow(2,3)%4 round：对浮点数进行四舍五入求值 12&gt;&gt;&gt; round(1.16,1)1.1 sum：对元素类型是数值的可迭代对象中的每个元素求和 123# 传入可迭代对象，要求是数字&gt;&gt;&gt; sum((1,2,3))6————————————————本文转载自CSDN大佬「Holidaylovesam」的博客原文链接：点这里","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python面向对象编程进阶①","slug":"python#6","date":"2021-03-03T15:00:05.000Z","updated":"2021-03-08T03:11:50.899Z","comments":true,"path":"posts/e4b558a/","link":"","permalink":"http://penglaidoll.xyz/posts/e4b558a/","excerpt":"","text":"鸭子类型：存在于动态语言的一种现象，不用严格遵循继承体系也就是说，只要调用的对象中含有对应的方法，不用继承也可以实现多态的现象：如： 1234567891011121314class Person(): def wang(self): print(&#39;wang wang wang!&#39;) passclass Dog(): def wang(self): print(&#39;wang wang wang&#39;) passdef jiao(thing): thing.wang()p &#x3D; Dog()r &#x3D; Person()jiao(p)jiao(r) 其中，一个带感叹号，一个不带输出可以发现，二者均输出 12wang wang wangwang wang wang! 由此可知，python这样的动态语言注重的是方法，而不是繁杂的继承，有对应的方法就可以调用 1“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” 这就是鸭子测试 dir()函数——获得传入类内所有的属性和方法 实例属性和类属性：在类定义时定义的属性为类属性实例化时称为实例属性类属性归类所有，所有的实例均可访问若实例化时没有赋值那么默认属性则被赋值为类属性的值如有定义那么就赋值为实例属性的值 __slots__变量：给类绑定方法和属性：例子如下： 123456789class pp(): passpp.name &#x3D; &#39;pp&#39;o1 &#x3D; pp()print(o1.name)o1.tall &#x3D; 114514print(o1.tall)o2 &#x3D; pp()print(o2.tall) 如果我们将上面的代码输入，就可以观察到最后一行报错原因是tall实际上绑定到的是o1的实例而不是o类，所以实例化的o2没有tall属性，而name属性就是绑定到类上，所有实例化都可用 12345def f(self,x,y): print(x+y)from types import MethodType #从types包中引入methodtype函数，利用这个函数来绑定o1.f &#x3D; MethodType(f,o1) #函数的具体使用o1.f(3,5) 之后，我们再输入以上代码，向o1动态绑定f方法，同上面一样，这个是实例方法，无法在同类变量中使用，除非另行绑定加入我们想让一个类只能绑定我们规定好的属性或方法而无法绑定其他的属性或方法，该怎么办呢 __slots__变量：这个属于系统变量，用来限制该类能绑定的属性或方法举个栗子： 123456789class pp(): __slots__ &#x3D; (&#39;name&#39;) passpp.name &#x3D; &#39;pp&#39;def f(self,x,y): print(x+y)o1 &#x3D; pp()print(o1.name)o1.sound &#x3D; 114514 #(恶臭) 还是上面的代码，只不过我们加入了__slots__变量并规定了一个元组，其中包括了pp类可以绑定的name属性，当我们执行到o1.sound语句时，编译器报错，因为我们规定了除了name属性，其他都无法动态绑定再补充一点:__slots__变量只对当前类有用，对其子类无法起作用，除非子类再定义一个__slots__。如果子类再定义了，那么作为其父类中的__slots__也会得到继承，那么子类可以规定的属性和方法就是它及其父类__slots__变量中的和了 输入参数的检查：我们刚刚得知了给类绑定方法和属性的方法，可如果我们要求绑定的属性有个范围该怎么办呢。举个检查输入参数是否为int类型的例子吧 12if not isinstance(value,int) printf(&#39;error&#39;) isinstance函数可以帮助我们检验一个值是否为某一个类型，并返回true或false @property@property是python中的装饰器，可以用来创建只读属性，将一个方法转换为相同名称的只读属性 1.修饰方法，将其转换可以像属性一样访问1234class pp(): @property def ppff(self): return &#39;pp&#39; 假如没有@property,我们要想输出pp，则需输入 1pp().ppff() 但是有了@property，可以简化为 1pp().ppff 注意，用装饰器修改完之后，ppff函数将变成只读状态，无法再传入任何参数，如输入 1pp().ppff() 将会报错 2.与私有属性连用，防止私有属性被修改在之前我们先看一下私有属性的特点 123456class pp(): def __init__(self,name): self.__name &#x3D; name passp &#x3D; pp(&#39;p&#39;)print(p.__name) 以上，我们定义了一个私有属性__name在后面执行print语句时报错，说明我们无法访问__name这个私有属性，只能另行通过定义函数来返回__name属性的值，但如果我们在print语句前，pp类实例化语句之后加上这么一句 1p.__name &#x3D; &#39;pp&#39; 再执行后面的print语句，你会惊奇的发现，print语句正常执行了，我个人猜测，这个赋值语句改变了__name的私有属性状态而变成了普通的类属性为了防止其私有属性状态的改变和其值被更改，我们可以用@property 12345678910111213class DataSet(object): def __init__(self): self._images &#x3D; 1 self._labels &#x3D; 2 #定义属性的名称 @property def images(self): #方法加入@property后，这个方法相当于一个属性，这个属性可以让用户进行使用，而且用户有没办法随意修改。 return self._images @property def labels(self): return self._labelsl &#x3D; DataSet()#用户进行属性调用的时候，直接调用images即可，而不用知道属性名_images，因此用户无法更改属性，从而保护了类的属性。print(l.images) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（） 上面的例子我们可以将那两个方法改成其他的函数从而隐藏属性的名字而进行调用，让人以为是属性，而其实是方法变成的属性哒！","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"生成器与迭代器基础","slug":"python#5","date":"2021-03-01T14:25:20.000Z","updated":"2021-03-08T03:02:25.006Z","comments":true,"path":"posts/3d4ca4e0/","link":"","permalink":"http://penglaidoll.xyz/posts/3d4ca4e0/","excerpt":"","text":"列表生成式：当我们在用for循环来输出列表时，会很麻烦，特别是生成一些复杂的列表，除此之外，我们可以利用列表生成式如：要生成 1[1&#x3D;1,2&#x3D;2,3&#x3D;3.....] 可以用 1[x&#x3D;x for x in range(1,...)] 这样的式子我们称之为列表生成式还可以在第一个for后面跟上更多的循环来生成更复杂的全排列灵活运用列表生成式可以简化代码列表生成式的if：如: 1[x for x in range(1,11) if x%2&#x3D;&#x3D;0] 可以输出1到11的偶数这里if起的是筛选作用注意后面不可跟else，否则会报错如果在for前面放if则必须跟else表示条件不同，就一以不同的形式输出 生成器：上面我们解释了列表生成式，是把for循环放在列表标识符中的([]),如果我们把列表标识符改成()并且讲其赋值到一个变量中去，像是生成了一个元组一样，但实际上是创建了一个生成器(generator)并将其赋值到了变量之中生成器，顾名思义，可以将一种算法赋值到一个变量之中，根据算法来取到所需要的值。与列表生成器不同，不需要将所有元素都计算出来，而只在需要的时候才算出对应的元素，省去不必要的元素以节省空间使用next(generator)函数来求出下一个元素最好使用for循环来求出所需的元素举个栗子： 123g &#x3D; (x for x in range(1,10000))for i in g: print(i) 在这里，刚刚生成1到10000时，并不是直接占用了所有的内存，二十后面一步一步推算出来的这里之所以能用for，是因为生成器也是可迭代对象生成器的作用非常强大，可以实现算法的迭代当一个算法过于复杂而for列表生成器无法应对的时候比如生成斐波那契数列常规写法： 1234567def fib(max): n,a,b&#x3D;0,0,1 while n&lt;max: print(a) a,b &#x3D; b,a+b n&#x3D;n+1return &#39;done&#39; 由此观察a,b=b,a+b逻辑和生成器相近，都是走一步算一步（雾生成器写法： 1234567def fib(max): n,a,b&#x3D;0,0,1 while n&lt;max: yield b a,b&#x3D;b,a+b n&#x3D;n+1return &#39;done&#39; 解释：在函数定义过程中，只要加上了yield，就可以将函数变成生成器，正常函数为顺序执行，而生成器则会一直执行到首次遇见yield语句，并输出yield语句后面的参数，使用next()语句使其从当前的yield语句执行到下一条yield语句举个简单栗子： 12345def odd(): print &#39;step1&#39; yield 1 print &#39;step2&#39; yield(3) 调用时： 1234567&gt;&gt;o &#x3D; odd()&gt;&gt;next(o)step11&gt;&gt;next(o)step23 如上 注意：调用一个生成器时，会返回一个generate对象就像map一样，生成的是迭代器迭代器和可迭代对象：能被for循环直接作用的，我们称为可迭代对象而像生成器那样的，可以用next()函数调用并返回下一个值的我们称为迭代器，如map,generator。(迭代器也是可迭代对象)可以利用isinstance()来判断一个变量是否为迭代器迭代器对象表示的是一个数据流，我们不知道其有多长，知道数据全部输出完毕就会报错，而不是迭代器的可迭代对象我们往往知道其长度","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"C语言指针相关","slug":"CCpp#1","date":"2021-02-28T09:01:18.000Z","updated":"2021-03-08T03:09:19.756Z","comments":true,"path":"posts/34311c5c/","link":"","permalink":"http://penglaidoll.xyz/posts/34311c5c/","excerpt":"","text":"C指针：指针是一类储存地址的变量 指针数组：如果想让一个数组存储一组指向某一特定数据类型的地址，那么就能定义一个指针数组如：int *ptr[3];int var[]={10,100,200};for (i=0;i&lt;3;i++) { ptr[i] = var[i];}通过以上这段代码，var数组的每个值的每个地址都被存储在指针数组ptr中了 补充：“指针数组”和“数组指针”的区别：“指针数组”顾名思义，是指针的数组，他是元素均为指针的一个数组变量“数组指针”，则是指一个指向数组的指针变量，通常地址为数组第一个元素的地址。 指针函数：一个返回值为指针的函数C语言默认在调用函数时不可返回地址，除非讲局部变量定义为static变量具体的使用过程为——在函数定义声明返回值为指针，然后return一个相同类型的指针(具体的返回值为地址)例如： 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int * fhptr(int i) &#123; static int *s; s &#x3D; &amp;i; return s;&#125;void main() &#123; int *p; p &#x3D; fhptr(5); printf(&quot;%d %p&quot;,*p,p);&#125; 至于为什么要求局部变量要定义为static变量则是因为局部变量存储在内存的栈区，函数调用结束后，内存释放，函数内的变量便不再拥有那个内存地址，故指针无法返回。而static变量值存放在静态栈区，静态区只会在最初时初始化一回，之后便不会改变。 函数指针：指向函数的指针函数在编译后会占一部分内存，函数名则是函数的首地址(类似于数组)将一个指针赋以函数名的值则能让这个特殊的指针指向函数举个栗子： 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void func(int a) &#123; printf(&quot;%d&quot;,a);&#125;void main() &#123; int (*funcpointer)(int); funcpointer &#x3D; &amp;func; funcpointer(6);&#125; 注意：指向函数的指针不可自增运算也就是说，你能在此处通过调用函数指针来获得和调用该函数一样的效果(脱了裤子放屁)还记得当函数作为参数传入函数时需要将其转换为指针的形式吗，函数指针的真正作用则是用在这里 完善一下上面的例子： 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;&#x2F;&#x2F;定义一个 指向 返回类型为void，传入参数为一个Int类型的函数类型 的指针类型typedef void (*hhh) (int);void func(int a) &#123; printf(&quot;%d&quot;,a);&#125;void main() &#123; hhh p; p &#x3D; func; p(6);&#125; 函数指针数组：例子如下：int (*function_pointer)N;这个是其通用形式，分开来看Int (*function_pointer) [n] (int,int)首先它是一个指针，指向的是一个数组，什么数组呢，存了n个 参数为两个int类型，返回值为int的函数 的地址","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python中的类，模块，包","slug":"python#4","date":"2021-02-24T07:38:16.000Z","updated":"2021-03-08T03:02:01.510Z","comments":true,"path":"posts/8a35e780/","link":"","permalink":"http://penglaidoll.xyz/posts/8a35e780/","excerpt":"","text":"类：Python被设计为一门面向对象的编程语言，同其他面向对象的编程语言一样，它也有类这个概念：类可以认为是一个集合，用来容纳众多的相近的属性和方法，方便随时调用其中的变量和函数；对象则是类的实例化(把类赋值到一个变量中)，一个对象(也可以说一个类)有其对应的属性和方法；属性可以认为是类中定义的变量，分为类的属性和实例对象的属性；方法则是在类中定义的函数；一个简单的类实例： 12345678910class Pp: def __init__(self,a,b): self.a &#x3D; a self.b &#x3D; b self.c &#x3D; a + b print(&quot;初始化完毕！&quot;) def outsc(self): print(self.c)X &#x3D; Pp(2,3)x.outsc() 关于init:在把对象实例化之后会默认执行__init__方法，结合对__init__方法的定义，通常用来对对象初始化。除此之外，若想在对象实例化时就传入参数，必须调用__init__方法，不带__init__方法的类默认无法传入参数。 对于self的解释：类在定义方法时，传入的参数第一个必须是self，即使没有参数时，也要传入self，这里有一种解释，比如上例，Pp类实例化为x，这里self的作用实际上是把变量x在类内以self指代，所以类不管实例化为什么，self总是能把变量的名称传入类内以便调用。 模块：在Python中，一个模块可以认为是一个.py文件，它可以被其他.py文件用import函数引入，以便使用之前定义好的函数，类，变量什么的。 包：当多个用处相近的模块组合在一起，放在同一个文件夹这样的文件夹可以称为一个包。多个这样的文件夹合成一个大文件夹也可以称为一个包，则小文件夹又称为子包。包同样可以用import引入，其往往是一些制作者为了提供一系列的模块所制成，以方便调用。包内必须要有init.py文件、一个包的组成往往如下：Package1:|-init.py|-Module1.py|-Module2.py|-……调用方法为: 1From package1 import module1: 或 1Import package1.module1: 若包中一个模块需调用其他目录的模块，可在当前包目录下的init.py文件中添加sys.path.append(‘调用模块位置’)，然后再import __init__就可以了。","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"格式化字符串的三种方法","slug":"python#3","date":"2021-02-24T07:26:07.000Z","updated":"2021-03-08T03:01:41.221Z","comments":true,"path":"posts/6d69b5ea/","link":"","permalink":"http://penglaidoll.xyz/posts/6d69b5ea/","excerpt":"","text":"最古老的方法：——%-formatting格式化字符串类似于C语言，它是这么用的： 输入： 123Name &#x3D; &#39;world&#39;Id &#x3D; &#39;10&#39;Print(&#39;Hello %s,id&#x3D;%s&#39; % (name,id)) 输出： 1&#39;Hello world,id&#x3D;10&#39; 对于字典，同样适用：格式(%(key)s/d/g) 输入： 1Print(&#39;Hello %(name)s,id&#x3D;%(name)s&#39; % &#123;&#39;id&#39;:10 , &#39;name&#39; : &#39;world&#39;&#125;) 输出： 1Hello World,id&#x3D;10 后来的方法：——str.format()方法格式化字符串常规方法：输入： 12Name &#x3D; &#39;World&#39;Print(&#39;Hello &#123;&#125;&#39; % (name)) 输出： 1Hello World 通过位置访问的方法：输入： 1Print(&#39;&#123;2&#125;,&#123;1&#125;,&#123;0&#125;&#39;.format(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) 输出： 1C,b,a 通过关键字访问的方法：输入： 1Print(&#39;hi &#123;name&#125;&#39;.format(name &#x3D; &#39;howdy!&#39;)) 输出： 1Hi howdy! 新的方法：f-string格式化字符串Python3.6版本更新这一种方法，性能更优： 输入: 12345name &#x3D; &#39;hello world!&#39;D &#x3D; &#123;&#39;id&#39;:&#39;1&#39;,&#39;page&#39;:&#39;2&#39;&#125;Print(f&#39;print &#123;name&#125;&#39;)Print(f&#39;print &#123;name.upper()&#125;)Print(f&#39;turn to &#123;d[&quot;page&quot;]&#125;) 输出： 123Print hello worldPrint HELLO WORLDTurn to 2","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python中的交叉排序问题","slug":"python#2","date":"2021-02-22T03:12:17.000Z","updated":"2021-03-08T03:01:23.181Z","comments":true,"path":"posts/51641b53/","link":"","permalink":"http://penglaidoll.xyz/posts/51641b53/","excerpt":"","text":"在计蒜客中学习Python时，遇到了一个很有趣的排序问题： 输入一行 kk 个用空格分隔开的整数，依次为 n_1, n_2 … n_kn 1 ,n 2…n k。请将所有下标不能被 3 但可以被 2 整除的数在这些数字原有的位置上进行升序排列，此外，将余下下标能被 3 整除的数在这些数字原有的位置上进行降序排列。输出包括一行，与输入相对应的若干个整数，为排序后的结果，整数之间用空格分隔。 自己琢磨了很长时间，其中也发现了各种各样的问题，下面分享一下： 输入例：1 5 4 3 10 7 19输出例：1 3 7 5 10 4 19 程序样例1234567891011121314151617181920212223242526272829n = [int(x) for x in input().split(&#x27; &#x27;)]n1 = []n2 = []n3 = []nc= []# 将满足下标不同条件的列表中的数放入不同的空列表中for index in range(len(n)): if ((index+1) % 3 != 0) and ((index+1) % 2 == 0): n1.append(n[index]) elif ((index+1) % 3 ==0): n2.append(n[index]) else: n3.append(n[index])# 列表排序n1.sort()n2.sort(reverse = True)# 再将列表元素按照原序依次放回for index in range(len(n)): if ((index+1) % 3 != 0) and ((index+1) % 2 == 0) and n1: nc.append(n1.pop(0)) elif ((index+1) % 3 ==0) and n2: nc.append(n2.pop(0)) elif n3: nc.append(n3.pop(0))# 按照格式输出for i in range(len(n)): print(nc[i],end=&#x27; &#x27;) 格式化输入比如以空格相间隔的数据的输入：100 200 300可以用下面的方式读取 12345678# example 1x = [int(i) for i in input().split(&#x27; &#x27;)# exapmle 2x = map(int,input().split(&#x27; &#x27;)) 其中，input().split(‘ ‘)是将输入的数据以split函数传入的参数为标志进行分割并返回分割后的列表(注：split函数返回的列表为字符串列表！！！）example 2是一种比较巧妙的方法 判断列表是否为空1234567a = []if a: print(&#x27;YES&#x27;)else: print(&#x27;NO&#x27;) 以上只是个例子，是为了说明若一个列表为空，则其对应布尔值为False可以利用这个来判断一个列表是否为空程序例子中使用这个判断来防止列表空时pop()函数对空列表使用报错 参考：点这里 [点这里](https://blog.csdn.net/weixin_43113241/article/details/109965485）","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python中的_name_属性","slug":"python#1","date":"2021-02-19T11:36:03.000Z","updated":"2021-03-08T03:00:28.549Z","comments":true,"path":"posts/e599f77d/","link":"","permalink":"http://penglaidoll.xyz/posts/e599f77d/","excerpt":"","text":"刚开始学习python，接触到 1If _name_ == &#x27;_main_&#x27;: 这句话并不是很了解，以下是解答： Python中的模块与C,C++的头文件python如同C，C++等其他编程语言相似，可以引入(import)外部文件，在python中，引入的每个文件，以及自身的代码文件又叫模块，不同于C和C++，python中的模块可以独立运行，而C和C++中的头文件会首先执行 _name_属性1.name_是一个系统定义的变量，用来存储模块的名字或状态，假如一个模块为主函数(通常为引入其他模块的模块)则其模块内包含的_name_变量被赋值为“_main_”；若该模块是被引入的模块，则其_name_变量被赋值为(模块名无后缀)2.通过判断_name_所被赋的值的方式，可以判断该模块是否被引入或为主函数3.通常与if _name ==’main‘结合使用减少bug 总结自：点这里","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]}],"categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"},{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]}