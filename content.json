{"meta":{"title":"PengLaiDoll网安学习心得","subtitle":"","description":"","author":"PengLaiDoll","url":"http://penglaidoll.xyz","root":"/"},"pages":[{"title":"关于个人","date":"2021-02-24T08:09:19.080Z","updated":"2021-02-24T08:09:19.080Z","comments":true,"path":"about/index.html","permalink":"http://penglaidoll.xyz/about/index.html","excerpt":"","text":"PengLaiDoll一个苦逼但仍在不断努力的共和国预备警官(笑)Wechat:wxpenglaidoll欢迎前来交流(笑)小站简陋但定实时更新敬请谅解"},{"title":"分类","date":"2021-02-19T12:04:00.000Z","updated":"2021-02-19T12:11:14.290Z","comments":true,"path":"categories/index.html","permalink":"http://penglaidoll.xyz/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-02-19T12:07:14.000Z","updated":"2021-02-19T12:11:30.960Z","comments":true,"path":"tags/index.html","permalink":"http://penglaidoll.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"UPX壳与Aspack壳脱壳","slug":"re#1","date":"2021-03-27T15:32:00.000Z","updated":"2021-03-27T15:39:26.654Z","comments":true,"path":"posts/b3843843/","link":"","permalink":"http://penglaidoll.xyz/posts/b3843843/","excerpt":"","text":"UPX壳： 单步步进法 ESP定理 全栈入栈，单步步进，发现只有ESP寄存器发生改变，跟随ESP寄存器到数据窗口，下硬件断点，执行文件，到断点处发现全栈出栈指令，应该是到oep了。 查找法（有限制） 既然有pushad，肯定有popad，在当前块直接查找popad，说不定就找到了 二次内存镜像法 在第一个.rsrc段下字节断点，运行，随后在00401000处下段点，运行，之后便接近oep了 Aspack壳： 单步步进发 ESP定理 查找法 二次内存镜像法 模拟跟踪法 找到内存中的sfx部分，输入指令tc eip&lt;(该段地址)执行到指定部分，便到了oep SFX 打开调试设置，找到SFX，利用OD自动找到oep","categories":[{"name":"逆向学习——OD脱壳","slug":"逆向学习——OD脱壳","permalink":"http://penglaidoll.xyz/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94OD%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"OD","slug":"OD","permalink":"http://penglaidoll.xyz/tags/OD/"},{"name":"脱壳","slug":"脱壳","permalink":"http://penglaidoll.xyz/tags/%E8%84%B1%E5%A3%B3/"},{"name":"UPX壳","slug":"UPX壳","permalink":"http://penglaidoll.xyz/tags/UPX%E5%A3%B3/"},{"name":"Aspack壳","slug":"Aspack壳","permalink":"http://penglaidoll.xyz/tags/Aspack%E5%A3%B3/"}]},{"title":"常见OPE","slug":"re#2","date":"2021-03-27T15:32:00.000Z","updated":"2021-03-27T15:41:17.380Z","comments":true,"path":"posts/2a1f355e/","link":"","permalink":"http://penglaidoll.xyz/posts/2a1f355e/","excerpt":"","text":"五种常见语言的OEP特征：C++ （Microsoft Visual C++ 6.0）0040577C &gt;/$ 55 PUSH EBP (C的入口) 0040577D |. 8BEC MOV EBP,ESP 0040577F |. 6A FF PUSH -1 00405781 |. 68 30B24000 PUSH EasyClea.0040B230 00405786 |. 68 84704000 PUSH EasyClea.00407084 ; SE 句柄安装 0040578B |. 64:A1 0000000&gt;MOV EAX,DWORD PTR FS:[0] 00405791 |. 50 PUSH EAX 00405792 |. 64:8925 00000&gt;MOV DWORD PTR FS:[0],ESP 00405799 |. 83EC 58 SUB ESP,58 0040579C |. 53 PUSH EBX 0040579D |. 56 PUSH ESI 0040579E |. 57 PUSH EDI 0040579F |. 8965 E8 MOV [LOCAL.6],ESP 004057A2 |. FF15 ECB04000 CALL DWORD PTR DS:[&lt;&amp;KERNEL32.GetVersion&gt;; kernel32.GetVersion -——————————————————————————————————————————– E语言这个和C极度像,要分清 0040389F &gt;/$ 55 PUSH EBP 004038A0 |. 8BEC MOV EBP,ESP 004038A2 |. 6A FF PUSH -1 004038A4 |. 68 F8724000 PUSH CrackMe.004072F8 004038A9 |. 68 04554000 PUSH CrackMe.00405504 ; SE 处理程序安装 004038AE |. 64:A1 0000000&gt;MOV EAX,DWORD PTR FS:[0] 004038B4 |. 50 PUSH EAX 004038B5 |. 64:8925 00000&gt;MOV DWORD PTR FS:[0],ESP 004038BC |. 83EC 58 SUB ESP,58 004038BF |. 53 PUSH EBX 004038C0 |. 56 PUSH ESI 004038C1 |. 57 PUSH EDI 004038C2 |. 8965 E8 MOV DWORD PTR SS:[EBP-18],ESP 004038C5 |. FF15 48704000 CALL DWORD PTR DS:[&lt;&amp;KERNEL32.GetVersion&gt;; kernel32.GetVersion 004038CB |. 33D2 XOR EDX,EDX 004038CD |. 8AD4 MOV DL,AH 004038CF |. 8915 94BA4000 MOV DWORD PTR DS:[40BA94],EDX 004038D5 |. 8BC8 MOV ECX,EAX 004038D7 |. 81E1 FF000000 AND ECX,0FF 004038DD |. 890D 90BA4000 MOV DWORD PTR DS:[40BA90],ECX 004038E3 |. C1E1 08 SHL ECX,8 004038E6 |. 03CA ADD ECX,EDX 004038E8 |. 890D 8CBA4000 MOV DWORD PTR DS:[40BA8C],ECX 004038EE |. C1E8 10 SHR EAX,10 004038F1 |. A3 88BA4000 MOV DWORD PTR DS:[40BA88],EAX 004038F6 |. 33F6 XOR ESI,ESI 004038F8 |. 56 PUSH ESI 004038F9 |. E8 7A030000 CALL CrackMe.00403C78 004038FE |. 59 POP ECX 004038FF |. 85C0 TEST EAX,EAX 00403901 |. 75 08 JNZ SHORT CrackMe.0040390B 00403903 |. 6A 1C PUSH 1C -——————————————————————————————————————————– Delphi （Borland Delphi 6.0 - 7.0）004F2F68 &gt; $ 55 PUSH EBP 004F2F69 . 8BEC MOV EBP,ESP 004F2F6B . 83C4 F0 ADD ESP,-10 004F2F6E . 53 PUSH EBX 004F2F6F . B8 102B4F00 MOV EAX,Unpacked.004F2B10 004F2F74 . E8 EF3BF1FF CALL Unpacked.00406B68 004F2F79 . 8B1D F4505000 MOV EBX,DWORD PTR DS:[5050F4] ; Unpacked.00506C14 004F2F7F . 8B03 MOV EAX,DWORD PTR DS:[EBX] 004F2F81 . E8 56ACF8FF CALL Unpacked.0047DBDC 004F2F86 . 8B03 MOV EAX,DWORD PTR DS:[EBX] 004F2F88 . BA F42F4F00 MOV EDX,Unpacked.004F2FF4 ; ASCII “ Hide Private File Pro” 004F2F8D . E8 32A8F8FF CALL Unpacked.0047D7C4 004F2F92 . 8B0D 904E5000 MOV ECX,DWORD PTR DS:[504E90] ; Unpacked.00509144 004F2F98 . 8B03 MOV EAX,DWORD PTR DS:[EBX] 004F2F9A . 8B15 70E44E00 MOV EDX,DWORD PTR DS:[4EE470] ; Unpacked.004EE4BC 004F2FA0 . E8 4FACF8FF CALL Unpacked.0047DBF4 004F2FA5 . 8B0D 3C525000 MOV ECX,DWORD PTR DS:[50523C] ; Unpacked.0050909C 004F2FAB . 8B03 MOV EAX,DWORD PTR DS:[EBX] 004F2FAD . 8B15 48B14E00 MOV EDX,DWORD PTR DS:[4EB148] ; Unpacked.004EB194 004F2FB3 . E8 3CACF8FF CALL Unpacked.0047DBF4 004F2FB8 . 8B0D 0C535000 MOV ECX,DWORD PTR DS:[50530C] ; Unpacked.005090A4 004F2FBE . 8B03 MOV EAX,DWORD PTR DS:[EBX] 004F2FC0 . 8B15 7CB34E00 MOV EDX,DWORD PTR DS:[4EB37C] ; Unpacked.004EB3C8 004F2FC6 . E8 29ACF8FF CALL Unpacked.0047DBF4 004F2FCB . 8B0D 30505000 MOV ECX,DWORD PTR DS:[505030] ; Unpacked.005090D4 004F2FD1 . 8B03 MOV EAX,DWORD PTR DS:[EBX] 004F2FD3 . 8B15 B0BF4E00 MOV EDX,DWORD PTR DS:[4EBFB0] ; Unpacked.004EBFFC 004F2FD9 . E8 16ACF8FF CALL Unpacked.0047DBF4 004F2FDE . 8B03 MOV EAX,DWORD PTR DS:[EBX] 004F2FE0 . E8 8FACF8FF CALL Unpacked.0047DC74 004F2FE5 . 5B POP EBX 004F2FE6 . E8 7115F1FF CALL Unpacked.0040455C 004F2FEB . 00FF ADD BH,BH 004F2FED FF DB FF -——————————————————————————————————————————– VB （Microsoft Visual Basic 5.0 / 6.0）00410400 &gt; 68 4C744100 PUSH Unpack_.0041744C ; ASCII “VB5!6&amp;*” 00410405 E8 EEFFFFFF CALL &lt;JMP.&amp;msvbvm60.ThunRTMain&gt; 0041040A 16 PUSH SS 0041040B 0000 ADD BYTE PTR DS:[EAX],AL 0041040D 0000 ADD BYTE PTR DS:[EAX],AL 0041040F 0030 ADD BYTE PTR DS:[EAX],DH 00410411 0000 ADD BYTE PTR DS:[EAX],AL 00410413 0038 ADD BYTE PTR DS:[EAX],BH 00410415 0000 ADD BYTE PTR DS:[EAX],AL 00410417 0000 ADD BYTE PTR DS:[EAX],AL 00410419 0000 ADD BYTE PTR DS:[EAX],AL 0041041B 0060 9C ADD BYTE PTR DS:[EAX-64],AH 0041041E F0:E2 CF LOCK LOOPD SHORT Unpack_.004103F0 ; 不允许锁定前缀 00410421 BE 3D439505 MOV ESI,595433D 00410426 E1 06 LOOPDE SHORT Unpack_.0041042E 00410428 18A5 05D40000 SBB BYTE PTR SS:[EBP+D405],AH 0041042E 0000 ADD BYTE PTR DS:[EAX],AL 00410430 0000 ADD BYTE PTR DS:[EAX],AL 00410432 0100 ADD DWORD PTR DS:[EAX],EAX 00410434 0000 ADD BYTE PTR DS:[EAX],AL 00410436 9E SAHF -——————————————————————————————————————————– BC++ （Borland C++ 1999）00401000 &gt; /EB 10 JMP SHORTXXXXXXX.00401012 00401002 |66:623A BOUND DI,DWORD PTR DS:[EDX] 00401005 |43 INC EBX 00401006 |2B2B SUB EBP,DWORD PTR DS:[EBX] 00401008 |48 DEC EAX 00401009 |4F DEC EDI 0040100A |4F DEC EDI 0040100B |4B DEC EBX 0040100C |90 NOP 0040100D -|E9 AC334800 JMP 008843BE 00401012 \\A1 9F334800 MOV EAX,DWORD PTR DS:[48339F] 00401017 C1E0 02 SHL EAX,2 0040101A A3 A3334800 MOV DWORD PTR DS:[4833A3],EAX 0040101F 52 PUSH EDX 00401020 6A 00 PUSH 0 00401022 E8 11110800 CALL &lt;JMP.&amp;KERNEL32.GetModuleHandleA&gt; 00401027 8BD0 MOV EDX,EAX 00401029 E8 3A1B0600 CALLXXXXXXX.00462B68 0040102E 5A POP EDX 0040102F E8 981A0600 CALLXXXXXXX.00462ACC 00401034 E8 6F1B0600 CALLXXXXXXX.00462BA8 00401039 6A 00 PUSH 0 0040103B E8 782E0600 CALLXXXXXXX.00463EB8 00401040 59 POP ECX 00401041 68 48334800 PUSHXXXXXXX.00483348 00401046 6A 00 PUSH 0 00401048 E8 EB100800 CALL &lt;JMP.&amp;KERNEL32.GetModuleHandleA&gt; 0040104D A3 A7334800 MOV DWORD PTR DS:[4833A7],EAX 00401052 6A 00 PUSH 0 00401054 E9 6B900600 JMPXXXXXXX.0046A0C4 00401059 &gt; E9 A62E0600 JMPXXXXXXX.00463F04 -——————————————————————————————————————————– Dasm:汇编00401000 &gt;/$ 6A 00 PUSH 0 ; /pModule = NULL 00401002 |. E8 C50A0000 CALL &lt;JMP.&amp;KERNEL32.GetModuleHandleA&gt; ; \\GetModuleHandleA 00401007 |. A3 0C354000 MOV DWORD PTR DS:[40350C],EAX 0040100C |. E8 B50A0000 CALL &lt;JMP.&amp;KERNEL32.GetCommandLineA&gt; ; [GetCommandLineA 00401011 |. A3 10354000 MOV DWORD PTR DS:[403510],EAX 00401016 |. 6A 0A PUSH 0A ; /Arg4 = 0000000A 00401018 |. FF35 10354000 PUSH DWORD PTR DS:[403510] ; |Arg3 = 00000000 0040101E |. 6A 00 PUSH 0 ; |Arg2 = 00000000 00401020 |. FF35 0C354000 PUSH DWORD PTR DS:[40350C] ; |Arg1 = 00000000 另一种： 00401025 &gt;/$ 6A F6 PUSH -0A 00401027 |. E8 A0000000 CALL &lt;JMP.&amp;kernel32.GetStdHandle&gt; 0040102C |. A3 00304000 MOV DWORD PTR DS:[403000],EAX 00401031 |. 6A F5 PUSH -0B 00401033 |. E8 94000000 CALL &lt;JMP.&amp;kernel32.GetStdHandle&gt; 00401038 |. A3 04304000 MOV DWORD PTR DS:[403004],EAX 0040103D |. 6A 01 PUSH 1 0040103F |. 68 00104000 PUSH EchoLine.00401000 00401044 |. E8 8F000000 CALL &lt;JMP.&amp;kernel32.SetConsoleCtrlHandle&gt; 00401049 |. 6A 07 PUSH 7 0040104B |. FF35 00304000 PUSH DWORD PTR DS:[403000] Vc++8.000403A30 &gt; $ E8 6E270000 call VC8.004061A3 00403A35 .^ E9 79FEFFFF jmp VC8.004038B3 00403A3A /$ 55 push ebp 00403A3B |. 8BEC mov ebp,esp 00403A3D |. 83EC 08 sub esp,0x8 00403A40 |. 897D FC mov [local.1],edi ; ntdll.7C930228 00403A43 |. 8975 F8 mov [local.2],esi 00403A46 |. 8B75 0C mov esi,[arg.2] 00403A49 |. 8B7D 08 mov edi,[arg.1] ; VC8. 00403A4C |. 8B4D 10 mov ecx,[arg.3] 00403A4F |. C1E9 07 shr ecx,0x7 转载自52论坛https://www.52pojie.cn/thread-139728-1-1.html","categories":[{"name":"逆向学习——OD","slug":"逆向学习——OD","permalink":"http://penglaidoll.xyz/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94OD/"}],"tags":[{"name":"脱壳，oep","slug":"脱壳，oep","permalink":"http://penglaidoll.xyz/tags/%E8%84%B1%E5%A3%B3%EF%BC%8Coep/"}]},{"title":"global和nonlocal的使用","slug":"python#12","date":"2021-03-24T15:04:14.000Z","updated":"2021-03-27T15:33:12.699Z","comments":true,"path":"posts/6d738442/","link":"","permalink":"http://penglaidoll.xyz/posts/6d738442/","excerpt":"","text":"global关键字如下一段代码： 12345678910111213count = 1def main(): count count+=1 print(count) main() 我们会发现程序报错而无法正常执行，这是因为count变量是全局变量，而在局部中是无法修改全局变量的 如果我们改成下面这样 ` 1234567891011count = 1def main(): global count count+=1 print(count)main() ` 程序可以正常执行了！ 这里global关键字可以让全局变量在局部中进行更改，只需要声明就行。 假如不进行声明也不修改呐？ 12345678910111213count = 1def main(): count count+=1 print(count)main() 是可以正常运行的 nonlocal关键字假如我们在一段函数定义中再引入一个函数定义而形成嵌套 12345678910111213def main(): count = 1 def pp(): nonlocal count print(count) pp()main() 这里可以看出，nonlocal声明是针对在嵌套函数的上一个函数的声明的使用 输出为 11","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python中对于文件的操作","slug":"python#11","date":"2021-03-19T15:57:01.000Z","updated":"2021-03-23T07:51:14.732Z","comments":true,"path":"posts/140ab620/","link":"","permalink":"http://penglaidoll.xyz/posts/140ab620/","excerpt":"","text":"对于文件的更改：Open函数：python中利用open函数来实现对文件的读取和更改举个栗子： 1234def main(): a &#x3D; open(&#39;a.txt&#39;,&#39;w&#39;,encoding&#x3D;utf-8) printf(a.read()) a.close() 这里我们用open()函数打开一个文件，注意open函数的返回值为一个对象，之后，我们对这个对象使用read方法来实现对文档的读取下面是对于传入的第二个参数的解释，其决定了open的操作模式| 操作模式 | 具体含义 || ——– | ——————————– || &#39;r&#39; | 读取 （默认） || &#39;w&#39; | 写入（会先截断之前的内容） || &#39;x&#39; | 写入，如果文件已经存在会产生异常 || &#39;a&#39; | 追加，将内容写入到已有文件的末尾 || &#39;b&#39; | 二进制模式 || &#39;t&#39; | 文本模式（默认） || &#39;+&#39; | 更新（既可以读又可以写） | With open as:当我们使用Open函数以后，我们不得不用close方法来对文件进行关闭，我们更常用的是这个 123def main(): with open(&#39;a.txt&#39;,&#39;w&#39;,encoding&#x3D;utf-8) as a: printf(a.read()) With open as 可以根据我们的使用情况(上下文环境)而适时关闭文件 Try:继续上面的代码，当我们当前目录的文件夹中无a.txt文件时，程序会报错，那么怎么避免这种情况呐 12345678910111213def main(): try: with open(&#39;a.txt&#39;,&#39;w&#39;,encoding&#x3D;utf-8) as a: printf(a.read()) except FileNotFoundError: print(&#39;无法打开指定的文件!&#39;) except LookupError: print(&#39;指定了未知的编码!&#39;) except UnicodeDecodeError: print(&#39;读取文件时解码错误!&#39;) finally: if a: print(&#39;Complete!&#39;) 这里引入了try except finally函数，这个函数可以根据不同的报错情况来选择性输出，属于选择结构，最后的finally又叫做“总要执行”，无论上述出现什么情况，这一语句总要执行，多用这个语句来保证程序的正确执行 For I in a.readlines():这一语句是用来整行遍历要读取的文件的内容","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python面向对象编程进阶③","slug":"python#10","date":"2021-03-19T14:47:37.000Z","updated":"2021-03-19T15:57:15.747Z","comments":true,"path":"posts/e04534a6/","link":"","permalink":"http://penglaidoll.xyz/posts/e04534a6/","excerpt":"","text":"静态方法与类方法静态方法：使用@staticmethod装饰器进行装饰可以直接被类调用而不用实例化假如我们要判定一个三角形是不是三角形 12345678910111213class San(): def __init__(self,a,b,c): self.__a &#x3D; a self.__b &#x3D; b self.__c &#x3D; c @staticmethod def is_right(a,b,c): if ((a+b&gt;c)&amp;(a+c&gt;b)&amp;(b+c&gt;a)): return True else: return Falses &#x3D; San(3,4,5)s.is_right() 这样我们会发现报错，显示 1is_right() missing 3 required positional arguments: &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; 这里我们就能看出，静态方法是不传入实例化参数的这样一来，我们可以在三角形S实例化之前用该方法判断S的三个边能否组成一个三角形静态方法的调用与实例化无关，只与该类和其定义有关 类方法使用@classmethod装饰器进行装饰传入的参数第一个必须为cls(表示传入类它自己)别的和普通方法差不多 三种方法的主要区别：普通方法第一个传入的参数是self，表示该方法引用的的有可能是类属性/方法，也有可能是实例属性/方法，实例的优先级大于类的类方法第一个传入的参数为cls，表示该方法引用的是类属性/方法静态方法类似于函数定义，只传入定义的东西","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"typedef与#define","slug":"CCpp#6","date":"2021-03-18T08:52:33.000Z","updated":"2021-03-18T08:55:40.508Z","comments":true,"path":"posts/3cbd2c1d/","link":"","permalink":"http://penglaidoll.xyz/posts/3cbd2c1d/","excerpt":"","text":"Typedef与#define几个区别： 1.typeof只能为类型定义一个别的符号名称，(#define)不仅能为类型定义别名，还能为数值定义别名2.typedef由编译器执行解释，(#define)由预编译器处理3.(#define)可以用其他类型说明符进行补充，而typeof不行 栗子： 1234#define p int;unsigned p n;&#x2F;&#x2F;可以typedef int p;unsigned p n;&#x2F;&#x2F;不可以 （这里可以看出，#define实际上起的是等量代换作用，而typedef不是）4.连续定义变量中#define的弱点栗子： 12#define a char *;a b,c; 等效于 1char *b,c; 也就是说，只有b被定义为了指针，c仍为字符变量 12typedef char* a;a b,c; 这里，可以将b,c都定义为字符变量指针","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"巧用异或交换数","slug":"CCpp#5","date":"2021-03-18T08:46:46.000Z","updated":"2021-03-18T08:50:56.342Z","comments":true,"path":"posts/994d2d1d/","link":"","permalink":"http://penglaidoll.xyz/posts/994d2d1d/","excerpt":"","text":"利用异或交换两个变量中存储的数正常情况下，我们通常定义swap利用地址交换两个变量中的值但如果我们只是交换两个整型变量的值呐？这里可以用到异或的小性质了 假设两个整形8bit的2进制数a,b交换的原理为 12a&#96;&#x3D;(a^b)^bb&#96;&#x3D;(a^b)^a&#96; 说说第一个的原理 12345a b a^b a&#96;1 1 0 11 0 1 10 1 1 00 0 0 0 由上推出，一个数，被同一个数异或两遍，数的大小不变","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"逻辑运算的短路性","slug":"CCpp#4","date":"2021-03-18T08:44:30.000Z","updated":"2021-03-18T08:50:56.336Z","comments":true,"path":"posts/d11843d/","link":"","permalink":"http://penglaidoll.xyz/posts/d11843d/","excerpt":"","text":"逻辑运算的短路性（表达式1）&amp;&amp;（表达式2）若表达式1为假，总式子一定为假，表达式2被短路（表达式1）||（表达式2）若表达式1为真，总式子一定为真，表达式2被短路 补充一下应用在网络上看到一个微软的面试题：求 1 + 2 + 3 + … + n要求：不能用乘除法，不能用if,while, switch,case, 不能用(a &lt; b ? a : b)三目运算符程序如下： 1234567891011121314#include &lt;stdio.h&gt;int fun(int n) &#123; int p&#x3D;0; int sum&#x3D;0; p &#x3D; n &amp;&amp; (sum&#x3D;n+fun(n-1)); return sum;&#125;int main() &#123; int a&#x3D;3,b; b &#x3D; fun(a); printf(&quot;%d&quot;,b); return 0; &#125; 这里面非常巧妙地用到了逻辑运算的短路原理，当n为0时，便不再执行后续语句，这上面的p只起到存储过程量的作用，可以忽略不看 原帖点这里","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"数据结构入门","slug":"data str#1","date":"2021-03-16T15:26:15.000Z","updated":"2021-03-16T15:47:36.098Z","comments":true,"path":"posts/4729e793/","link":"","permalink":"http://penglaidoll.xyz/posts/4729e793/","excerpt":"","text":"最近一段时间开始为了提高编程本领而开始学习数据结构了，据说学习好了不仅编程技巧直线上升，考试不挂科了，对Reverse也有好处(笑)便开始了万里长征的第一步 在网上搜索了一下关于数据结构的内容，大致这门课是学习如何更好的存储数据，据我自己感觉，学数据结构最大的作用就是让我们去获得更好的编程逻辑，以及我们日常用的如py中的dict,list，C中的链表，汇编经常用的栈等的实现原理也就是说，不学这个并不影响你去编程，但会决定你是不是一个好的程序员，而且，有了这些底层的理解，我们就更容易去理解他人的程序抱着成为更好的自己的信念，努力吧！ 数据结构的理解数据结构有两个要素，一个是数据元素的集合，另一个是关系的集合形式上，通常用二元组来表示 分类按照元素关系不同，分为以下四种 1234|--集合结构(元素属于同一集合)|--线性结构(元素一对一的关系)(常见列表，队列，栈等)|--树形结构(元素一对多的关系)(常见二叉树，二叉查找树，平衡二叉查找树等)|--图形结构(元素多对多的关系) 按照存储方式不同，分为以下两种 12|--顺序存储结构(数据元素在存储器中连续存储)|--链式存储结构(每个元素里设置了指向下一个元素的指针) 算法复杂度：时间频度，指算法中语句的执行次数，一般用T(n)表示，n为问题的规模有时，时间频度的表示方法过于复杂，于是又引入了时间复杂度，这个只关心算法中最耗时的部分，通常用时间频度中最能决定其大小的简单函数来表示空间复杂度指运行该算法所占用的存储空间大小，记为S(n)","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://penglaidoll.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://penglaidoll.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"记录一次作业","slug":"CCpp#3","date":"2021-03-14T23:26:54.000Z","updated":"2021-03-18T07:24:05.241Z","comments":true,"path":"posts/f5d29790/","link":"","permalink":"http://penglaidoll.xyz/posts/f5d29790/","excerpt":"","text":"学校开了C语言课，老师布置了一个简单的小程序，输入一个三位整数，然后分别输出这个数的个位，十位，百位，为了写出一个比较完善的代码，花了不少心思，也学了不少东西，在此记录一下： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void main() &#123; &#x2F;&#x2F;定义字符数组，以存储输入的数字 char strin[1024]; &#x2F;&#x2F;定义一个指针，以确保strlen函数的正常运行 char *strin_ptr; &#x2F;&#x2F;将i初始化为零，以防初始化导致i的随机定义进而导致内存中混进莫名的东西 &#x2F;&#x2F;其实这里也可以不初始化，因为if的第一个判断条件已经避免这个问题了 int i&#x3D;0,p; strin_ptr &#x3D; strin; &#x2F;&#x2F;do while将先执行一遍传入需要的数字，然后进行判断，若符合要求，则不再执行循环 do &#123; &#x2F;&#x2F;清空缓冲区 fflush(stdin); printf(&quot;Please input 3 integer:\\n&quot;); scanf(&quot;%d&quot;,&amp;i); &#x2F;&#x2F;itoa将整形转换为字符，以便存储和计数 itoa(i,strin,10); &#x2F;&#x2F;利用strlen判断输入数字的位数 p &#x3D; strlen(strin_ptr); &#x2F;&#x2F;判断位数、类型是否符合 if ((t &#x3D;&#x3D; 0)|| (strin[0]&#x3D;&#x3D;&#39;0&#39;) || (p !&#x3D; 3)) &#123; printf(&quot;This is ont a right integer,please input again!\\n&quot;); &#125; &#125; while ((t &#x3D;&#x3D; 0) || (strin[0]&#x3D;&#x3D;&#39;0&#39;) || (p !&#x3D; 3)); printf(&quot;Hundred position &#x3D; %c\\n&quot;,strin[0]); printf(&quot;Ten position &#x3D; %c\\n&quot;,strin[1]); printf(&quot;Individual position &#x3D; %c\\n&quot;,strin[2]); system(&quot;pause&quot;);&#125; 缓冲区问题：fflush(stdin)在此之前，我的代码是直接用的while循环且没有fflush(stdin)这一语句，如下： 1234while (((int)i!&#x3D;i) || (strin[0]&#x3D;&#x3D;&#39;0&#39;) || (p !&#x3D; 3)) &#123; printf(&quot;This is ont a right integer,please input again!\\n&quot;); scanf(&quot;%d,&amp;i&quot;); &#125; 大概就是上面这个样子造成的一个问题就是当第一次输入如abc这样不符合条件的字符类型的东西的时候，缓冲区存入‘abc’三个字符，第一个scanf读入因不符合类型要求而无法读取缓冲区的内容，之后执行while循环语句，输出“请重新输入”并再次执行scanf语句，我原本想着利用第二个scanf语句更改输入，结果scanf“不讲武德”，因为缓冲区已经有东西了(我们输入的不符合类型的内容)，所以scanf默认直接读取缓冲区的东西，导致进入了死循环为了解决上面这个问题，我改用了do while并在第一句直接加上了fflush(stdin)语句来清空标准输入的缓冲区，这样，每一次执行循环的开始，都会清空输入的缓冲区，防止进入死循环 字符串与字符问题：Gets():C语言中，其实不存在字符串这个东西，只有char类型来存储字符，能勉强算上存储字符的变量只有字符数组了，一个字符数组的名称相当于指向其首字母元素的指针，但很可惜，字符数组并不能作为变量传入scanf，会报错。所以，为了将缓冲区的字符串传入，不能用scanf,要用gets(),并将要传入的字符数组作为参数传入 判断类型是否正确：刚开始在while中我用了一个强制类型转换(int)i!=i来判断i是不是输入了正确类型，其实意义不大，因为在scanf中也有，只会读取缓冲区中的整型，如果我们输入了错误的类型，scanf压根不会读取，这里我们就要用到scanf的返回值了 scanf的返回值：scanf函数其实是存在返回值的，他返回读取到的匹配字符数目，比如我们输了3个%d,恰好缓冲区有三个整型的数与之匹配，那么就返回3，如果没有匹配的类型，scanf就不会读取缓冲区的任何内容，并返回0.在这里重新说一下scanf的作用，其读取缓冲区中的内容并将其赋值到传入的后续参数中去，读取的内容与传入的第一个参数中的%+字母有关，其决定了读取内容的类型 判断字符数组的长度我也不知道怎么回事，我试着将字符数组a作为参数传入strlen函数却发现编译器报错，后来查了一下,strlen函数的声明是这样的 1unsigned int strlen(char *s); 其传入的参数是指针，但理应传入数组应该也不会报错，最终我又加了一个指针来防止它报错 strlen函数和sizeof函数的区别sizeof函数和strlen函数一样，传入的参数类型须是指针，当然，当一个字符串被赋值进入一个指针后，该指针就指向了一个字符串，也可以说，字符串就相当于了一个指针的地位，所以可以直接作为参数传入这两个函数中去。strlen读取并返回字符串实际长度,而sizeof返回包括0/在内的所有字符细节，也就是在内存中的长度——————————————————对于上面的后续补充：get()函数有一个大缺点，他会无限读取stdin中的字符串直到遇见/0或换行符，也就是说，如果读取的字符串长度大于字符数组的长度，就会发生内存越界的坏情况为了防止这种情况，我们最好使用fget函数 1234格式fget(char* char,int n,FILE* stream)栗子fget(strlist,sizeof(strlist),stdin) 传入的第一个参数为指向字符串存储的变量的指针，第二个参数为读取字符串的长度，通常用sizeof来限制，传入的第三个参数为文件指针，以stdin使其读取输入缓冲区","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python基础进阶——list与dict","slug":"python#9","date":"2021-03-10T03:21:16.876Z","updated":"2021-03-10T03:23:35.952Z","comments":true,"path":"posts/8a0f52d1/","link":"","permalink":"http://penglaidoll.xyz/posts/8a0f52d1/","excerpt":"","text":"再补充一下关于list和dict的一些基础知识 不可变对象与可变对象：Str,dict的key等都是不可变对象比如我们调用replace函数 123&gt;&gt;A &#x3D; &#39;abc&#39;&gt;&gt;A.replace(&#39;a&#39;,&#39;A&#39;)&#39;Abc&#39; 看上去是变了，但当我们再次输入A时，我们发现： 12&gt;&gt;A&#39;abc&#39; 换种方式来看看： 123&gt;&gt;B &#x3D; A.replace(&#39;a&#39;,&#39;A&#39;)&gt;&gt;B&#39;Abc&#39; 为什么呢，因为str是不可变对象，当我们对一个str对象调用任何方法时，都不会改变这个不可变对象，而是创建新的不同的对象并返回现在我们去理解dict的key为什么时不可变对象 list和dict的优缺点：在理解key为不可变对象之前，我们先看一下list与dict的优缺点和list相比，dict查找和插入对象的速度更快，但消耗的内存更高，更浪费内存，也就是说,dict牺牲了内存来换取速度，之所以这个样子，就要谈到dict的原理了 关于list与链表以下的内容是我在网上查阅大佬资料时找到的list其实是用链表的方式存储的。假如我们有一个列表a =[1,2,3]，我们知道，链表的名称存储第一个元素的地址，也就是相当于名称是指向第一个元素的指针，第一个元素的指针再指向第二个元素，以此类推，我们便实现了元素的顺序排列。当我们想插入或删除一个元素，比如我们想在第一个和第二个元素之间插入一个5，我们可以直接通过链表的形式来实现。先通过添加一个链节5，让第一个元素的指针指向该链节，再让该链节的指针指向原来的第二个元素，这样便实现了插入，也就是说，在内存中，这些元素不一定是顺序排列的，但也可以实现顺序访问当我们想要查找某个元素时，因为是链表，所以我们不得不从头开始遍历，这也就是为什么list查找这么慢的原因 关于dict与哈希表dict的存储方式与list截然不同，dict采用了一种哈希算法，将key值利用哈希算法转换为一个数，再利用这个数找到相对应的值，不同的key通过哈希算法得到的值有很大概率不同，所以不同的key存储的地方不同，这才有了一一对应的原则。举个栗子：有一个字典{‘a’:1,’b’:2,’c’:3},我们想利用key’c’来查找，首先利用哈希算法将key’c’算出一个值，咱假设为233，再在内存空间开辟一个大空间0-1000出来，然后根据算出来的值将’c’的value存进对应的内存空间中去，所有的键值对都是这样存储的，因此，当我们想要取一个key的value时，没必要全部遍历，直接用哈希算法去算，然后找到对应的就可以了，所以dict的查找速度很快,但我们不得不得提前开辟一个大空间，所以dict又很消耗内存由上，我们可以推知为什么key为不可变对象了,dict通过key来存储值，假如key变了，那么下一次寻找时寻到的地址不同了，整个dict不就乱了吗补充一点：不同的key通过哈希算法得到的值有很大概率不同，也就是说，有小概率是相同的，这就要求设计哈希表时要尽量减少冲突，这个就是设计编译器的事情了。","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python面向对象编程进阶②","slug":"python#8","date":"2021-03-10T03:17:27.799Z","updated":"2021-03-10T06:52:52.301Z","comments":true,"path":"posts/794c651c/","link":"","permalink":"http://penglaidoll.xyz/posts/794c651c/","excerpt":"","text":"对于类的定制：str:用于返回当前类的自定义名称举个栗子： 1234class pp(): name &#x3D; &#39;ff&#39; passprint(pp()) 这样的话，会输出以下内容 1&lt;__main__.pp object at 0x0000023A8A958E50&gt; 假如说，我们加入__str__方法： 12345class pp(): name &#x3D; &#39;ff&#39; def __str__(self): return &#39;pp(name:%s)&#39; % &#39;ff&#39;print(pp()) 这样我们返回的就是： 1pp(name:ff) 也就是说，我们通过定义__str__方法，并返回我们想要输出的内容，那么当我们想要直接访问这个类时，系统会主动调用__str__方法，返回的不是类类型的标志语，而是我们自定义的内容 对于可迭代对象和迭代器的补充：之前我们说过，能被for直接作用的是可迭代对象，能使用next()方法的是迭代器，这里我们完善一下我们知道，一个对象中往往含有许多方法和属性，而dir函数可以帮助我们查看这些方法和属性。当我们对一个迭代器使用dir函数查看时，我们能看到其中有iter()和next()方法，这个很关键。在python中，若一个对象含有iter()方法，那么这个方法会返回一个可迭代对象，而若再含有__next__方法，那么这个对象就可以被调用next()方法，那么该对象就是迭代器由此，可迭代对象和迭代器都有__iter__方法，都可被for循环调用，迭代器中多了__next__方法，可用next()方法迭代由此，我们可以创建自己的可迭代对象了：以斐波那契数列为例： 12345678910class Fib(object): def __init__(self): self.a, self.b &#x3D; 0, 1 # 初始化两个计数器a，bdef __iter__(self): return self # 实例本身就是迭代对象，故返回自己def __next__(self): self.a, self.b &#x3D; self.b, self.a + self.b # 计算下一个值 if self.a &gt; 100: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 栗子中，我们定义了iter__方法使类实例化过程中返回一个可迭代对象，用__next__（）方法定义发生迭代的过程对于这个例子进行简单分析：__iter__使得一个对象成为可迭代对象__next__定义了该迭代器发生一次迭代的过程和结果StopIteration(终止异常):让一个迭代器终止迭代发生异常比如for循环自带异常处理，所以我们在遍历列表时不会因索引过大报错导致的程序终止,while循环则没有异常处理，所以我们在自定义可迭代对象时，为了防止无休止的迭代，要加上stopiteration异常，使之迭代到一定程度时触发异常，转而让异常处理来处理，从而终止迭代。在此处，并不是真的发生错误了，而是相当于换了一种方式告诉调用者已经迭代完毕。以上，我们发现自己所定义的迭代器并不支持索引调用其中的元素，这时，我们加入__getitem()方法的定义，这样，我们就可以通过访问下标索引的方式来访问可迭代对象中的元素 __getitem__方法当实例对象使用[]运算符取值时，会自动调用调用内建函数（方法）getitem()，并将[]中的内容作为一个参数传入__getitem__方法中。由此看出，当我们想通过访问下标的方式让自定义实例对象返回对应列表等可迭代对象或字典中的目标内容时，只需定义__getitem__对象使其返回就可举个栗子： 123456789class DataBase: def __init__(self): &#39;&#39;&#39;初始化方法&#39;&#39;&#39; self.lt &#x3D; [3,6,9] def __getitem__(self, key): return self.lt[key] data &#x3D; DataBase()print(data[1]) 输出： 1&gt;&gt;6 不难想到，列表的实现方式与这个如出一辙 __dict__属性之前我们用dir函数查看对象所含有或继承的方法和属性，现在我们介绍一个内置的__dict__属性，用它来查看某一对象自己的属性和方法，(当然，其作为对象的一个属性，它的作用之一也是存储这些信息)在这里，与dir有几点不同：1.dir函数生成的是list结构，其中只包括属性和方法的名称__dict__则展示了其作为dict的结构，key对应名称，value对应具体的值或方法定义2.dir函数生成全部的属性和方法(包括继承的)__dict__属性只展示部分属性或方法(不包括继承的)3.利用__dict__可以更改对象的属性，而dir不可栗子： 1Classname.__dict__[key] &#x3D; value 和正常的字典赋值差不多，就是多了一个类或实例访问另外，实例对象和类的__dict__属性有所不同举个栗子： 1234567891011class DataBase: def __init__(self): &#39;&#39;&#39;初始化方法&#39;&#39;&#39; self.lt &#x3D; [3,6,9] def __getitem__(self, key): return self.lt[key] def ff(self): return self.lt[2]data &#x3D; DataBase()print(data.__dict__)print(DataBase.__dict__) 返回 12&#123;&#39;lt&#39;: [3, 6, 9]&#125;&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;__init__&#39;: &lt;function DataBase.__init__ at 0x0000018994282040&gt;, &#39;__getitem__&#39;: &lt;function DataBase.__getitem__ at 0x00000189942820D0&gt;, &#39;ff&#39;: &lt;function DataBase.ff at 0x0000018994282160&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;DataBase&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;DataBase&#39; objects&gt;, &#39;__doc__&#39;: None&#125; 可见实例对象的__dict__属性仅包含self.xxx等的实例化属性，而类则相对包括更多的属性方法等(包括类函数，静态函数，全局变量等) 注意：如int,list,dict等的内置数据类型无__dict__属性 部分总结自点这里","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"几种特殊的数据类型","slug":"CCpp#2","date":"2021-03-08T02:52:23.000Z","updated":"2021-03-08T03:09:48.468Z","comments":true,"path":"posts/85a1c1ed/","link":"","permalink":"http://penglaidoll.xyz/posts/85a1c1ed/","excerpt":"","text":"size_t全称为size type,属于一种整型类型，能够保存一个整数，这个整数往往是一个大小(size)，也就是说，size_t是用来记录大小的数据类型类似的还有wchar_t,ptrdiff_t wchar_t即wide char type,是一种记录一个宽字符的数据类型 ptrdiff_t即pointer difference type,用来记录两个指针之间的距离的数据类型 补充：一般来说，以上三种数据类型均需要typedef来实现，而程序员们为了方便使用和记忆而人为规定了这么几种，但在较新的C/C++标准中，wchar_t已经被涵盖在数据类型中了可以直接使用了，其他的数据类型可以在其他常见的头文件的代码中看到定义","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python内置函数总结","slug":"python#7","date":"2021-03-04T01:08:21.000Z","updated":"2021-03-08T02:59:48.837Z","comments":true,"path":"posts/cf4bdb1c/","link":"","permalink":"http://penglaidoll.xyz/posts/cf4bdb1c/","excerpt":"","text":"Python内置的函数及其用法。 分类为了方便记忆，已经有很多开发者将这些内置函数进行了如下分类： 数学运算(7个)类型转换(24个)序列操作(8个)对象操作(7个)反射操作(8个)变量操作(2个)交互操作(2个)文件操作(1个)编译执行(4个)装饰器(3个) 汇总数学运算abs 求数值的绝对值divmod 返回两个数值的商和余数max 返回可迭代对象中的元素中的最大值或者所有参数的最大值min 返回可迭代对象中的元素中的最小值或者所有参数的最小值pow 返回两个数值的幂运算值或其与指定整数的模值round 对浮点数进行四舍五入求值sum 对元素类型是数值的可迭代对象中的每个元素求和 类型转换bool 根据传入的参数逻辑值，创建一个新的布尔值int 根据传入的参数，创建一个新的整数float 根据传入的参数，创建一个新的浮点数complex 根据传入参数，创建一个新的复数str 返回一个对象的字符串表现形式(给用户)bytearray 根据传入的参数，创建一个新的字节数组bytes 根据传入的参数，创建一个新的不可变字节数组memoryview 根据传入的参数，创建一个新的内存查看对象ord 返回Unicode字符对应的整数chr 返回整数所对应的Unicode字符bin 将整数转换成2进制字符串oct 将整数转化成8进制数字符串hex 将整数转换成16进制字符串tuple 根据传入的参数，创建一个新的元组list 根据传入的参数，创建一个新的列表dict 根据传入的参数，创建一个新的字典set 根据传入的参数，创建一个新的集合frozenset 根据传入的参数，创建一个新的不可变集合enumerate 根据可迭代对象创建枚举对象range 根据传入的参数，创建一个新的range对象iter 根据传入的参数，创建一个新的可迭代对象slice 根据传入的参数，创建一个新的切片对象super 根据传入的参数，创建一个新的子类和父类关系的代理对象object 创建一个新的object对象 序列操作all 判断可迭代对象的每个元素是否都为True值any 判断可迭代对象的元素是否有为True值的元素filter 使用指定方法过滤可迭代对象的元素map 使用指定方法去作用传入的每个可迭代对象的元素，生成新的可迭代对象next 返回可迭代对象中的下一个元素值reversed 反转序列生成新的可迭代对象sorted 对可迭代对象进行排序，返回一个新的列表zip 聚合传入的每个迭代器中相同位置的元素，返回一个新的元组类型迭代器 对象操作help 返回对象的帮助信息dir 返回对象或者当前作用域内的属性列表id 返回对象的唯一标识符hash 获取对象的哈希值type 返回对象的类型，或者根据传入的参数，创建一个新的类型len 返回对象的长度ascii 返回对象的可打印表字符串表现方式format 格式化显示值 反射操作vars 返回当前作用域内的局部变量，和其值组成的字典，或者返回对象的属性列表isinstance 判断对象是否是类或者类型元组中任意类元素的实例issubclass 判断类是否是另外一个类或者类型元组中任意类元素的子类hasattr 检查对象是否含有属性getattr 获取对象的属性值setattr 设置对象的属性值delattr 删除对象的属性callable 检测对象是否可被调用 变量操作globals 返回当前作用域内的全局变量，和其值组成的字典locals 返回当前作用域内的局部变量，和其值组成的字典 交互操作print 向标准输出对象打印输出input 读取用户输入值 文件操作open 使用指定的模式和编码打开文件，返回文件读写对象 编译执行compile 将字符串编译为代码或者AST对象，使之能够通过exec语句来执行或者eval进行求值eval 执行动态表达式求值exec 执行动态语句块repr 返回一个对象的字符串表现形式(给解释器) 装饰器property 标示属性的装饰器classmethod 标示方法为类方法的装饰器staticmethod 标示方法为静态方法的装饰器具体每个函数的解析如下： 数学运算abs：求数值的绝对值 1234&gt;&gt;&gt; abs(-1)1&gt;&gt;&gt; abs(1)1 divmod：返回两个数值的商和余数 1234&gt;&gt;&gt; divmod(5,2)(2, 1)&gt;&gt; divmod(5.5,2)(2.0, 1.5) max：返回可迭代对象中的元素中的最大值或者所有参数的最大值 12345678&gt;&gt;&gt; max(1,2) # 传入参数 取较大者2&gt;&gt;&gt; max(&#39;123&#39;) # 传入1个可迭代对象，取其最大元素值&#39;3&#39;&gt;&gt;&gt; max(-1,0) # 数值默认取数值较大者0&gt;&gt;&gt; max(-1,0,key &#x3D; abs) # 传入了求绝对值函数，则参数都会进行求绝对值后再取较大者-1min：返回可迭代对象中的元素中的最小值或者所有参数的最小值 12345678&gt;&gt;&gt; min(1,2) # 传入3个参数 取3个中较小者1&gt;&gt;&gt; min(&#39;123&#39;) # 传入1个可迭代对象，取其最小元素值&#39;1&#39;&gt;&gt;&gt; min(-1,-2) # 数值默认去数值较小者-2&gt;&gt;&gt; min(-1,-2,key &#x3D; abs) # 传入了求绝对值函数，则参数都会进行求绝对值后再取较小者-1pow：返回两个数值的幂运算值或其与指定整数的模值 12345&gt;&gt;&gt; pow(2,3)&gt;&gt;&gt; 2**3 &gt;&gt;&gt; pow(2,3,4)&gt;&gt;&gt; pow(2,3)%4 round：对浮点数进行四舍五入求值 12&gt;&gt;&gt; round(1.16,1)1.1 sum：对元素类型是数值的可迭代对象中的每个元素求和 123# 传入可迭代对象，要求是数字&gt;&gt;&gt; sum((1,2,3))6————————————————本文转载自CSDN大佬「Holidaylovesam」的博客原文链接：点这里","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python面向对象编程进阶①","slug":"python#6","date":"2021-03-03T15:00:05.000Z","updated":"2021-03-08T03:11:50.899Z","comments":true,"path":"posts/e4b558a/","link":"","permalink":"http://penglaidoll.xyz/posts/e4b558a/","excerpt":"","text":"鸭子类型：存在于动态语言的一种现象，不用严格遵循继承体系也就是说，只要调用的对象中含有对应的方法，不用继承也可以实现多态的现象：如： 1234567891011121314class Person(): def wang(self): print(&#39;wang wang wang!&#39;) passclass Dog(): def wang(self): print(&#39;wang wang wang&#39;) passdef jiao(thing): thing.wang()p &#x3D; Dog()r &#x3D; Person()jiao(p)jiao(r) 其中，一个带感叹号，一个不带输出可以发现，二者均输出 12wang wang wangwang wang wang! 由此可知，python这样的动态语言注重的是方法，而不是繁杂的继承，有对应的方法就可以调用 1“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” 这就是鸭子测试 dir()函数——获得传入类内所有的属性和方法 实例属性和类属性：在类定义时定义的属性为类属性实例化时称为实例属性类属性归类所有，所有的实例均可访问若实例化时没有赋值那么默认属性则被赋值为类属性的值如有定义那么就赋值为实例属性的值 __slots__变量：给类绑定方法和属性：例子如下： 123456789class pp(): passpp.name &#x3D; &#39;pp&#39;o1 &#x3D; pp()print(o1.name)o1.tall &#x3D; 114514print(o1.tall)o2 &#x3D; pp()print(o2.tall) 如果我们将上面的代码输入，就可以观察到最后一行报错原因是tall实际上绑定到的是o1的实例而不是o类，所以实例化的o2没有tall属性，而name属性就是绑定到类上，所有实例化都可用 12345def f(self,x,y): print(x+y)from types import MethodType #从types包中引入methodtype函数，利用这个函数来绑定o1.f &#x3D; MethodType(f,o1) #函数的具体使用o1.f(3,5) 之后，我们再输入以上代码，向o1动态绑定f方法，同上面一样，这个是实例方法，无法在同类变量中使用，除非另行绑定加入我们想让一个类只能绑定我们规定好的属性或方法而无法绑定其他的属性或方法，该怎么办呢 __slots__变量：这个属于系统变量，用来限制该类能绑定的属性或方法举个栗子： 123456789class pp(): __slots__ &#x3D; (&#39;name&#39;) passpp.name &#x3D; &#39;pp&#39;def f(self,x,y): print(x+y)o1 &#x3D; pp()print(o1.name)o1.sound &#x3D; 114514 #(恶臭) 还是上面的代码，只不过我们加入了__slots__变量并规定了一个元组，其中包括了pp类可以绑定的name属性，当我们执行到o1.sound语句时，编译器报错，因为我们规定了除了name属性，其他都无法动态绑定再补充一点:__slots__变量只对当前类有用，对其子类无法起作用，除非子类再定义一个__slots__。如果子类再定义了，那么作为其父类中的__slots__也会得到继承，那么子类可以规定的属性和方法就是它及其父类__slots__变量中的和了 输入参数的检查：我们刚刚得知了给类绑定方法和属性的方法，可如果我们要求绑定的属性有个范围该怎么办呢。举个检查输入参数是否为int类型的例子吧 12if not isinstance(value,int) printf(&#39;error&#39;) isinstance函数可以帮助我们检验一个值是否为某一个类型，并返回true或false @property@property是python中的装饰器，可以用来创建只读属性，将一个方法转换为相同名称的只读属性 1.修饰方法，将其转换可以像属性一样访问1234class pp(): @property def ppff(self): return &#39;pp&#39; 假如没有@property,我们要想输出pp，则需输入 1pp().ppff() 但是有了@property，可以简化为 1pp().ppff 注意，用装饰器修改完之后，ppff函数将变成只读状态，无法再传入任何参数，如输入 1pp().ppff() 将会报错 2.与私有属性连用，防止私有属性被修改在之前我们先看一下私有属性的特点 123456class pp(): def __init__(self,name): self.__name &#x3D; name passp &#x3D; pp(&#39;p&#39;)print(p.__name) 以上，我们定义了一个私有属性__name在后面执行print语句时报错，说明我们无法访问__name这个私有属性，只能另行通过定义函数来返回__name属性的值，但如果我们在print语句前，pp类实例化语句之后加上这么一句 1p.__name &#x3D; &#39;pp&#39; 再执行后面的print语句，你会惊奇的发现，print语句正常执行了，我个人猜测，这个赋值语句改变了__name的私有属性状态而变成了普通的类属性为了防止其私有属性状态的改变和其值被更改，我们可以用@property 12345678910111213class DataSet(object): def __init__(self): self._images &#x3D; 1 self._labels &#x3D; 2 #定义属性的名称 @property def images(self): #方法加入@property后，这个方法相当于一个属性，这个属性可以让用户进行使用，而且用户有没办法随意修改。 return self._images @property def labels(self): return self._labelsl &#x3D; DataSet()#用户进行属性调用的时候，直接调用images即可，而不用知道属性名_images，因此用户无法更改属性，从而保护了类的属性。print(l.images) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（） 上面的例子我们可以将那两个方法改成其他的函数从而隐藏属性的名字而进行调用，让人以为是属性，而其实是方法变成的属性哒！","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"生成器与迭代器基础","slug":"python#5","date":"2021-03-01T14:25:20.000Z","updated":"2021-03-08T03:02:25.006Z","comments":true,"path":"posts/3d4ca4e0/","link":"","permalink":"http://penglaidoll.xyz/posts/3d4ca4e0/","excerpt":"","text":"列表生成式：当我们在用for循环来输出列表时，会很麻烦，特别是生成一些复杂的列表，除此之外，我们可以利用列表生成式如：要生成 1[1&#x3D;1,2&#x3D;2,3&#x3D;3.....] 可以用 1[x&#x3D;x for x in range(1,...)] 这样的式子我们称之为列表生成式还可以在第一个for后面跟上更多的循环来生成更复杂的全排列灵活运用列表生成式可以简化代码列表生成式的if：如: 1[x for x in range(1,11) if x%2&#x3D;&#x3D;0] 可以输出1到11的偶数这里if起的是筛选作用注意后面不可跟else，否则会报错如果在for前面放if则必须跟else表示条件不同，就一以不同的形式输出 生成器：上面我们解释了列表生成式，是把for循环放在列表标识符中的([]),如果我们把列表标识符改成()并且讲其赋值到一个变量中去，像是生成了一个元组一样，但实际上是创建了一个生成器(generator)并将其赋值到了变量之中生成器，顾名思义，可以将一种算法赋值到一个变量之中，根据算法来取到所需要的值。与列表生成器不同，不需要将所有元素都计算出来，而只在需要的时候才算出对应的元素，省去不必要的元素以节省空间使用next(generator)函数来求出下一个元素最好使用for循环来求出所需的元素举个栗子： 123g &#x3D; (x for x in range(1,10000))for i in g: print(i) 在这里，刚刚生成1到10000时，并不是直接占用了所有的内存，二十后面一步一步推算出来的这里之所以能用for，是因为生成器也是可迭代对象生成器的作用非常强大，可以实现算法的迭代当一个算法过于复杂而for列表生成器无法应对的时候比如生成斐波那契数列常规写法： 1234567def fib(max): n,a,b&#x3D;0,0,1 while n&lt;max: print(a) a,b &#x3D; b,a+b n&#x3D;n+1return &#39;done&#39; 由此观察a,b=b,a+b逻辑和生成器相近，都是走一步算一步（雾生成器写法： 1234567def fib(max): n,a,b&#x3D;0,0,1 while n&lt;max: yield b a,b&#x3D;b,a+b n&#x3D;n+1return &#39;done&#39; 解释：在函数定义过程中，只要加上了yield，就可以将函数变成生成器，正常函数为顺序执行，而生成器则会一直执行到首次遇见yield语句，并输出yield语句后面的参数，使用next()语句使其从当前的yield语句执行到下一条yield语句举个简单栗子： 12345def odd(): print &#39;step1&#39; yield 1 print &#39;step2&#39; yield(3) 调用时： 1234567&gt;&gt;o &#x3D; odd()&gt;&gt;next(o)step11&gt;&gt;next(o)step23 如上 注意：调用一个生成器时，会返回一个generate对象就像map一样，生成的是迭代器迭代器和可迭代对象：能被for循环直接作用的，我们称为可迭代对象而像生成器那样的，可以用next()函数调用并返回下一个值的我们称为迭代器，如map,generator。(迭代器也是可迭代对象)可以利用isinstance()来判断一个变量是否为迭代器迭代器对象表示的是一个数据流，我们不知道其有多长，知道数据全部输出完毕就会报错，而不是迭代器的可迭代对象我们往往知道其长度","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"C语言指针相关","slug":"CCpp#1","date":"2021-02-28T09:01:18.000Z","updated":"2021-03-18T07:45:08.117Z","comments":true,"path":"posts/34311c5c/","link":"","permalink":"http://penglaidoll.xyz/posts/34311c5c/","excerpt":"","text":"C指针：指针是一类储存地址的变量 指针数组：如果想让一个数组存储一组指向某一特定数据类型的地址，那么就能定义一个指针数组如：int *ptr[3];int var[]={10,100,200};for (i=0;i&lt;3;i++) { ptr[i] = var[i];}通过以上这段代码，var数组的每个值的每个地址都被存储在指针数组ptr中了 补充：“指针数组”和“数组指针”的区别：“指针数组”顾名思义，是指针的数组，他是元素均为指针的一个数组变量“数组指针”，则是指一个指向数组的指针变量，通常地址为数组第一个元素的地址。 指针函数：一个返回值为指针的函数C语言默认在调用函数时不可返回地址，除非讲局部变量定义为static变量具体的使用过程为——在函数定义声明返回值为指针，然后return一个相同类型的指针(具体的返回值为地址)例如： 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int * fhptr(int i) &#123; static int *s; s &#x3D; &amp;i; return s;&#125;void main() &#123; int *p; p &#x3D; fhptr(5); printf(&quot;%d %p&quot;,*p,p);&#125; 至于为什么要求局部变量要定义为static变量则是因为局部变量存储在内存的栈区，函数调用结束后，内存释放，函数内的变量便不再拥有那个内存地址，故指针无法返回。而static变量值存放在静态栈区，静态区只会在最初时初始化一回，之后便不会改变。 函数指针：指向函数的指针函数在编译后会占一部分内存，函数名则是函数的首地址(类似于数组)将一个指针赋以函数名的值则能让这个特殊的指针指向函数举个栗子： 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void func(int a) &#123; printf(&quot;%d&quot;,a);&#125;void main() &#123; int (*funcpointer)(int); funcpointer &#x3D; &amp;func; funcpointer(6);&#125; 注意：指向函数的指针不可自增运算也就是说，你能在此处通过调用函数指针来获得和调用该函数一样的效果(脱了裤子放屁)还记得当函数作为参数传入函数时需要将其转换为指针的形式吗，函数指针的真正作用则是用在这里 完善一下上面的例子： 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;&#x2F;&#x2F;定义一个 指向 返回类型为void，传入参数为一个Int类型的函数类型 的指针类型typedef void (*hhh) (int);void func(int a) &#123; printf(&quot;%d&quot;,a);&#125;void main() &#123; hhh p; p &#x3D; func; p(6);&#125; 函数指针数组：例子如下： 1int (*function_pointer)[N](int,int); 这个是其通用形式，分开来看 1Int (*function_pointer) [n] (int,int); 首先它是一个指针，指向的是一个数组，什么数组呢，存了n个 参数为两个int类型，返回值为int的函数 的地址","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python中的类，模块，包","slug":"python#4","date":"2021-02-24T07:38:16.000Z","updated":"2021-03-08T03:02:01.510Z","comments":true,"path":"posts/8a35e780/","link":"","permalink":"http://penglaidoll.xyz/posts/8a35e780/","excerpt":"","text":"类：Python被设计为一门面向对象的编程语言，同其他面向对象的编程语言一样，它也有类这个概念：类可以认为是一个集合，用来容纳众多的相近的属性和方法，方便随时调用其中的变量和函数；对象则是类的实例化(把类赋值到一个变量中)，一个对象(也可以说一个类)有其对应的属性和方法；属性可以认为是类中定义的变量，分为类的属性和实例对象的属性；方法则是在类中定义的函数；一个简单的类实例： 12345678910class Pp: def __init__(self,a,b): self.a &#x3D; a self.b &#x3D; b self.c &#x3D; a + b print(&quot;初始化完毕！&quot;) def outsc(self): print(self.c)X &#x3D; Pp(2,3)x.outsc() 关于init:在把对象实例化之后会默认执行__init__方法，结合对__init__方法的定义，通常用来对对象初始化。除此之外，若想在对象实例化时就传入参数，必须调用__init__方法，不带__init__方法的类默认无法传入参数。 对于self的解释：类在定义方法时，传入的参数第一个必须是self，即使没有参数时，也要传入self，这里有一种解释，比如上例，Pp类实例化为x，这里self的作用实际上是把变量x在类内以self指代，所以类不管实例化为什么，self总是能把变量的名称传入类内以便调用。 模块：在Python中，一个模块可以认为是一个.py文件，它可以被其他.py文件用import函数引入，以便使用之前定义好的函数，类，变量什么的。 包：当多个用处相近的模块组合在一起，放在同一个文件夹这样的文件夹可以称为一个包。多个这样的文件夹合成一个大文件夹也可以称为一个包，则小文件夹又称为子包。包同样可以用import引入，其往往是一些制作者为了提供一系列的模块所制成，以方便调用。包内必须要有init.py文件、一个包的组成往往如下：Package1:|-init.py|-Module1.py|-Module2.py|-……调用方法为: 1From package1 import module1: 或 1Import package1.module1: 若包中一个模块需调用其他目录的模块，可在当前包目录下的init.py文件中添加sys.path.append(‘调用模块位置’)，然后再import __init__就可以了。","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"格式化字符串的三种方法","slug":"python#3","date":"2021-02-24T07:26:07.000Z","updated":"2021-03-08T03:01:41.221Z","comments":true,"path":"posts/6d69b5ea/","link":"","permalink":"http://penglaidoll.xyz/posts/6d69b5ea/","excerpt":"","text":"最古老的方法：——%-formatting格式化字符串类似于C语言，它是这么用的： 输入： 123Name &#x3D; &#39;world&#39;Id &#x3D; &#39;10&#39;Print(&#39;Hello %s,id&#x3D;%s&#39; % (name,id)) 输出： 1&#39;Hello world,id&#x3D;10&#39; 对于字典，同样适用：格式(%(key)s/d/g) 输入： 1Print(&#39;Hello %(name)s,id&#x3D;%(name)s&#39; % &#123;&#39;id&#39;:10 , &#39;name&#39; : &#39;world&#39;&#125;) 输出： 1Hello World,id&#x3D;10 后来的方法：——str.format()方法格式化字符串常规方法：输入： 12Name &#x3D; &#39;World&#39;Print(&#39;Hello &#123;&#125;&#39; % (name)) 输出： 1Hello World 通过位置访问的方法：输入： 1Print(&#39;&#123;2&#125;,&#123;1&#125;,&#123;0&#125;&#39;.format(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) 输出： 1C,b,a 通过关键字访问的方法：输入： 1Print(&#39;hi &#123;name&#125;&#39;.format(name &#x3D; &#39;howdy!&#39;)) 输出： 1Hi howdy! 新的方法：f-string格式化字符串Python3.6版本更新这一种方法，性能更优： 输入: 12345name &#x3D; &#39;hello world!&#39;D &#x3D; &#123;&#39;id&#39;:&#39;1&#39;,&#39;page&#39;:&#39;2&#39;&#125;Print(f&#39;print &#123;name&#125;&#39;)Print(f&#39;print &#123;name.upper()&#125;)Print(f&#39;turn to &#123;d[&quot;page&quot;]&#125;) 输出： 123Print hello worldPrint HELLO WORLDTurn to 2","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python中的交叉排序问题","slug":"python#2","date":"2021-02-22T03:12:17.000Z","updated":"2021-03-08T03:01:23.181Z","comments":true,"path":"posts/51641b53/","link":"","permalink":"http://penglaidoll.xyz/posts/51641b53/","excerpt":"","text":"在计蒜客中学习Python时，遇到了一个很有趣的排序问题： 输入一行 kk 个用空格分隔开的整数，依次为 n_1, n_2 … n_kn 1 ,n 2…n k。请将所有下标不能被 3 但可以被 2 整除的数在这些数字原有的位置上进行升序排列，此外，将余下下标能被 3 整除的数在这些数字原有的位置上进行降序排列。输出包括一行，与输入相对应的若干个整数，为排序后的结果，整数之间用空格分隔。 自己琢磨了很长时间，其中也发现了各种各样的问题，下面分享一下： 输入例：1 5 4 3 10 7 19输出例：1 3 7 5 10 4 19 程序样例1234567891011121314151617181920212223242526272829n = [int(x) for x in input().split(&#x27; &#x27;)]n1 = []n2 = []n3 = []nc= []# 将满足下标不同条件的列表中的数放入不同的空列表中for index in range(len(n)): if ((index+1) % 3 != 0) and ((index+1) % 2 == 0): n1.append(n[index]) elif ((index+1) % 3 ==0): n2.append(n[index]) else: n3.append(n[index])# 列表排序n1.sort()n2.sort(reverse = True)# 再将列表元素按照原序依次放回for index in range(len(n)): if ((index+1) % 3 != 0) and ((index+1) % 2 == 0) and n1: nc.append(n1.pop(0)) elif ((index+1) % 3 ==0) and n2: nc.append(n2.pop(0)) elif n3: nc.append(n3.pop(0))# 按照格式输出for i in range(len(n)): print(nc[i],end=&#x27; &#x27;) 格式化输入比如以空格相间隔的数据的输入：100 200 300可以用下面的方式读取 12345678# example 1x = [int(i) for i in input().split(&#x27; &#x27;)# exapmle 2x = map(int,input().split(&#x27; &#x27;)) 其中，input().split(‘ ‘)是将输入的数据以split函数传入的参数为标志进行分割并返回分割后的列表(注：split函数返回的列表为字符串列表！！！）example 2是一种比较巧妙的方法 判断列表是否为空1234567a = []if a: print(&#x27;YES&#x27;)else: print(&#x27;NO&#x27;) 以上只是个例子，是为了说明若一个列表为空，则其对应布尔值为False可以利用这个来判断一个列表是否为空程序例子中使用这个判断来防止列表空时pop()函数对空列表使用报错 参考：点这里 [点这里](https://blog.csdn.net/weixin_43113241/article/details/109965485）","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python中的_name_属性","slug":"python#1","date":"2021-02-19T11:36:03.000Z","updated":"2021-03-08T03:00:28.549Z","comments":true,"path":"posts/e599f77d/","link":"","permalink":"http://penglaidoll.xyz/posts/e599f77d/","excerpt":"","text":"刚开始学习python，接触到 1If _name_ == &#x27;_main_&#x27;: 这句话并不是很了解，以下是解答： Python中的模块与C,C++的头文件python如同C，C++等其他编程语言相似，可以引入(import)外部文件，在python中，引入的每个文件，以及自身的代码文件又叫模块，不同于C和C++，python中的模块可以独立运行，而C和C++中的头文件会首先执行 _name_属性1.name_是一个系统定义的变量，用来存储模块的名字或状态，假如一个模块为主函数(通常为引入其他模块的模块)则其模块内包含的_name_变量被赋值为“_main_”；若该模块是被引入的模块，则其_name_变量被赋值为(模块名无后缀)2.通过判断_name_所被赋的值的方式，可以判断该模块是否被引入或为主函数3.通常与if _name ==’main‘结合使用减少bug 总结自：点这里","categories":[{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]}],"categories":[{"name":"逆向学习——OD脱壳","slug":"逆向学习——OD脱壳","permalink":"http://penglaidoll.xyz/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94OD%E8%84%B1%E5%A3%B3/"},{"name":"逆向学习——OD","slug":"逆向学习——OD","permalink":"http://penglaidoll.xyz/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94OD/"},{"name":"语言学习","slug":"语言学习","permalink":"http://penglaidoll.xyz/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"算法学习","slug":"算法学习","permalink":"http://penglaidoll.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"OD","slug":"OD","permalink":"http://penglaidoll.xyz/tags/OD/"},{"name":"脱壳","slug":"脱壳","permalink":"http://penglaidoll.xyz/tags/%E8%84%B1%E5%A3%B3/"},{"name":"UPX壳","slug":"UPX壳","permalink":"http://penglaidoll.xyz/tags/UPX%E5%A3%B3/"},{"name":"Aspack壳","slug":"Aspack壳","permalink":"http://penglaidoll.xyz/tags/Aspack%E5%A3%B3/"},{"name":"脱壳，oep","slug":"脱壳，oep","permalink":"http://penglaidoll.xyz/tags/%E8%84%B1%E5%A3%B3%EF%BC%8Coep/"},{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"},{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://penglaidoll.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}