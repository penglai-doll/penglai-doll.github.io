{"meta":{"title":"PengLaiDoll网安学习心得","subtitle":"","description":"","author":"PengLaiDoll","url":"http://penglaidoll.xyz","root":"/"},"pages":[{"title":"关于个人","date":"2021-02-24T08:09:19.080Z","updated":"2021-02-24T08:09:19.080Z","comments":true,"path":"about/index.html","permalink":"http://penglaidoll.xyz/about/index.html","excerpt":"","text":"PengLaiDoll一个苦逼但仍在不断努力的共和国预备警官(笑)Wechat:wxpenglaidoll欢迎前来交流(笑)小站简陋但定实时更新敬请谅解"},{"title":"分类","date":"2021-02-19T12:04:00.000Z","updated":"2021-02-19T12:11:14.290Z","comments":true,"path":"categories/index.html","permalink":"http://penglaidoll.xyz/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-02-19T12:07:14.000Z","updated":"2021-02-19T12:11:30.960Z","comments":true,"path":"tags/index.html","permalink":"http://penglaidoll.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"生成器与迭代器基础","slug":"python#5","date":"2021-03-01T14:25:20.000Z","updated":"2021-03-01T14:35:06.074Z","comments":true,"path":"posts/3d4ca4e0/","link":"","permalink":"http://penglaidoll.xyz/posts/3d4ca4e0/","excerpt":"","text":"列表生成式：当我们在用for循环来输出列表时，会很麻烦，特别是生成一些复杂的列表，除此之外，我们可以利用列表生成式如：要生成 1[1&#x3D;1,2&#x3D;2,3&#x3D;3.....] 可以用 1[x&#x3D;x for x in range(1,...)] 这样的式子我们称之为列表生成式还可以在第一个for后面跟上更多的循环来生成更复杂的全排列灵活运用列表生成式可以简化代码列表生成式的if：如: 1[x for x in range(1,11) if x%2&#x3D;&#x3D;0] 可以输出1到11的偶数这里if起的是筛选作用注意后面不可跟else，否则会报错如果在for前面放if则必须跟else表示条件不同，就一以不同的形式输出 生成器：上面我们解释了列表生成式，是把for循环放在列表标识符中的([]),如果我们把列表标识符改成()并且讲其赋值到一个变量中去，像是生成了一个元组一样，但实际上是创建了一个生成器(generator)并将其赋值到了变量之中生成器，顾名思义，可以将一种算法赋值到一个变量之中，根据算法来取到所需要的值。与列表生成器不同，不需要将所有元素都计算出来，而只在需要的时候才算出对应的元素，省去不必要的元素以节省空间使用next(generator)函数来求出下一个元素最好使用for循环来求出所需的元素举个栗子： 123g &#x3D; (x for x in range(1,10000))for i in g: print(i) 在这里，刚刚生成1到10000时，并不是直接占用了所有的内存，二十后面一步一步推算出来的这里之所以能用for，是因为生成器也是可迭代对象生成器的作用非常强大，可以实现算法的迭代当一个算法过于复杂而for列表生成器无法应对的时候比如生成斐波那契数列常规写法： 1234567def fib(max): n,a,b&#x3D;0,0,1 while n&lt;max: print(a) a,b &#x3D; b,a+b n&#x3D;n+1return &#39;done&#39; 由此观察a,b=b,a+b逻辑和生成器相近，都是走一步算一步（雾生成器写法： 1234567def fib(max): n,a,b&#x3D;0,0,1 while n&lt;max: yield b a,b&#x3D;b,a+b n&#x3D;n+1return &#39;done&#39; 解释：在函数定义过程中，只要加上了yield，就可以将函数变成生成器，正常函数为顺序执行，而生成器则会一直执行到首次遇见yield语句，并输出yield语句后面的参数，使用next()语句使其从当前的yield语句执行到下一条yield语句举个简单栗子： 12345def odd(): print &#39;step1&#39; yield 1 print &#39;step2&#39; yield(3) 调用时： 1234567&gt;&gt;o &#x3D; odd()&gt;&gt;next(o)step11&gt;&gt;next(o)step23 如上 注意：调用一个生成器时，会返回一个generate对象就像map一样，生成的是迭代器迭代器和可迭代对象：能被for循环直接作用的，我们称为可迭代对象而像生成器那样的，可以用next()函数调用并返回下一个值的我们称为迭代器，如map,generator。(迭代器也是可迭代对象)可以利用isinstance()来判断一个变量是否为迭代器迭代器对象表示的是一个数据流，我们不知道其有多长，知道数据全部输出完毕就会报错，而不是迭代器的可迭代对象我们往往知道其长度","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础扫盲","slug":"基础扫盲","permalink":"http://penglaidoll.xyz/tags/%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/"}]},{"title":"C语言指针相关","slug":"C#","date":"2021-02-28T09:01:18.000Z","updated":"2021-02-28T09:04:59.932Z","comments":true,"path":"posts/34311c5c/","link":"","permalink":"http://penglaidoll.xyz/posts/34311c5c/","excerpt":"","text":"C指针：指针是一类储存地址的变量 指针数组：如果想让一个数组存储一组指向某一特定数据类型的地址，那么就能定义一个指针数组如：int *ptr[3];int var[]={10,100,200};for (i=0;i&lt;3;i++) { ptr[i] = var[i];}通过以上这段代码，var数组的每个值的每个地址都被存储在指针数组ptr中了 补充：“指针数组”和“数组指针”的区别：“指针数组”顾名思义，是指针的数组，他是元素均为指针的一个数组变量“数组指针”，则是指一个指向数组的指针变量，通常地址为数组第一个元素的地址。 指针函数：一个返回值为指针的函数C语言默认在调用函数时不可返回地址，除非讲局部变量定义为static变量具体的使用过程为——在函数定义声明返回值为指针，然后return一个相同类型的指针(具体的返回值为地址)例如： 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int * fhptr(int i) &#123; static int *s; s &#x3D; &amp;i; return s;&#125;void main() &#123; int *p; p &#x3D; fhptr(5); printf(&quot;%d %p&quot;,*p,p);&#125; 至于为什么要求局部变量要定义为static变量则是因为局部变量存储在内存的栈区，函数调用结束后，内存释放，函数内的变量便不再拥有那个内存地址，故指针无法返回。而static变量值存放在静态栈区，静态区只会在最初时初始化一回，之后便不会改变。 函数指针：指向函数的指针函数在编译后会占一部分内存，函数名则是函数的首地址(类似于数组)将一个指针赋以函数名的值则能让这个特殊的指针指向函数举个栗子： 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void func(int a) &#123; printf(&quot;%d&quot;,a);&#125;void main() &#123; int (*funcpointer)(int); funcpointer &#x3D; &amp;func; funcpointer(6);&#125; 注意：指向函数的指针不可自增运算也就是说，你能在此处通过调用函数指针来获得和调用该函数一样的效果(脱了裤子放屁)还记得当函数作为参数传入函数时需要将其转换为指针的形式吗，函数指针的真正作用则是用在这里 完善一下上面的例子： 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;&#x2F;&#x2F;定义一个 指向 返回类型为void，传入参数为一个Int类型的函数类型 的指针类型typedef void (*hhh) (int);void func(int a) &#123; printf(&quot;%d&quot;,a);&#125;void main() &#123; hhh p; p &#x3D; func; p(6);&#125; 函数指针数组：例子如下：int (*function_pointer)N;这个是其通用形式，分开来看Int (*function_pointer) [n] (int,int)首先它是一个指针，指向的是一个数组，什么数组呢，存了n个 参数为两个int类型，返回值为int的函数 的地址","categories":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础扫盲","slug":"基础扫盲","permalink":"http://penglaidoll.xyz/tags/%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/"}]},{"title":"Python中的类，模块，包","slug":"python#4","date":"2021-02-24T07:38:16.000Z","updated":"2021-02-24T07:42:42.336Z","comments":true,"path":"posts/8a35e780/","link":"","permalink":"http://penglaidoll.xyz/posts/8a35e780/","excerpt":"","text":"类：Python被设计为一门面向对象的编程语言，同其他面向对象的编程语言一样，它也有类这个概念：类可以认为是一个集合，用来容纳众多的相近的属性和方法，方便随时调用其中的变量和函数；对象则是类的实例化(把类赋值到一个变量中)，一个对象(也可以说一个类)有其对应的属性和方法；属性可以认为是类中定义的变量，分为类的属性和实例对象的属性；方法则是在类中定义的函数；一个简单的类实例： 12345678910class Pp: def __init__(self,a,b): self.a &#x3D; a self.b &#x3D; b self.c &#x3D; a + b print(&quot;初始化完毕！&quot;) def outsc(self): print(self.c)X &#x3D; Pp(2,3)x.outsc() 关于init:在把对象实例化之后会默认执行__init__方法，结合对__init__方法的定义，通常用来对对象初始化。除此之外，若想在对象实例化时就传入参数，必须调用__init__方法，不带__init__方法的类默认无法传入参数。 对于self的解释：类在定义方法时，传入的参数第一个必须是self，即使没有参数时，也要传入self，这里有一种解释，比如上例，Pp类实例化为x，这里self的作用实际上是把变量x在类内以self指代，所以类不管实例化为什么，self总是能把变量的名称传入类内以便调用。 模块：在Python中，一个模块可以认为是一个.py文件，它可以被其他.py文件用import函数引入，以便使用之前定义好的函数，类，变量什么的。 包：当多个用处相近的模块组合在一起，放在同一个文件夹这样的文件夹可以称为一个包。多个这样的文件夹合成一个大文件夹也可以称为一个包，则小文件夹又称为子包。包同样可以用import引入，其往往是一些制作者为了提供一系列的模块所制成，以方便调用。包内必须要有init.py文件、一个包的组成往往如下：Package1:|-init.py|-Module1.py|-Module2.py|-……调用方法为: 1From package1 import module1: 或 1Import package1.module1: 若包中一个模块需调用其他目录的模块，可在当前包目录下的init.py文件中添加sys.path.append(‘调用模块位置’)，然后再import __init__就可以了。","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础扫盲","slug":"基础扫盲","permalink":"http://penglaidoll.xyz/tags/%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/"}]},{"title":"格式化字符串的三种方法","slug":"python#3","date":"2021-02-24T07:26:07.000Z","updated":"2021-02-24T07:42:42.329Z","comments":true,"path":"posts/6d69b5ea/","link":"","permalink":"http://penglaidoll.xyz/posts/6d69b5ea/","excerpt":"","text":"最古老的方法：——%-formatting格式化字符串类似于C语言，它是这么用的： 输入： 123Name &#x3D; &#39;world&#39;Id &#x3D; &#39;10&#39;Print(&#39;Hello %s,id&#x3D;%s&#39; % (name,id)) 输出： 1&#39;Hello world,id&#x3D;10&#39; 对于字典，同样适用：格式(%(key)s/d/g) 输入： 1Print(&#39;Hello %(name)s,id&#x3D;%(name)s&#39; % &#123;&#39;id&#39;:10 , &#39;name&#39; : &#39;world&#39;&#125;) 输出： 1Hello World,id&#x3D;10 后来的方法：——str.format()方法格式化字符串常规方法：输入： 12Name &#x3D; &#39;World&#39;Print(&#39;Hello &#123;&#125;&#39; % (name)) 输出： 1Hello World 通过位置访问的方法：输入： 1Print(&#39;&#123;2&#125;,&#123;1&#125;,&#123;0&#125;&#39;.format(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) 输出： 1C,b,a 通过关键字访问的方法：输入： 1Print(&#39;hi &#123;name&#125;&#39;.format(name &#x3D; &#39;howdy!&#39;)) 输出： 1Hi howdy! 新的方法：f-string格式化字符串Python3.6版本更新这一种方法，性能更优： 输入: 12345name &#x3D; &#39;hello world!&#39;D &#x3D; &#123;&#39;id&#39;:&#39;1&#39;,&#39;page&#39;:&#39;2&#39;&#125;Print(f&#39;print &#123;name&#125;&#39;)Print(f&#39;print &#123;name.upper()&#125;)Print(f&#39;turn to &#123;d[&quot;page&quot;]&#125;) 输出： 123Print hello worldPrint HELLO WORLDTurn to 2","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础扫盲","slug":"基础扫盲","permalink":"http://penglaidoll.xyz/tags/%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/"}]},{"title":"Python中的交叉排序问题","slug":"python#2","date":"2021-02-22T03:12:17.000Z","updated":"2021-02-22T03:54:45.382Z","comments":true,"path":"posts/51641b53/","link":"","permalink":"http://penglaidoll.xyz/posts/51641b53/","excerpt":"","text":"在计蒜客中学习Python时，遇到了一个很有趣的排序问题： 输入一行 kk 个用空格分隔开的整数，依次为 n_1, n_2 … n_kn 1 ,n 2…n k。请将所有下标不能被 3 但可以被 2 整除的数在这些数字原有的位置上进行升序排列，此外，将余下下标能被 3 整除的数在这些数字原有的位置上进行降序排列。输出包括一行，与输入相对应的若干个整数，为排序后的结果，整数之间用空格分隔。 自己琢磨了很长时间，其中也发现了各种各样的问题，下面分享一下： 输入例：1 5 4 3 10 7 19输出例：1 3 7 5 10 4 19 程序样例1234567891011121314151617181920212223242526272829n = [int(x) for x in input().split(&#x27; &#x27;)]n1 = []n2 = []n3 = []nc= []# 将满足下标不同条件的列表中的数放入不同的空列表中for index in range(len(n)): if ((index+1) % 3 != 0) and ((index+1) % 2 == 0): n1.append(n[index]) elif ((index+1) % 3 ==0): n2.append(n[index]) else: n3.append(n[index])# 列表排序n1.sort()n2.sort(reverse = True)# 再将列表元素按照原序依次放回for index in range(len(n)): if ((index+1) % 3 != 0) and ((index+1) % 2 == 0) and n1: nc.append(n1.pop(0)) elif ((index+1) % 3 ==0) and n2: nc.append(n2.pop(0)) elif n3: nc.append(n3.pop(0))# 按照格式输出for i in range(len(n)): print(nc[i],end=&#x27; &#x27;) 格式化输入比如以空格相间隔的数据的输入：100 200 300可以用下面的方式读取 12345678# example 1x = [int(i) for i in input().split(&#x27; &#x27;)# exapmle 2x = map(int,input().split(&#x27; &#x27;)) 其中，input().split(‘ ‘)是将输入的数据以split函数传入的参数为标志进行分割并返回分割后的列表(注：split函数返回的列表为字符串列表！！！）example 2是一种比较巧妙的方法 判断列表是否为空1234567a = []if a: print(&#x27;YES&#x27;)else: print(&#x27;NO&#x27;) 以上只是个例子，是为了说明若一个列表为空，则其对应布尔值为False可以利用这个来判断一个列表是否为空程序例子中使用这个判断来防止列表空时pop()函数对空列表使用报错 参考：点这里 [点这里](https://blog.csdn.net/weixin_43113241/article/details/109965485）","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础扫盲","slug":"基础扫盲","permalink":"http://penglaidoll.xyz/tags/%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/"}]},{"title":"Python中的_name_属性","slug":"python#1","date":"2021-02-19T11:36:03.000Z","updated":"2021-02-19T13:54:27.957Z","comments":true,"path":"posts/e599f77d/","link":"","permalink":"http://penglaidoll.xyz/posts/e599f77d/","excerpt":"","text":"刚开始学习python，接触到 1If _name_ == &#x27;_main_&#x27;: 这句话并不是很了解，以下是解答： Python中的模块与C,C++的头文件python如同C，C++等其他编程语言相似，可以引入(import)外部文件，在python中，引入的每个文件，以及自身的代码文件又叫模块，不同于C和C++，python中的模块可以独立运行，而C和C++中的头文件会首先执行 _name_属性1.name_是一个系统定义的变量，用来存储模块的名字或状态，假如一个模块为主函数(通常为引入其他模块的模块)则其模块内包含的_name_变量被赋值为“_main_”；若该模块是被引入的模块，则其_name_变量被赋值为(模块名无后缀)2.通过判断_name_所被赋的值的方式，可以判断该模块是否被引入或为主函数3.通常与if _name ==’main‘结合使用减少bug 总结自：点这里","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础扫盲","slug":"基础扫盲","permalink":"http://penglaidoll.xyz/tags/%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/"}]}],"categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/categories/Python%E5%AD%A6%E4%B9%A0/"},{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础扫盲","slug":"基础扫盲","permalink":"http://penglaidoll.xyz/tags/%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/"}]}