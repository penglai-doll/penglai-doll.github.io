{"meta":{"title":"PengLaiDoll网安学习心得","subtitle":"","description":"","author":"PengLaiDoll","url":"http://penglaidoll.xyz","root":"/"},"pages":[{"title":"关于个人","date":"2021-02-24T08:09:19.080Z","updated":"2021-02-24T08:09:19.080Z","comments":true,"path":"about/index.html","permalink":"http://penglaidoll.xyz/about/index.html","excerpt":"","text":"PengLaiDoll一个苦逼但仍在不断努力的共和国预备警官(笑)Wechat:wxpenglaidoll欢迎前来交流(笑)小站简陋但定实时更新敬请谅解"},{"title":"标签","date":"2021-02-19T12:07:14.000Z","updated":"2021-02-19T12:11:30.960Z","comments":true,"path":"tags/index.html","permalink":"http://penglaidoll.xyz/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-02-19T12:04:00.000Z","updated":"2021-02-19T12:11:14.290Z","comments":true,"path":"categories/index.html","permalink":"http://penglaidoll.xyz/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"C++学习日记②","slug":"CCpp#8","date":"2021-04-24T15:39:11.000Z","updated":"2021-04-27T14:42:24.498Z","comments":true,"path":"posts/6097588b/","link":"","permalink":"http://penglaidoll.xyz/posts/6097588b/","excerpt":"","text":"C++中的类&amp;对象：类是C++面向对象程序设计的核心，我们可以把类看成一个用户定义的类型 类被用来指定一个对象的形式，其中包含了数据表示法和用于处理数据的方法 定义一个类，实际上相当于定义了一个数据类型的蓝图，其中包含类的对象包括什么，以及可以在这个对象上进行什么操作 定义如下： 1234567891011class classname&#123;private&#x2F;pubilc&#x2F;protected:属性定义；方法定义；&#125; 其中，private/public/protected是类访问修饰符，决定了在类对象作用域内的类成员能否在类的外部被访问 说白了，这玩意相当于自定义数据类型，就比如说内置类型int，我们可以对所有int类型的使用+方法来实现加法，类就相当于变相给你了一种自定义数据类型的法子 类访问修饰符：public: 公有成员，类成员在类的外部可以被直接访问 private: 私有成员，类成员只可以被类和友元函数访问，默认没有标注的情况下，类成员都是私有的(类似py的__前缀) protected: 类似私有成员，但protected成员可被子类访问 继承：有三种继承方式，对应的就是类成员访问属性 优先度：private&gt;protected&gt;public 大概就是private属性的无论怎么继承都是private public用啥继承就是啥属性 无论是啥用private属性继承就变成private属性 继承方法： 12345class newclass : type fatherclassname &#123;etc….&#125; 友元函数：可以访问private和protected属性的对象成员的函数，若要使一个函数成为一个类的友元函数，必须在类中加上前缀friend声明这个函数或用另一种方法声明一个类中所有的成员函数作为类的友元，具体如下： 12345678class Box &#123; double width; public: double length; friend void printWidth( Box box ); void setWidth( double wid ); &#125;; 以上表示printWidth为Box类对象的友元函数 friend class ClassTwo; 以上表示ClassTwo对象中所有函数均为其友元函数 类对象的方法和属性：对象的方法可以粗略认为是在类内定义的函数，而对象的属性可以认为是在类内定义的函数 成员函数可以定义在类内，定义方法和普通函数一样 如果在类外想定义一个成员函数，得使用”范围解析运算符::”定义函数 如下所示： 1234567double Animal::getValue(void)&#123;return number;&#125; 调用对象方法： 123Aniamal cat;cat.getValue() 函数重载：在c++中，可以定义多个同名函数，然后分别指定不同的传入参数来实现重载 举个栗子： \\ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt; using namespace std;class printData &#123; public: void print(int i) &#123; cout &lt;&lt; &quot;整数为: &quot; &lt;&lt; i &lt;&lt; endl; &#125; void print(double f) &#123; cout &lt;&lt; &quot;浮点数为: &quot; &lt;&lt; f &lt;&lt; endl; &#125; void print(char c[]) &#123;cout &lt;&lt; &quot;字符串为: &quot; &lt;&lt; c &lt;&lt; endl; &#125; &#125;; int main(void) &#123; printData pd; &#x2F;&#x2F; 输出整数 pd.print(5); &#x2F;&#x2F; 输出浮点数 pd.print(500.263); &#x2F;&#x2F; 输出字符串 char c[] &#x3D; &quot;Hello C++&quot;; pd.print(c); return 0; &#125; 同一个函数，多次定义，分别用不同的参数来实现对不同参数输入输出不同结果的功能","categories":[{"name":"C/C++语言学习","slug":"C-C-语言学习","permalink":"http://penglaidoll.xyz/categories/C-C-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"C++学习日记①","slug":"CCpp#7","date":"2021-04-22T13:43:19.000Z","updated":"2021-04-22T13:58:51.662Z","comments":true,"path":"posts/1790681d/","link":"","permalink":"http://penglaidoll.xyz/posts/1790681d/","excerpt":"","text":"类型标识符今天在C语言课上划水，偷偷把C++看了一下，果真就是C的全集，基本上除了面向对象部分，别的都和C差不多，就稍微整理了一下，多学习学习，为以后在师弟师妹面前装13打下良好基础(笑) 栗子代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;//空间命名using *namespace* std;//宏定义\\#define monster 114514//变量声明extern *int* a,b;//全局变量声明*int* g = 9;//主函数定义*int* main()&#123; //局部变量定义————只可在局部内使用 //局部变量可以覆盖全局变量 *int* a=0,b=0; *int* g=99; //修饰只读属性 const *int* xb = monster; //输出为99 cout &lt;&lt; g &lt;&lt; endl; //输出宏 cout &lt;&lt; monster &lt;&lt; endl; // &lt;&lt; 允许输出多个字符 endl代表输出完换行 cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl; return 0;&#125; 类型限定符： const const类型的对象在执行期间无法被修改或改变 volatile 修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。 restrict 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 存储类：auto类：两种用法，一是用于声明变量并初始化时自动根据初始化的值来判断变量的类型；二是用于作为函数定义的返回值的占位符 static存储类：保证被修饰的变量在程序运行的全生命周期内保持局部变量的存在 即相当于声明了静态变量 extern存储类:用于提供全局变量的声明 Lambda函数与表达式定义如下： **[capture]**：(parameters) mutable -&gt;return-type{statement} 解释： **[capture]**：捕获列表。其总是出现在lambda表达式的开始处,是lambda的引出符，编译器根据此判断接下来的代码是否是lambda函数 (parameters):参数列表，和普通的参数列表一致，如果不需要参数列表 则可省略 mutable:默认情况下，lambda函数总是一个const函数，使用mutable修饰符可以取消其常量性,但使用时参数列表不可省略(即使为空) -&gt;return_type：返回类型，如果不需要可以连同-&gt;一起省略 {statement}:函数体内容与普通函数一样，不仅可以使用参数，还可以使用捕获的变量 C++的伪随机：在C++中，利用srand(unsigned seed)进行伪随机的初始化 再调用rand()函数返回一个伪随机数 通常来讲，为了使rand()产生的数相对没有规律，传入的参数往往是time系统时间，也就是说，当srand()传入的参数seed相同时,后面的rand()函数产生的伪随机数是一样的，在逆向中有时会见到，要注意. 引用：定义： type&amp; name = name0; 相当于给变量起个小名，必须在声明时就初始化 实际上用的都是同一块内存空间，地址和对应的值都一样","categories":[{"name":"C/C++语言学习","slug":"C-C-语言学习","permalink":"http://penglaidoll.xyz/categories/C-C-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"Django与MongoDb学习的尝试日记①","slug":"Django&MongoDb#1","date":"2021-04-19T15:29:10.000Z","updated":"2021-04-22T13:44:34.672Z","comments":true,"path":"posts/6bd8bc66/","link":"","permalink":"http://penglaidoll.xyz/posts/6bd8bc66/","excerpt":"","text":"在pycharm中创建一个django项目可生成以下文件目录 根目录文件名可自定义 manage.py 项目管理文件，通过它管理项目，比如增加app XXX 与项目同名的目录，此处为XXX(可当作一个python包使用) / init.py 一个空文件，作用是这个目录XXX可以被当作包使用 asgi.py Django3及以后版本新出的异步功能模块 settings.py 项目的整体配置文件 urls.py 项目的URL配置文件，使得你定义的函数可以通过url访问 wsgi.py 项目与WSGI兼容的Web服务器入口 在带有wsgi的http模型中，django的作用相当于app，所以项目中的app和模型中的app不是一个东西,项目中的app可以认为是做某一类事情的东西 在命令行中输入 python manage.py startapp XX 创建一个名称为XX的app 具体文件目录如下 init.py 是一个空文件，表示当前目录XX可以当作一个python包使用 migrations 数据库迁移文件夹 admin.py 跟网站的后台管理相关 apps.py Django的生成app（应用）名称的文件 models.py 数据库操作相关 tests.py 用于开发测试用例，在实际开发中会有专门的测试人员 views.py 接收浏览器请求，进行处理，返回页面相关 在主目录的settings下INSTALL_APPS数组中添加自定义的app就可以实现app的安装 输入命令 python manage.py runserver (ip:端口) 运行服务器 默认为 127.0.0.1:8000(local) app的调用假如我们想要调用一个app中views的一个函数，需要按以下步骤操作： 1.建立app，在views中编制出相应的函数 2.在app目录中新建一个urls.py作为该app的URLconfs，在其中输入 fromdjango.urlsimportpath from.importviews urlpatterns=[ ] 其中，urlpatterns中填入对应的url，函数，标定名称，如： path(‘’,views.index,name=’index’), 3.在主目录的urls.py中再引入一个django.urls中的include函数(起到即插即用的效果) 然后输入如下的栗子： urlpatterns=[ path(‘admin/‘,admin.site.urls), path(‘test_app1/‘,include(‘test_app1.urls’)) ] 其中,include的作用相当于把app中的URLconfs引入其中","categories":[{"name":"Django学习","slug":"Django学习","permalink":"http://penglaidoll.xyz/categories/Django%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"web学习","slug":"web学习","permalink":"http://penglaidoll.xyz/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"web后端","slug":"web后端","permalink":"http://penglaidoll.xyz/tags/web%E5%90%8E%E7%AB%AF/"},{"name":"Python学习，MongoDB学习","slug":"Python学习，MongoDB学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0%EF%BC%8CMongoDB%E5%AD%A6%E4%B9%A0/"}]},{"title":"Reverse知识总结","slug":"re#3","date":"2021-04-19T13:32:54.000Z","updated":"2021-04-19T15:24:59.565Z","comments":true,"path":"posts/193d94a/","link":"","permalink":"http://penglaidoll.xyz/posts/193d94a/","excerpt":"","text":"以下为个人从书中和网上搜集的资料和经验，如有不足之处，敬请指出： 1.X86应用接口（常见）DialogBoxes类型的APIs以下来源于鱼C工作室： DialogBoxParamA GetDlgItem GetDlgItemInt GetDlgItemTextA GetWindowTextA GetWindowLong DialogBoxParamA‘ 函数功能： 该函数根据对话框模板资源创建一个模态的对话框。在显示对话框之前，函数把一个应用程序定义的值作为WM_INITDIALOG消息的IParam参数传到对话框过程,应用程序可用此值来初始化对话。 函数原型： int DialogBoxParam( HINSTANCE hlnstance, LPCTSTR IpTemplateName, HWND hWndParent, DLGPROC IPDialogFunc, LPARAM dwlnitParam ); 123456789101112131415161718192021222324 **参数：** hlnstance：标识一个模块的事例，该模块的可执行文件含有对话框模板。 IpTemplateName：标识对话框模板。此参数可以指向一个以NULL结尾的字符串的指针,该字符串指定对话框模扳名，或是指定对话框模板的资源标识符的一个整型值。如果此参数指定了一个资源标识符，则它的高位字一定为零，且低位字一定含有标识符。一定用MAKEINTRESOURCE宏指令创建此值。 hWndParent：指定拥有对话框的窗口。 IpDirlogFunc：指向对话框过程的指针。 dwlnitaram：指定传递到WM_INITDIALOG消息的IParam参数中的对话框过程的值。**返回值**如果函数调用成功则返回值为在对函数EndDialog的调用中的nResult参数，该EndDialog函数用于中止对话框。如果函数调用失败，则返回值为C1。若想获得错误信息，请调用GetLastError函数。**GetDlgItem****函数功能**该函数检索指定的对话框中的控件句柄。**函数原型**1. &#96;&#96;&#96; HWND GetDlgItem(HWND hDlg, int nlDDlgltem); **参数** hDlg：标识含有控件的对话框。 nlDDlgltem：指定将被检索的控件标识符。y 返回值如果函数调用成功则返回值为给定控件的窗口句柄。如果函数调用失败，则返回值为NULL，表示为一个无效的对话框句柄或一个不存在的控件。若想获得更多错误信息，可以调用GetLastError函数。 GetDlgItemInt函数功能获取控件中里面字符串并转换成int类型返回。 函数原型 UINT GetDlgItemInt( HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOLbSigned ); 1234567891011121314151617181920212223242526272829303132 **参数** hDlg：对话框的句柄。 nIDDlgItem：标识哪个文本将被转换。 lpTranslated：表示成功或失败（TRUE表示成功，FALSE表示失败）。如果此参数为NULL，则该函数没有返回成功或失败的信息。 bSigned：TURE表示有符号数，FALSE表示无符号数。**返回值**如果函数成功转换，返回转换的字符个数。**小甲鱼备注**第三个参数，主要是为了接收错误信息的。可能出现的错误信息有: ID无效，并且超过指定大小。比如说ID为12345677，这个就不行。还有就是输入不能解析为一个int类型的，比如输入:&quot;bvbvbvbv&quot;，&quot;3.5666&quot;， 当然后面可以解析为一个浮点型，在这里取得的值为3，但是还是会有错误信息。如果不指定第二个参数，就不会获得任何错误信息。对输入的判断是否可以解析为int类型或者是否有效，很有用的，我们经常有这个参数来判断用户的输入是否合法第四个参数，默认的为true，主要是针对&quot;-123&quot;，像这样的字符，它可以把前面的&quot;-&quot;解析为负号，那么就是标准的int类型了，如果设置为false，那么它不可以有负数，因为在这里的&quot;-&quot;号，被认为是不合法的。**GetDlgItemTextA****函数功能**调用这个函数以获得与对话框中的控件相关的标题或文本。GetDlgItemText成员函数将文本拷贝到lpStr指向的位置并返回拷贝的字节的数目。**函数原型**1. &#96;&#96;&#96; int GetDlgItemText( HWND hDlg, int nID, LPTSTR lpStr, int nMaxCount ); **参数** hDlg：句柄啊句柄~_~ nID：指定了要获取其标题的控件的整数标识符。 lpStr：指向要接收控件的标题或文本的缓冲区。 nMaxCount：指定了要拷贝到lpStr的字符串的最大长度（以字节为单位）。如果字符串比nMaxCount要长，它将被截断。 **返回值** 如果函数调用成功，返回值为拷贝到缓冲区中的 TCHAR 字符个数（不包括结束空字符）。 如果函数调用失败，返回值为 0 。要获取更多错误信息，请调用 GetLastError 函数。 *小甲鱼备注**如果字符串的长度大于缓冲区的长度，则会被截断，并以空字符结束。 GetWindowTextA : 函数功能该函数将指定窗口的标题条文本（如果存在）拷贝到一个缓存区内。如果指定的窗口是一个控件，则拷贝控件的文本。但是，GetWindowText不能接收其他应用程序中控件的文本。 函数原型 Int GetWindowText( HWND hWnd, LPTSTR lpString, Int nMaxCount); 123456789101112131415161718192021 **参数** hWnd：带文本的窗口或控件的句柄。 IpString：指向接收文本的缓冲区的指针。 nMaxCount：指定要保存在缓冲区内的字符的最大个数，其中包含NULL字符。如果文本超过界限，它就被截断。 **返回值** 如果函数成功，返回值是拷贝的字符串的字符个数，不包括中断的空字符；如果窗口无标题栏或文本，或标题栏为空，或窗口或控制的句柄无效，则返回值为零。若想获得更多错误信息，请调用GetLastError函数。 **小甲鱼备注** 函数不能返回在其他应用程序中的编辑控件的文本。**GetWindowLong** &quot;**函数功能**该函数获得有关指定窗口的信息，函数也获得在额外窗口内存中指定偏移位地址的32位度整型值。**函数原型**1. &#96;&#96;&#96; LONG GetWindowLong( HWND hWnd, int nlndex ); 参数hWnd：窗口句柄及间接给出的窗口所属的窗口类。nlndex：指定要获得值的大于等于0的值的偏移量。有效值的范围从0到额外窗口内存空间的字节数一4例如，若指定了12位或多于12位的额外类存储空间，则应设为第三个32位整数的索引位8。要获得任意其他值，指定下列值之一： GWL_EXSTYLE(-20)；获得扩展窗口风格。 GWL_STYLE(-16)：获得窗口风格。 GWL_WNDPROC(-4)：获得窗口过程的地址，或代表窗口过程的地址的句柄。必须使用CallWindowProc函数调用窗口过程。 GWL_HINSTANCE(-6)：获得应用事例的句柄。 GWL_HWNDPARENT(-8)：如果父窗口存在，获得父窗口句柄。 GWL_ID(-12):获得窗口标识。 GWL_USERDATA(-21)：获得与窗口有关的32位值。每一个窗口均有一个由创建该窗口的应用程序使用的32位值。 在hWnd参数标识了一个对话框时也可用下列值： DWL_DLGPROC(4)：获得对话框过程的地址，或一个代表对话框过程的地址的句柄。必须使用函数CallWindowProc来调用对话框过程。 DWL_MSGRESULT(0)：获得在对话框过程中一个消息处理的返回值。 DWL_USER(8)：获得应用程序私有的额外信息，例如一个句柄或指针。 返回值如果函数成功，返回值是所需的32位值；如果函数失败，返回值是0。若想获得更多错误信息请调用 GetLastError函数。 小甲鱼备注通过使用函数RegisterClassEx将结构WNDCLASSEX中的cbWndExtra单元指定为一个非0值来保留额外类的存储空间。 常见其他API1 comctl32.dllWindows应用程序公用GUI图形用户界面模块。 2 imm32.dll电脑的系统文件，与输入法密切相关。3 SetDispositionInformationFile设置部署信息文件4 LockFile可以锁定文件的一部分, 锁成功返回非0，他只能锁定一个打开的文件，给予锁定者以独占的模式。禁止其他线程访问。UnlockFile()解锁,类似5 ntdll.dll描述了windows本地NTAPI的接口。是重要的Windows NT内核级文件。6 conime.exe7 msimg32.dll是Windows图形设备接口GDI相关模块，用于支持新的API应用程序接口和GDI32相关特性。8 winmm.dll是Windows多媒体相关应用程序接口，用于低档的音频和游戏手柄。9 WindowsShell.ManifestWinXP 样式的配置文件；该文件损坏会导致 XP 变回经典样式的界面。10 GetPrivateProfileString初始化文件中指定的条目取得字串。11 RegCreateKeyEx该函数用来创建注册表键，如果该键已经存在，则打开它（注册表键不区分大小写）12 ShellExecuteHook从最初的第三方EXE加载DLL启动方式开始，到随后的使用rundll32.exe加载运行，再到利用NT服务的宿主程序svchost.exe实现启动，直到使用“ShellExecuteHook”（执行挂钩）技术，如今许多木马和恶意程序都在用户层使用ShellExecuteHook作为启动方式，实现随系统启动。13 CreateToolhelp32Snapshot函数通过获取进程信息为指定的进程、进程使用的堆[HEAP]、模块[MODULE]、线程建立一个快照.说到底，可以获取系统中正在运行的进程信息，线程信息等。14 process32First是一个进程获取函数,当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后,我们可以利用process32First函数来获得第一个进程的句柄.15 Process32Next是一个进程获取函数,当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后,我们可以利用Process32Next函数来获得下一个进程的句柄.其原型为16 GetEnvironmentVariable获取系统变量。17 GetModuleHandleA获取一个应用程序或动态链接库的模块句柄18 CreateMutex作用是找出当前系统是否已经存在指定进程的实例。如果没有则创建一个互斥体。19 GetStartupInfoWindows API函数。该函数取得进程在启动时被指定的 STARTUPINFO 结构。20 GetCommandLine获得指向当前命令行缓冲区的一个指针。21 GetEnvironmentStrings函数获取系统环境变量。22 GetModuleFileName获取当前进程已加载模块的文件的完整路径，该模块必须由当前进程加载。23 SystemParametersinfo该函数查询或设置系统级参数。该函数也可以在设置参数中更新用户配置文件。24 rep movs dword ptres:[edi], dword ptr [esi]循环从esi指向的内存区域复制数据到edi处的内存区域，复制ecx次，每次是一个DWORD25 REPNE SCAS BYTE PTR ES:[EDI]扫描 ES:[EDI]字符串中的 AL值.值到找到AL值后停止.25 FindFirstFile:根据文件名查找文件。该函数到一个文件夹(包括子文件夹)去搜索指定文件如果要使用附加属性去搜索文件的话可以使用FindFirstFileEx函数。26 GetEnvironmentStrings该函数为当前进程返回系统环境变量,它取代了DOS模式下的相应函数:GetDOSEnvironment()27 GetUserDefaultLCID:获得默认的用户本地标识符。CHS简体中文28 attrib.exe是DOS下不常用的命令。它是显示、设置，或删除指派给文件或目录的属性。ATTRIB [+R | -R] [+A | -A ] [+S | -S] [+H | -H] [+I | -I] [drive:][path][filename][/S [/D] [/L]] 29 setenvironmentvariable函数用于设置指定的环境变量：用法：BOOL WINAPISetEnvironmentVariable(_in LPCTSTR lpName, //环境变量名，当该值不存在且lpValue不为NULL时，将创建一个新的_in_opt LPCTSTR lpValue //环境变量值);30 LoadLibrary:载入指定的动态链接库，并将它映射到当前进程使用的地址空间。31 ExpandEnvironmentStrings扩充环境字串。具体操作过程与命令行处理的所为差不多。也就是说，将由百分号封闭起来的环境变量名转换成那个变量的内容。比如，“%path%”会扩充成完整路径。在vb里经常用于为新进程创建一个环境块32 GetVersion判断当前运行的Windows和DOS版本33 wsprintf函数wsprintf()将一系列的字符和数值输入到缓冲区。输出缓冲区里的的值取决于格式说明符（即”%”）。如果写入的是文字，此函数给写入的文字的末尾追加一个’\\0’。函数的返回值是写入的长度，但不包括最后的’\\0’。34 ShellExecute createprocess winexec：这三者都可以执行可执行文件功能上：createprocess &gt; shellexecute &gt; winexec 复杂程度也是！winexec() 只用于可执行文件，是一个老函数啦，虽然使用方便，但不推荐！(兼容性也不好);shellexcute()是通过windows外壳打开任意文件，非可执行文件自动通过关联的程序打开对于可执行文件，区别不大，不过shellexcute可以指定运行时的工作路径;winexec() 必须有GetMessage或超时之后才返回！CreateProcess和ShellExecute都是直接返回的！35 writefsdwordWrite memory to a location specified by an offset relative to thebeginning of the FS segment。用法： 1234void__writefsword( unsigned long Offset, unsigned short Data ); 36 GetLastError该函数返回调用线程最近的错误代码值，错误代码以单线程为基础来维护的，多线程不重写各自的错误代码值。分析过程中常见的返回值类型：(1)当返回值为183—&gt;当文件已存在时，无法创建该文件。(2)当返回值为2的时候找不到指定文件。(3)返回值为3的时候找不到指定路径。37 VirtualAllocEx函数可以用来在其他进程的地址空间内申请内存 。 38 CreateRemoteThread函数用来在其他进程内创建一个线程，当然创建的线程是运行于目标进程的地址空间内的，它和目标进程自己创建的线程并没有什么区别。 2.X86 32/64位汇编函数调用与栈的关系（栈回溯）： 函数发生调用时，先将传入参数从左往右依次压入栈中，然后通过调用call函数，将函数返回地址压入栈中，并跳转 以下内容为CSDN大佬的分析： 假设函数A调用函数B，我们称A函数为”调用者”,B函数为“被调用者”则函数调用过程： （1）先将调用者（A）的堆栈的基址（ebp）入栈，以保存之前任务的信息； （2）然后将调用者（A）的栈顶指针（esp）的值赋给ebp，作为新的基址（即被调用者B的栈底）； （3）然后在这个基址（被调用者B的栈底）上开辟（一般用sub指令）相应的空间用作被调用者B的栈空间； （4）函数B返回后，从当前栈帧的ebp即恢复为调用者A的栈顶（esp），使栈顶恢复函数B被调用前的位置；然后调用者A再从恢复后的栈顶可弹出之前的ebp值（可以这么做是因为这个值在函数调用前一步被压入堆栈）。这样，ebp和esp就都恢复了调用函数B前的位置，也就是栈恢复函数B调用前的状态。大致就是 “我是一个栈” 后来的sp–&gt; （1） （2） （3） （4） 原sp(后来的ebp)–&gt; （5） （6） 原ebp–&gt; （7） 总的来说 在A函数中调用B函数，先将B函数的传入参数压栈，再将返回地址压栈，再将A函数的ebp压栈，再将ebp调到原sp的位置，最后开拓新的B函数的栈空间，完成对B函数的调用，调用完成之后，再将原值pop出，完成栈回溯。 3.常规逆向分析流程1.API断点法 窗口类应用程序获取文本输入时，主要通过调用GetWindowText和GetDlgItemText两个API来获取，可以在这两个API函数下断点，通过栈回溯定位到关键代码 2.字符串检索法 对于某些简单的程序或有明显有义字符的程序，可通过OD或IDA的字符串查找工具找到关键字符串以减少工序 3.辅助工具法 对于某些特殊的文件可利用相关工具如针对MFC程序的xspy，Delphi程序的Dede 来源：点这里 点这里","categories":[{"name":"逆向学习","slug":"逆向学习","permalink":"http://penglaidoll.xyz/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://penglaidoll.xyz/tags/%E9%80%86%E5%90%91/"}]},{"title":"MIPS指令集初学","slug":"MIPS#1","date":"2021-04-08T08:00:56.000Z","updated":"2021-04-08T08:22:55.110Z","comments":true,"path":"posts/88ccd4cd/","link":"","permalink":"http://penglaidoll.xyz/posts/88ccd4cd/","excerpt":"","text":"寄存器：MIPS包含32个通用寄存器($0-$31),这些通用寄存器均为32位，硬件没有强制规定这些寄存器的作用，但实际使用中我们按照约定引入了一系列用法，使用过程中尽量使用约定名和助记符，而不直接使用寄存器编号 编号 助记符 用法 0 zero 永远为0 1 at 用作汇编器的暂时变量 2-3 v0,v1 子函数调用返回结果 4-7 a0-a3 子函数调用的参数 8-15 t0-t7 暂时变量，子函数使用时不需要保存与恢复 16-23 s0-s7 子函数寄存器变量。在返回之前子函数必须保存和恢复使用过的变量，从而调用函数知道这些寄存器的值没有变化 24-25 t8,t9 暂时变量，子函数使用时不需要保存和恢复 26-27 k0,k1 通常被中断或异常处理程序使用保存一些系统参数 28 gp 全局指针。一些运行系统维护这个指针来更方便的存取static和extern变量 29 sp 堆栈指针 30 s8/fp 框架指针/第九个寄存器变量 31 ra 子函数的返回地址 两个特殊的寄存器： $0不管我们存放什么值,其返回值永远为0 $31永远存放着正常函数调用指令(jal)的返回地址 $at由编译器生成复合指令时使用 $v0,$v1用来存放一个子程序(函数)的非浮点运算的结果或返回值。若这两个寄存器的大小不足够存放结果，系统将通过内存来完成存储 $a0-a3用来传递子函数调用时前四个非浮点参数 $t0-t9依照约定，这些寄存器在被子程序调用时可以不用被保存并随便使用，适合存储暂时变量，但因为可以被随便调用，因此不被推荐用来存储不变量，因为子程序有可能会调用这些寄存器将其中的值破坏掉 换句话说，这些寄存器谁都能用，而且不必保存里面原有的数据 $s0-s8依照约定，子函数在函数返回时必须保证调用完这些寄存器之后要恢复这些寄存器中的值为函数调用之前的值，这样的约定使得这几个寄存器通常被用来存放常量 换句话说，这些寄存器若想使用，必须先保证能恢复其中原来的数 $k0,k1被OS的异常或中断处理程序使用，被使用后将不会恢复原来的值，因此通常不会被使用 $gp如果存放一个全局指针，它将指向程序运行时所决定的静态数据区(static date)的一个位置，这意味着，利用gp做基指针，在基指针32k左右的数据存取，系统只需要一条指令即可完成 补充(之所以出现这个，是因为RISC结构CPU一条指令为32位，而地址总线也为32位，也就是说，正常条件下不可能通过一条指令完成对于内存的访问) $sp堆栈指针的上下需要显示的 通过指令来实现，因此MIPS通常只在子函数进入和退出时调整栈堆的指针。当SP被函数调用时，通常指向被调用栈的底部，利用其相对偏移来存取堆栈上面的堆栈变量 $fp/s8fp作为框架指针通常被函数用来记录堆栈的情况 (注：说白了fp,sp和ss,sp关系差不多) (关于pushl和popl：在mips中pushl是按照从右往左顺序入栈，popl则是从左往右，举个栗子： popl {$eax,$ebx}//先是ebx入栈，再是eax ) $ra当我们调用任何一个子函数时，返回地址存放在ra寄存器中，因此，子程序中最后一个指令往往是jr ra,如果子函数嵌套调用函数,往往通过栈堆来保存ra中的值 补充：hi 和 lo是乘法运算器相关的两个寄存器，一般除了乘法运算，不存放任何值 若浮点运算协处理器存在的话。则有32个浮点寄存器$f0到$f31 整数乘法单元和寄存器在MIPS中，只有在整数乘法运算完成得到完整的结果后，才能读取结果寄存器 寻址基址－偏移 寻址 指令格式：(所有指令都是32位长)R格式(操作码、第一个源操作数、第二个源操作数、目标寄存器(放结果)、偏移量、函数码) 举个栗子： add $8,$17,$18 #$8 = $17 + $18 I格式(带有立即数，target的指令) (操作码、第一个源操作数寄存器、目标寄存器、地址相对基址偏移量) (分类：装入/存储指令、分支指令、立即数运算指令) J格式指令集小结：i结尾代表可用执行数immediate u结尾代表无符号unsigned 加载/保存 指令集加载lw(load word) lw reg,ram #从对应的ram中复制内容到reg中 lb(load byte) 用法同上 保存sw(store word) sw reg,ram #将指定寄存器中的数据写入特定内存中 sb(store byte) 用法同上 load immediate li reg,value #加载立即数 立即与间接寻址直接寻址la(load address) la reg,var1 #表示将var1段的内存地址塞入reg寄存器中 间接寻址lw reg1,(reg2) #将reg2中的ram地址加载进reg1中 sw reg1,(reg2) 加偏移量lw reg1,4(reg2) sw reg1,-12(reg2) 算数指令集注： 最多三个操作数 操作数只能是寄存器，不可为地址 所有指令统一为32位 add reg,reg1,reg2 sub reg,reg1,reg2 addi reg,reg1,value(带立即数的加) addu reg,reg1,reg2(不带符号的数加) subi reg,reg1,reg2 subu reg,reg1,reg2 mult reg1,reg2(两个32位数分别存在于reg1、reg2,然后相乘得到一个64位数放在hi,lo中，hi高位，lo低位) div reg1,reg2(reg1/reg2,商数存储在lo，余数放在hi) or reg,reg1,reg2 xor reg,reg1,reg2 nor reg,reg1,reg2 mfhi reg(将hi的值传给reg) mflo reg(将lo的值传给reg) move reg1,reg2(reg1 = reg2) slt reg,reg1,reg2(if reg1&lt;reg2 reg=1 else reg=0) sltu reg,reg1,reg2(同上，只不过是无符号数) slti reg,reg1,value sltiu reg,reg1,value #按位移动 sll reg1,reg2,value(reg1=reg2按位左移value) srl reg1,reg2,value(reg1=reg2按位右移value) sra reg1,reg2,value(同上右移，注意符号位保留) #末尾带v可以让立即数在寄存器中 sllv reg1,reg2,reg3(作用同上，按位移动，只不过立即数保存在了reg3中) srlv reg1,reg2,reg3 srav reg1,reg2,reg3 控制流分支 beq reg1,reg2,target (equal) blt reg1,reg2,target (lower than) ble reg1,reg2,target (low equal) bgt reg1,reg2,target (bigger than) bge reg1,reg2,target (big equal) bne reg1,reg2,target (not equal) 跳转j target #直接跳转 jr reg #跳到该寄存器给的地址处 子程序调用jal (name) #将当前的程序计数器(PC)保存在$ra中，调用子程序，返回值设为PC+8 如果多次嵌套调用子程序，那么返回地址的标记就用栈来存储 至于为什么+8，因为是流水线技术，在真正执行这一条指令之前jal下一条指令已经进入流水线了，因此一定会执行完下一句，所以pc指向的是jal指令的下下条指令 补：关于PC寄存器 每一个线程启动时，都会建立一个PC寄存器(程序计数器),该寄存器指向下一条命令执行的地址(类似于x86的cs:ip) MIPS的5阶段流水线：IF(fetch):取指令，PC值发生变化，指向当前指令 ID(decode):指令译码，读寄存器 EX：执行运算，对于Load/Store，计算地址；对于其他指令，执行运算操作 MEM：访问内存，Load/Store的执行 WB：数据写回寄存器","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"MIPS","slug":"MIPS","permalink":"http://penglaidoll.xyz/tags/MIPS/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://penglaidoll.xyz/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"AT&T汇编语法","slug":"PE#3","date":"2021-04-04T03:34:00.000Z","updated":"2021-04-04T03:39:38.445Z","comments":true,"path":"posts/af3cdccb/","link":"","permalink":"http://penglaidoll.xyz/posts/af3cdccb/","excerpt":"","text":"AT&amp;T汇编和8086汇编(INTEL)其实差不多，只是表达方式不同 1.大小写INTEL汇编指令通常采用大写字母，如： 1MOV EAX,EBX AT&amp;T则通常采用小写字母来表示，如： 1movl %ebx,%eax 2.操作数赋值方向INTEL语法中，第一个表示目的操作数，第二个表示源操作数，如： 1MOV EAX，EBX；&#x2F;&#x2F;将EBX的内容移入EAX 而在AT&amp;T语法中，第一个表示源操作数，第二个表示目的操作数 1movl %eax,%ebx;&#x2F;&#x2F;将eax中的内容移入ebx 3.前缀INTEL语法中不需要前缀，如： 1MOV EAX,1 AT&amp;T语法则需要前缀，规则如下： 符号常数直接引用，不需要加前缀，如： 1movl value,%eax(value为一个常数) 前缀%加在寄存器名前 前缀$表示引用符号地址，如： 1movl $value,%ebx&#x2F;&#x2F;是将value的地址放入ebx中 前缀’lock’表示总线锁定，在linux核心代码中’lock’前缀很常见，特别是SMP代码，当总线锁定后CPU不能存取锁定地址处的内存单元 远程跳转指令和子过程调用指令要加前缀’|’分别为 1|jmp |call |ret 4.间接寻址语法INTEL语法中偏移地址通常用[]来括住，处理复杂操作数的语法为 1Segreg:[base+index*scale+disp] AT&amp;T中偏移地址则用()，处理复杂操作数的语法为 1$segreg:disp(base,index,scale) 其中上面所有的base,index,scale,disp都是可选的，scale默认为1 5.后缀AT&amp;T语法大部分指令操作码最后一个字母表示操作数大小,’b’表示’byte’,’w’表示’word’，’l’表示’long’，如: 1movl %eax,%ebx INTEL语法较少加后缀,但比如 1MOV eax,dword ptr [ebx] 这样的就规定了后缀来表示转移的数据长度 如果表示符号扩展和零扩展，在INTEL语法中表示为 1movsx,movzx AT&amp;T中表示为 1movs,movz 因此,movsbl %al,%ebx表示对寄存器al中的字节数据进行字节到长字的符号扩展，下面是一些扩展后缀 bl——字节-&gt;长字 bw——字节-&gt;字 wl——字-&gt;长字 跳转指令标号后的后缀表示跳转方向，如： 1jmp 1f ‘f’表示向前(forword)，’b’表示向后(behind)","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://penglaidoll.xyz/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"AT&T","slug":"AT-T","permalink":"http://penglaidoll.xyz/tags/AT-T/"}]},{"title":"从.c到.exe","slug":"PE#2","date":"2021-03-31T13:16:33.000Z","updated":"2021-04-04T03:39:38.440Z","comments":true,"path":"posts/c704601a/","link":"","permalink":"http://penglaidoll.xyz/posts/c704601a/","excerpt":"","text":"用C语言五步生成一个可执行文件我们都知道，利用gcc可以让一个C的源文件(.c)变成一个可执行文件(.exe) 123&#x2F;&#x2F;如何编译和运行一个.c源文件$gcc hello.c$.&#x2F;a.out 过程大概如下： 编写代码（人干的）（手动滑稽） 预编译 编译 汇编 链接 第一步——编写代码咱都懂 12345#include &lt;stdio.h&gt;void main()&#123; printf(&quot;Hello World!&quot;);&#125; 如上，没啥可说的，都会写，写完之后保存便生成了.c的C源文件 之后的四步，是gcc干的是，我们要来研究研究这个 第二步——预编译这里先大致概括一下《程序员的自我修养》上给的解释： 预编译过程主要处理那些源代码文件中的以“#”开始的预编译指令，主要处理规则规则如下： 删除所有的#define指令，展开所有的宏定义 处理所有的预编译指令 处理#include预编译指令，并将包含的文件插入该预编译指令的位置（这里是递归进行的） 删除所有的注释 在文件开头加上文件名标识，如(#2 “hello.c” 2) 为每一行添加行号，以方便编译器在调试时弹出错误信息能对应到具体的行 保留所有#pragma编译器指令，以便编译器使用 生成.i文件 上面是书中给出的预编译的过程，虽然已经讲的很清楚，但也有些地方需要进一步解释 123&#x2F;&#x2F;利用gcc实现预编译$gcc -E hello.c -o hello.i&#x2F;&#x2F;将hello.c预编译生成hello.i 预处理指令就是我们在.c开头使用的带有#的指令 主要分为三类 宏定义 文件包含 条件编译 其中宏定义和文件包含最常见，分别为#define和#include 预编译的作用主要就是针对预处理指令对.c语言变成.exe文件做初步的准备，比如将宏展开以便下一步的编译和将其他引入的文件（一般为头文件）引入以便于编译器对其进行分析 另外，条件编译我们用的较少，以下给出一些其他预编译指令的常见用法，不做多的讲解 指令 用途 #undef 未定义宏 #if 如果给定条件为真，则编译下面代码 #ifdef 如果宏被定义，则编译下面代码 #ifndef 如果宏未被定义，则编译下面的代码 #elif 如果前面的#if给定条件不为真，当前条件为真，则编译下面代码 #enif 结束一个#if…#else条件编译块 #error 停止编译并显示错误信息 #line 改变编译器用来指出警告和错误信息的文件号和行号 #pragma 为编译程序提供非常规的控制流信息 来源于网络，侵删 预处理指令的作用大概就是对于编译器的编程，让编译器有选择性的编译，将不必要的代码不进行编译。 特殊符号在网上我查到了一些神奇的东西，在书中好像并没有提及到，就是这个特殊符号，例如在源程序中出现的LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称。预编译程序对于在源程序中出现的这些串将用合适的值进行替换。具体操作也没有找到。 总而言之，预处理相当于帮助我们完成了编程的后续部分。 第三步——编译1234&#x2F;&#x2F;利用gcc将.s文件编译$gcc -c hello.s -o hello.o&#x2F;&#x2F;也就可以直接编译$gcc -c hello.c -o hello.o 这一部分应该是整个编译部分最困难的部分，因为涉及到编译原理，我能力不足也无法过多涉及。 这一部分编译器大致以下进行几个部分 词法分析 语法分析 语义分析 优化处理 经过预处理，程序中只剩下了：常量，变量，字符串(误),数字以及各种关键字、符号等 这一部分编译所做的工作就是通过分析这些个东西先判断是否符合语法规则，之后将其按照事先定好的规则翻译为等价的中间代码或汇编语言，最后进行优化 词法分析主要是利用扫描器词句进行分析，利用特殊的算法将其归类为关键字、标识符、字面量和特殊符号。并将其存放到对应的表中，以备后用。 语法分析利用语法分析器通过对上面生成的表中的记号进行分析，产生语法树，来分析语法的正误 语义分析利用语义分析器来分析语法树，对不同的数据类型进行标注等 生成中间语言和目标代码的生成和优化第四步——汇编这一步主要就是将上面的.s文件中的代码（汇编代码）转换为机器码(010101)，产生的目标文件,一般有两个段（代码段，数据段），其实这玩意就是平时在逆向时看到的代码，只不过我们在平时可以看到调用的其他的API （我个人理解为这个是一个差不多程序领空一样的东西，甚至小于程序领空） 第五步——链接我个人认为这步很重要，主要就是将我们的文件和所调用的其他比如头文件啦、Win32API啦什么的链接起来，让主程序正常能够调用 链接方式主要有两种： 静态链接 动态链接 关于链接这一块涉及到PE文件结构，并不太懂，只能粗略的说一下个人见解（不一定准确） 静态链接相当于你把所需要的函数名称、定义什么的在连接过程中加入到了文件之中，文件会变得大一点，但我们无论将这个文件移到什么地方，都可以正常执行 而动态链接只是在链接时将有关你所需要的外部函数所在的dll文件的相关信息存放在了文件的输入表当中，当需要时，会根据相关信息去寻找并输出，也就是说，只有当该文件执行时，才将输入表中的函数信息借助输入表使用loadlibrary()找到相关函数对应的dll并映射到对应虚拟内存中去，然后借助导入表用getprocessaddress()函数找到对应的函数来调用，这样会更节省内存，但会因为得需要现加载所以执行较慢，效率较低","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"c语言编译","slug":"c语言编译","permalink":"http://penglaidoll.xyz/tags/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91/"}]},{"title":"PE文件格式","slug":"PE#1","date":"2021-03-28T05:21:53.000Z","updated":"2021-03-28T06:00:54.906Z","comments":true,"path":"posts/16e2846c/","link":"","permalink":"http://penglaidoll.xyz/posts/16e2846c/","excerpt":"","text":"PE文件大致格式 **DOS头 ** **DOS **stub **PE签名 ** **PE文件头 ** **PE可选头 ** **Section table（节表） ** **.idata ** **.text ** **.data ** DOS头：用来兼容MS-DOS系统，主要目的是在MS-DOS上运行时提示This program cannot be run in DOS mode.另外就是指明到真正的PE文件头的位置的作用。 格式大概如下： 12345678910111213141516171819202122232425262728293031323334353637383940typedef struct_IMAGE_DOS_ &#123; // DOS .EXE header// offset: 0HWORD e_magic; // Magic number// offset: 2HWORD e_cblp; // Bytes on last page of file// offset: 4HWORD e_cp; // Pages infile// offset: 6HWORD e_crlc; // Relocations// offset: 8HWORD e_cparhdr; // Size of header in paragraphs// offset: AHWORD e_minalloc; // Minimumextra paragraphs needed// offset: CHWORD e_maxalloc; // Maximumextra paragraphs needed// offset: EHWORD e_ss; // Initial(relative) SS value// offset: 10HWORD e_sp; // Initial SPvalue// offset: 12HWORD e_csum; // Checksum// offset: 14hWORD e_ip; // Initial IPvalue// offset: 16HWORD e_cs; // Initial(relative) CS value// offset: 18HWORD e_lfarlc; // File address of relocation table// offset: 1AHWORD e_ovno; // Overlaynumber// offset: 1CHWORD e_res[4]; // Reservedwords// offset: 24HWORD e_oemid; // OEMidentifier (for e_oeminfo)// offset: 26HWORD e_oeminfo; // OEMinformation; e_oemid specific// offset: 28HWORD e_res2[10]; // Reservedwords// offset: 3CHLONG e_lfanew; // File address of new exe header&#125;IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; 其中需关注两个域： 第一个域——e_magic.exe文件第一个域一定为e_magic域，通常可执行文件在此域的值为’MZ’(16进制为0x4D5A) 最后一个域——e_lfanew看上文最后一个long型变量的注释：存储PE头的地址；32位可执行文件的扩展域，通常指向NT头相对文件起始位置的偏移 如下图所示： 4D 5A为DOS MZ header 80 00 00 00为最后一个域，如图，恰好指向0080h的PE头 补充：DOS头下，NT头上，这一部分为DOS stub，是由编译器所生成的当不支持PE文件的操作系统执行文件时输出This program cannot be run in DOS mode.通常不予理会，如上图所示。 NT头：NT头包含了PE文件的主要信息，包含 一个’PE’字样的签名 PE文件头(IMAGE_FILE_HEADER) PE可选头(IMAGE_OPTIONAL_HEADER32) 12345678typedef struct _IMAGE_NT_HEADERS&#123;// offset: 0HDWORD Signature;// offset: 4HIMAGE_FILE_HEADER FileHeader;// offset: 18HIMAGE_OPTIONAL_HEADER32 OptionalHeader;&#125; IMAGE_NT_HEADERS32,*PIMAGE_NT_HEADERS32; 如上所示 其中需要关注两个域 Signature类似于DOS头中的e_magic，高16位为0，低16位为0x4550,用字符表示就是’PE’ IMAGE_FILE_HEADER这个就是PE文件头，C语言定义如下 123456789typedefstruct _IMAGE_FILE_HEADER &#123;+4H WORD Machine;+6H WORD NumberOfSections;+8H DWORD TimeDateStamp;+CH DWORD PointerToSymbolTable;+10HDWORD NumberOfSymbols;+14HWORD SizeOfOptionalHeader;+16HWORD Characteristics;&#125;IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 具体位置如下 每个域的具体含义： Machine该文件的运行平台，是x86、x64还是I64等等，可以是下面值里的某一个。 123456789101112131415161718192021222324252627282930#define IMAGE_FILE_MACHINE_UNKNOWN 0#define IMAGE_FILE_MACHINE_I386 0x014c // Intel 386.#define IMAGE_FILE_MACHINE_R3000 0x0162 // MIPS little-endian, 0x160big-endian#define IMAGE_FILE_MACHINE_R4000 0x0166 // MIPS little-endian#define IMAGE_FILE_MACHINE_R10000 0x0168 // MIPS little-endian#define IMAGE_FILE_MACHINE_WCEMIPSV2 0x0169 // MIPS little-endian WCE v2#define IMAGE_FILE_MACHINE_ALPHA 0x0184 // Alpha_AXP#define IMAGE_FILE_MACHINE_SH3 0x01a2 // SH3 little-endian#define IMAGE_FILE_MACHINE_SH3DSP 0x01a3#define IMAGE_FILE_MACHINE_SH3E 0x01a4 // SH3E little-endian#define IMAGE_FILE_MACHINE_SH4 0x01a6 // SH4 little-endian#define IMAGE_FILE_MACHINE_SH5 0x01a8 // SH5#define IMAGE_FILE_MACHINE_ARM 0x01c0 // ARM Little-Endian#define IMAGE_FILE_MACHINE_THUMB 0x01c2#define IMAGE_FILE_MACHINE_AM33 0x01d3#define IMAGE_FILE_MACHINE_POWERPC 0x01F0 // IBM PowerPC Little-Endian#define IMAGE_FILE_MACHINE_POWERPCFP 0x01f1#define IMAGE_FILE_MACHINE_IA64 0x0200 // Intel 64#define IMAGE_FILE_MACHINE_MIPS16 0x0266 // MIPS#define IMAGE_FILE_MACHINE_ALPHA64 0x0284 //ALPHA64#define IMAGE_FILE_MACHINE_MIPSFPU 0x0366 // MIPS#define IMAGE_FILE_MACHINE_MIPSFPU16 0x0466 // MIPS#define IMAGE_FILE_MACHINE_AXP64 IMAGE_FILE_MACHINE_ALPHA64#define IMAGE_FILE_MACHINE_TRICORE 0x0520 // Infineon#define IMAGE_FILE_MACHINE_CEF 0x0CEF#define IMAGE_FILE_MACHINE_EBC 0x0EBC // EFI Byte Code#define IMAGE_FILE_MACHINE_AMD64 0x8664 // AMD64 (K8)#define IMAGE_FILE_MACHINE_M32R 0x9041 // M32R little-endian#define IMAGE_FILE_MACHINE_CEE 0xC0EE 也就是说，machine的值，代表了运行的平台 NumberOfSections该PE文件中有多少个节，也就是节表中的项数。 TimeDateStampPE文件的创建时间，一般有连接器填写。表明文件是何时被创建的。这个值是自1970年1月1日以来用格林威治时间（GMT）计算的秒数，这个值是比文件系统（FILESYSTEM）的日期时间更加精确的指示器。 PointerToSymbolTableCOFF文件符号表在文件中的偏移，主要指向调式信息 NumberOfSymbols符号表的数量。 SizeOfOptionalHeader紧随其后的可选头的大小,对于32位系统，通常为0X00E0H,64位系统为0X00F0H。 Characteristics 可执行文件的属性 具体定义在winnt.h头文件中 IMAGE_OPTIONAL_HEADER32/64这个是PE可选头，虽名为可选头，但必不可少，不同平台下其往往不同 下面以32位为例 123456789101112131415161718192021222324252627282930313233343536typedef struct _IMAGE_OPTIONAL_HEADER &#123;// 必选部分+18H WORD Magic;+1AH BYTE MajorLinkerVersion;+1BH BYTE MinorLinkerVersion;+1CH DWORD SizeOfCode;+20H DWORD SizeOfInitializedData;+24H DWORD SizeOfUninitializedData;+28H DWORD AddressOfEntryPoint;+2CH DWORD BaseOfCode;+30H DWORD BaseOfData;// 可选部分+34H DWORD ImageBase;+38H DWORD SectionAlignment;+3CH DWORD FileAlignment;+40H WORD MajorOperatingSystemVersion;+42H WORD MinorOperatingSystemVersion;+44H WORD MajorImageVersion;+46H WORD MinorImageVersion;+48H WORD MajorSubsystemVersion;+4AH WORD MinorSubsystemVersion;+4CH DWORD Win32VersionValue;+50H DWORD SizeOfImage;+54H DWORD SizeOfHeaders;+58H DWORD CheckSum;+5CH WORD Subsystem;+5EH WORD DllCharacteristics;+60H DWORD SizeOfStackReserve;+64H DWORD SizeOfStackCommit;+68H DWORD SizeOfHeapReserve;+6CH DWORD SizeOfHeapCommit;+70H DWORD LoaderFlags;+74H DWORD NumberOfRvaAndSizes;+78H IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32,*PIMAGE_OPTIONAL_HEADER32; **必选部分Magic表示可选头的类型,也可以看成创建文件的系统的位数 1234#define IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10b &#x2F;&#x2F; 32位PE可选头#define IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b &#x2F;&#x2F; 64位PE可选头#define IMAGE_ROM_OPTIONAL_HDR_MAGIC 0x107 MajorLinkerVersion链接器的版本号 MinorLinkerVersion链接器的版本号 SizeOfCode代码段的长度，如果有多个代码段，则是代码段长度的总和。 SizeOfInitializedData初始化的数据长度。 SizeOfUninitializedData未初始化的数据长度。 AddressOfEntryPoint 程序入口的RVA，对于exe可以理解为WinMain的RVA。对于DLL可以理解为DllMain的RVA，对于驱动程序，可以理解为DriverEntry的RVA。当然，实际上入口点并非是WinMain，DllMain和DriverEntry，在这些函数之前还有一系列初始化要完成。 BaseOfCode代码段起始地址的RVA。 BaseOfData数据段起始地址的RVA。 可选字段部分ImageBase介绍：映象（加载到内存中的PE文件）的基地址，这个基地址是建议，对于DLL来说，如果无法加载到这个地址，系统会自动为其选择地址。链接器产生可执行文件的时候对应这个地址来生成机器码，所以当文件被装入这个地址时不需要进行重定位操作，装入的速度最快。当文件被装载到其他地址时，进行重定位操作，会慢一点。 对于EXE文件来说，由于每个文件总是使用独立的虚拟地址空间，优先装入地址不可能被其他模块占据，所以EXE总是能够按照这个地址装入。 这也意味着EXE文件不再需要重定位信息。对于DLL文件来说，由于多个DLL文件全部使用宿主EXE文件的地址空间，不能保证优先装入地址没有被其他的DLL使用，所以DLL文件中必须包含重定位信息以防万一。 因此，在前面介绍的 IMAGE_FILE_HEADER 结构的 Characteristics 字段中，DLL 文件对应的 IMAGE_FILE_RELOCS_STRIPPED 位总是为0，而EXE文件的这个标志位总是为1，即DLL中不删除重定位信息，EXE文件中删除重定位信息。 也就是说，这个位置是对应物理内存的地址，再利用RSA，便可以找到真实地址 补：123#define IMAGE_FILE_RELOCS_STRIPPED 0x0001//Relocation info stripped from file.（从文件中删除重定位信息。） 在链接的时候，可以通过对link.exe指定/base:address选项来自定义优先装入地址，如果不指定这个选项的话，一般EXE文件的默认优先装入地址被定为00400000h，而DLL文件的默认优先装入地址被定为10000000h。 SectionAlignment节对齐，PE中的节被加载到内存时会按照这个域指定的值来对齐，比如这个值是0x1000，那么每个节的起始地址的低12位都为0。 FileAlignment节在文件中按此值对齐，SectionAlignment必须大于或等于FileAlignment。 MajorOperatingSystemVersion所需操作系统的版本号，随着操作系统版本越来越多，这个好像不是那么重要了。 MinorOperatingSystemVersion所需操作系统的版本号，随着操作系统版本越来越多，这个好像不是那么重要了。 MajorImageVersion映象的版本号，这个是开发者自己指定的，由连接器填写。 MinorImageVersion映象的版本号，这个是开发者自己指定的，由连接器填写。 MajorSubsystemVersion所需子系统版本号。 MinorSubsystemVersion所需子系统版本号。 Win32VersionValue保留，必须为0。 SizeOfImage映象的大小，PE文件加载到内存中空间是连续的，这个值指定占用虚拟空间的大小。 SizeOfHeaders所有文件头（包括节表）的大小，这个值是以FileAlignment对齐的。 CheckSum映象文件的校验和。 Subsystem运行该PE文件所需的子系统，可以是下面定义中的某一个： DllCharacteristicsDLL的文件属性，只对DLL文件有效，可以是下面定义中某些的组合： 12345678#define IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 0x0040 // DLL can move.#define IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY 0x0080 // Code Integrity Image#define IMAGE_DLLCHARACTERISTICS_NX_COMPAT 0x0100 // Image is NX compatible#define IMAGE_DLLCHARACTERISTICS_NO_ISOLATION 0x0200 // Image understands isolation and doesn&#x27;t want it#define IMAGE_DLLCHARACTERISTICS_NO_SEH 0x0400 // Image does not use SEH. No SE handler may reside in this image#define IMAGE_DLLCHARACTERISTICS_NO_BIND 0x0800 // Do not bind this image.// 0x1000 // Reserved.#define IMAGE_DLLCHARACTERISTICS_WDM_DRIVER 0x2000 //Driver uses WDM model// 0x4000 // Reserved.#define IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE 0x8000 SizeOfStackReserve运行时为每个线程栈保留内存的大小。 SizeOfStackCommit运行时每个线程栈初始占用内存大小。 SizeOfHeapReserve运行时为进程堆保留内存大小。 SizeOfHeapCommit运行时进程堆初始占用内存大小。 LoaderFlags保留，必须为0。 NumberOfRvaAndSizes数据目录的项数，即下面这个数组的项数。 DataDirectory数据目录，这是一个数组，数组的项定义如下： 1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; DWORD Size;&#125; IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;VirtualAddress 是一个RVA，Size：是一个大小。这两个数有什么用呢？一个是地址，一个是大小，可以看出这个数据目录项定义的是一个区域。那他定义的是什么东西的区域呢？前面说了，DataDirectory是个数组，数组中的每一项对应一个特定的数据结构，包括导入表，导出表等等，根据不同的索引取出来的是不同的结构，头文件里定义各个项表示哪个结构，如下面的代码所示： 节（块）表(Section Table)节表是PE文件后续节的描述，Windows根据节表的描述加载每个节。PE文件中所有节的属性都被定义在节表中，节表由一系列的IMAGE_SECTION_HEADER结构排列而成，每个结构用来描述一个节，结构的排列顺序和它们描述的节在文件中的排列顺序是一致的。全部有效结构的最后以一个空的IMAGE_SECTION_HEADER结构作为结束，所以节表中IMAGE_SECTION_HEADER结构数量等于节的数量加一。 节表总是被存放在紧接在PE文件头的地方。节表中 IMAGE_SECTION_HEADER结构的总数总是由PE文件头IMAGE_NT_HEADERS 结构中的FileHeader.NumberOfSections 字段来指定的。 123456789101112131415typedef struct_IMAGE_SECTION_HEADER &#123; BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union &#123; DWORD PhysicalAddress; DWORD VirtualSize; &#125; Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORDPointerToRelocations; DWORDPointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics;&#125; IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER; 需要关注的几个域Name区块名。这是一个由8个ASCII码组成，用来定义区块的名称的数组。多数区块名都习惯性以一个“.”作为开头（例如：.text），这个“.”实际上是不是必须的。值得我们注意的是，如果区块名达到8 个字节，后面就没有0字符了。前边带有一个“$” 的区块名字会从连接器那里得到特殊的待遇，前边带有“$”的相同名字的区块在载入时候将会被合并，在合并之后的区块中，他们是按照“$”后边的字符的字母顺序进行合并的。每个区块的名称都是唯一的，不能有同名的两个区块。但事实上节的名称不代表任何含义，他的存在仅仅是为了正规统一编程的时候方便程序员查看方便而设置的一个标记而已。所以将包含代码的区块命名为“.Data”或者说将包含数据的区块命名为“.Code”都是合法的。当我们要从PE 文件中读取需要的区块时候，不能以区块的名称作为定位的标准和依据，正确的方法是按照IMAGE_OPTIONAL_HEADER32 结构中的数据目录字段结合进行定位。 VirtualSize对表对应的区块的大小，这是区块的数据在没有进行对齐处理前的实际大小。 VirtualAddress该区块装载到内存中的RVA地址。这个地址是按照内存页来对齐的，因此它的数值总是SectionAlignment的值的整数倍。 PointerToRawData指出节在磁盘文件中所处的位置。这个数值是从文件头开始算起的偏移量。 SizeOfRawData该区块在磁盘中所占的大小，这个数值等于VirtualSize字段的值按照FileAlignment的值对齐以后的大小。 Characteristics该区块的属性。该字段是按位来指出区块的属性（如代码/数据/可读/可写等）的标志。 装载过程依靠PointerToRawData，SizeOfRawData，VirtualAddress，VirtualSize这4个字段的值，装载器就可以从PE文件中找出某个节(从PointerToRawData偏移开始的SizeOfRawData字节)的数据，并将它映射到内存中去(映射到从模块基地址偏移VirtualAddress的地方，并占用以VirtualSize的值按照页的尺寸对齐后的空间大小)。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"逆向","slug":"逆向","permalink":"http://penglaidoll.xyz/tags/%E9%80%86%E5%90%91/"},{"name":"PE File","slug":"PE-File","permalink":"http://penglaidoll.xyz/tags/PE-File/"}]},{"title":"UPX壳与Aspack壳脱壳","slug":"re#1","date":"2021-03-27T15:32:00.000Z","updated":"2021-03-27T15:41:38.549Z","comments":true,"path":"posts/b3843843/","link":"","permalink":"http://penglaidoll.xyz/posts/b3843843/","excerpt":"","text":"UPX壳： 单步步进法 ESP定理 全栈入栈，单步步进，发现只有ESP寄存器发生改变，跟随ESP寄存器到数据窗口，下硬件断点，执行文件，到断点处发现全栈出栈指令，应该是到oep了。 查找法（有限制） 既然有pushad，肯定有popad，在当前块直接查找popad，说不定就找到了 二次内存镜像法 在第一个.rsrc段下字节断点，运行，随后在00401000处下段点，运行，之后便接近oep了 Aspack壳： 单步步进发 ESP定理 查找法 二次内存镜像法 模拟跟踪法 找到内存中的sfx部分，输入指令tc eip&lt;(该段地址)执行到指定部分，便到了oep SFX 打开调试设置，找到SFX，利用OD自动找到oep","categories":[{"name":"逆向学习——OD脱壳","slug":"逆向学习——OD脱壳","permalink":"http://penglaidoll.xyz/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94OD%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"OD","slug":"OD","permalink":"http://penglaidoll.xyz/tags/OD/"},{"name":"脱壳","slug":"脱壳","permalink":"http://penglaidoll.xyz/tags/%E8%84%B1%E5%A3%B3/"},{"name":"UPX壳","slug":"UPX壳","permalink":"http://penglaidoll.xyz/tags/UPX%E5%A3%B3/"},{"name":"Aspack壳","slug":"Aspack壳","permalink":"http://penglaidoll.xyz/tags/Aspack%E5%A3%B3/"}]},{"title":"常见OPE","slug":"re#2","date":"2021-03-27T15:32:00.000Z","updated":"2021-03-28T05:26:19.296Z","comments":true,"path":"posts/2a1f355e/","link":"","permalink":"http://penglaidoll.xyz/posts/2a1f355e/","excerpt":"","text":"五种常见语言的OEP特征：C++ （Microsoft Visual C++ 6.0）1234567891011121314151617181920212223242526270040577C &gt;&#x2F;$ 55 PUSH EBP (C的入口)0040577D |. 8BEC MOV EBP,ESP0040577F |. 6A FF PUSH -100405781 |. 68 30B24000 PUSH EasyClea.0040B23000405786 |. 68 84704000 PUSH EasyClea.00407084 ; SE 句柄安装0040578B |. 64:A1 0000000&gt;MOV EAX,DWORD PTR FS:[0]00405791 |. 50 PUSH EAX00405792 |. 64:8925 00000&gt;MOV DWORD PTR FS:[0],ESP00405799 |. 83EC 58 SUB ESP,580040579C |. 53 PUSH EBX0040579D |. 56 PUSH ESI0040579E |. 57 PUSH EDI0040579F |. 8965 E8 MOV [LOCAL.6],ESP004057A2 |. FF15 ECB04000 CALL DWORD PTR DS:[&lt;&amp;KERNEL32.GetVersion&gt;; kernel32.GetVersion -——————————————————————————————————————————– E语言这个和C极度像,要分清 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162630040389F &gt;&#x2F;$ 55 PUSH EBP004038A0 |. 8BEC MOV EBP,ESP004038A2 |. 6A FF PUSH -1004038A4 |. 68 F8724000 PUSH CrackMe.004072F8004038A9 |. 68 04554000 PUSH CrackMe.00405504 ; SE 处理程序安装004038AE |. 64:A1 0000000&gt;MOV EAX,DWORD PTR FS:[0]004038B4 |. 50 PUSH EAX004038B5 |. 64:8925 00000&gt;MOV DWORD PTR FS:[0],ESP004038BC |. 83EC 58 SUB ESP,58004038BF |. 53 PUSH EBX004038C0 |. 56 PUSH ESI004038C1 |. 57 PUSH EDI004038C2 |. 8965 E8 MOV DWORD PTR SS:[EBP-18],ESP004038C5 |. FF15 48704000 CALL DWORD PTR DS:[&lt;&amp;KERNEL32.GetVersion&gt;; kernel32.GetVersion004038CB |. 33D2 XOR EDX,EDX004038CD |. 8AD4 MOV DL,AH004038CF |. 8915 94BA4000 MOV DWORD PTR DS:[40BA94],EDX004038D5 |. 8BC8 MOV ECX,EAX004038D7 |. 81E1 FF000000 AND ECX,0FF004038DD |. 890D 90BA4000 MOV DWORD PTR DS:[40BA90],ECX004038E3 |. C1E1 08 SHL ECX,8004038E6 |. 03CA ADD ECX,EDX004038E8 |. 890D 8CBA4000 MOV DWORD PTR DS:[40BA8C],ECX004038EE |. C1E8 10 SHR EAX,10004038F1 |. A3 88BA4000 MOV DWORD PTR DS:[40BA88],EAX004038F6 |. 33F6 XOR ESI,ESI004038F8 |. 56 PUSH ESI004038F9 |. E8 7A030000 CALL CrackMe.00403C78004038FE |. 59 POP ECX004038FF |. 85C0 TEST EAX,EAX00403901 |. 75 08 JNZ SHORT CrackMe.0040390B00403903 |. 6A 1C PUSH 1C -——————————————————————————————————————————– Delphi （Borland Delphi 6.0 - 7.0）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667004F2F68 &gt; $ 55 PUSH EBP004F2F69 . 8BEC MOV EBP,ESP004F2F6B . 83C4 F0 ADD ESP,-10004F2F6E . 53 PUSH EBX004F2F6F . B8 102B4F00 MOV EAX,Unpacked.004F2B10004F2F74 . E8 EF3BF1FF CALL Unpacked.00406B68004F2F79 . 8B1D F4505000 MOV EBX,DWORD PTR DS:[5050F4] ; Unpacked.00506C14004F2F7F . 8B03 MOV EAX,DWORD PTR DS:[EBX]004F2F81 . E8 56ACF8FF CALL Unpacked.0047DBDC004F2F86 . 8B03 MOV EAX,DWORD PTR DS:[EBX]004F2F88 . BA F42F4F00 MOV EDX,Unpacked.004F2FF4 ; ASCII &quot; Hide Private File Pro&quot;004F2F8D . E8 32A8F8FF CALL Unpacked.0047D7C4004F2F92 . 8B0D 904E5000 MOV ECX,DWORD PTR DS:[504E90] ; Unpacked.00509144004F2F98 . 8B03 MOV EAX,DWORD PTR DS:[EBX]004F2F9A . 8B15 70E44E00 MOV EDX,DWORD PTR DS:[4EE470] ; Unpacked.004EE4BC004F2FA0 . E8 4FACF8FF CALL Unpacked.0047DBF4004F2FA5 . 8B0D 3C525000 MOV ECX,DWORD PTR DS:[50523C] ; Unpacked.0050909C004F2FAB . 8B03 MOV EAX,DWORD PTR DS:[EBX]004F2FAD . 8B15 48B14E00 MOV EDX,DWORD PTR DS:[4EB148] ; Unpacked.004EB194004F2FB3 . E8 3CACF8FF CALL Unpacked.0047DBF4004F2FB8 . 8B0D 0C535000 MOV ECX,DWORD PTR DS:[50530C] ; Unpacked.005090A4004F2FBE . 8B03 MOV EAX,DWORD PTR DS:[EBX]004F2FC0 . 8B15 7CB34E00 MOV EDX,DWORD PTR DS:[4EB37C] ; Unpacked.004EB3C8004F2FC6 . E8 29ACF8FF CALL Unpacked.0047DBF4004F2FCB . 8B0D 30505000 MOV ECX,DWORD PTR DS:[505030] ; Unpacked.005090D4004F2FD1 . 8B03 MOV EAX,DWORD PTR DS:[EBX]004F2FD3 . 8B15 B0BF4E00 MOV EDX,DWORD PTR DS:[4EBFB0] ; Unpacked.004EBFFC004F2FD9 . E8 16ACF8FF CALL Unpacked.0047DBF4004F2FDE . 8B03 MOV EAX,DWORD PTR DS:[EBX]004F2FE0 . E8 8FACF8FF CALL Unpacked.0047DC74004F2FE5 . 5B POP EBX004F2FE6 . E8 7115F1FF CALL Unpacked.0040455C004F2FEB . 00FF ADD BH,BH004F2FED FF DB FF -——————————————————————————————————————————– VB （Microsoft Visual Basic 5.0 / 6.0）123456789101112131415161718192021222324252627282930313233343536373839404100410400 &gt; 68 4C744100 PUSH Unpack_.0041744C ; ASCII &quot;VB5!6&amp;*&quot;00410405 E8 EEFFFFFF CALL &lt;JMP.&amp;msvbvm60.ThunRTMain&gt;0041040A 16 PUSH SS0041040B 0000 ADD BYTE PTR DS:[EAX],AL0041040D 0000 ADD BYTE PTR DS:[EAX],AL0041040F 0030 ADD BYTE PTR DS:[EAX],DH00410411 0000 ADD BYTE PTR DS:[EAX],AL00410413 0038 ADD BYTE PTR DS:[EAX],BH00410415 0000 ADD BYTE PTR DS:[EAX],AL00410417 0000 ADD BYTE PTR DS:[EAX],AL00410419 0000 ADD BYTE PTR DS:[EAX],AL0041041B 0060 9C ADD BYTE PTR DS:[EAX-64],AH0041041E F0:E2 CF LOCK LOOPD SHORT Unpack_.004103F0 ; 不允许锁定前缀00410421 BE 3D439505 MOV ESI,595433D00410426 E1 06 LOOPDE SHORT Unpack_.0041042E00410428 18A5 05D40000 SBB BYTE PTR SS:[EBP+D405],AH0041042E 0000 ADD BYTE PTR DS:[EAX],AL00410430 0000 ADD BYTE PTR DS:[EAX],AL00410432 0100 ADD DWORD PTR DS:[EAX],EAX00410434 0000 ADD BYTE PTR DS:[EAX],AL00410436 9E SAHF -——————————————————————————————————————————– BC++ （Borland C++ 1999）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606100401000 &gt; &#x2F;EB 10 JMP SHORTXXXXXXX.0040101200401002 |66:623A BOUND DI,DWORD PTR DS:[EDX]00401005 |43 INC EBX00401006 |2B2B SUB EBP,DWORD PTR DS:[EBX]00401008 |48 DEC EAX00401009 |4F DEC EDI0040100A |4F DEC EDI0040100B |4B DEC EBX0040100C |90 NOP0040100D -|E9 AC334800 JMP 008843BE00401012 \\A1 9F334800 MOV EAX,DWORD PTR DS:[48339F]00401017 C1E0 02 SHL EAX,20040101A A3 A3334800 MOV DWORD PTR DS:[4833A3],EAX0040101F 52 PUSH EDX00401020 6A 00 PUSH 000401022 E8 11110800 CALL &lt;JMP.&amp;KERNEL32.GetModuleHandleA&gt;00401027 8BD0 MOV EDX,EAX00401029 E8 3A1B0600 CALLXXXXXXX.00462B680040102E 5A POP EDX0040102F E8 981A0600 CALLXXXXXXX.00462ACC00401034 E8 6F1B0600 CALLXXXXXXX.00462BA800401039 6A 00 PUSH 00040103B E8 782E0600 CALLXXXXXXX.00463EB800401040 59 POP ECX00401041 68 48334800 PUSHXXXXXXX.0048334800401046 6A 00 PUSH 000401048 E8 EB100800 CALL &lt;JMP.&amp;KERNEL32.GetModuleHandleA&gt;0040104D A3 A7334800 MOV DWORD PTR DS:[4833A7],EAX00401052 6A 00 PUSH 000401054 E9 6B900600 JMPXXXXXXX.0046A0C400401059 &gt; E9 A62E0600 JMPXXXXXXX.00463F04 -——————————————————————————————————————————– Dasm:汇编123456789101112131415161700401000 &gt;&#x2F;$ 6A 00 PUSH 0 ; &#x2F;pModule &#x3D; NULL00401002 |. E8 C50A0000 CALL &lt;JMP.&amp;KERNEL32.GetModuleHandleA&gt; ; \\GetModuleHandleA00401007 |. A3 0C354000 MOV DWORD PTR DS:[40350C],EAX0040100C |. E8 B50A0000 CALL &lt;JMP.&amp;KERNEL32.GetCommandLineA&gt; ; [GetCommandLineA00401011 |. A3 10354000 MOV DWORD PTR DS:[403510],EAX00401016 |. 6A 0A PUSH 0A ; &#x2F;Arg4 &#x3D; 0000000A00401018 |. FF35 10354000 PUSH DWORD PTR DS:[403510] ; |Arg3 &#x3D; 000000000040101E |. 6A 00 PUSH 0 ; |Arg2 &#x3D; 0000000000401020 |. FF35 0C354000 PUSH DWORD PTR DS:[40350C] ; |Arg1 &#x3D; 00000000 另一种： 12345678910111213141516171819202100401025 &gt;&#x2F;$ 6A F6 PUSH -0A 00401027 |. E8 A0000000 CALL &lt;JMP.&amp;kernel32.GetStdHandle&gt; 0040102C |. A3 00304000 MOV DWORD PTR DS:[403000],EAX00401031 |. 6A F5 PUSH -0B 00401033 |. E8 94000000 CALL &lt;JMP.&amp;kernel32.GetStdHandle&gt; 00401038 |. A3 04304000 MOV DWORD PTR DS:[403004],EAX0040103D |. 6A 01 PUSH 1 0040103F |. 68 00104000 PUSH EchoLine.00401000 00401044 |. E8 8F000000 CALL &lt;JMP.&amp;kernel32.SetConsoleCtrlHandle&gt;00401049 |. 6A 07 PUSH 7 0040104B |. FF35 00304000 PUSH DWORD PTR DS:[403000] Vc++8.012345678910111213141516171819202100403A30 &gt; $ E8 6E270000 call VC8.004061A300403A35 .^ E9 79FEFFFF jmp VC8.004038B300403A3A &#x2F;$ 55 push ebp00403A3B |. 8BEC mov ebp,esp00403A3D |. 83EC 08 sub esp,0x800403A40 |. 897D FC mov [local.1],edi ; ntdll.7C93022800403A43 |. 8975 F8 mov [local.2],esi00403A46 |. 8B75 0C mov esi,[arg.2]00403A49 |. 8B7D 08 mov edi,[arg.1] ; VC8.&lt;ModuleEntryPoint&gt;00403A4C |. 8B4D 10 mov ecx,[arg.3]00403A4F |. C1E9 07 shr ecx,0x7 转载自52论坛https://www.52pojie.cn/thread-139728-1-1.html","categories":[{"name":"逆向学习——OD","slug":"逆向学习——OD","permalink":"http://penglaidoll.xyz/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94OD/"}],"tags":[{"name":"脱壳","slug":"脱壳","permalink":"http://penglaidoll.xyz/tags/%E8%84%B1%E5%A3%B3/"},{"name":"oep","slug":"oep","permalink":"http://penglaidoll.xyz/tags/oep/"}]},{"title":"global和nonlocal的使用","slug":"python#12","date":"2021-03-24T15:04:14.000Z","updated":"2021-03-28T05:59:55.548Z","comments":true,"path":"posts/6d738442/","link":"","permalink":"http://penglaidoll.xyz/posts/6d738442/","excerpt":"","text":"global关键字如下一段代码： 12345678910111213count = 1def main(): count count+=1 print(count) main() 我们会发现程序报错而无法正常执行，这是因为count变量是全局变量，而在局部中是无法修改全局变量的 如果我们改成下面这样 ` 1234567891011count = 1def main(): global count count+=1 print(count)main() ` 程序可以正常执行了！ 这里global关键字可以让全局变量在局部中进行更改，只需要声明就行。 假如不进行声明也不修改呐？ 12345678910111213count = 1def main(): count count+=1 print(count)main() 是可以正常运行的 nonlocal关键字假如我们在一段函数定义中再引入一个函数定义而形成嵌套 12345678910111213def main(): count = 1 def pp(): nonlocal count print(count) pp()main() 这里可以看出，nonlocal声明是针对在嵌套函数的上一个函数的声明的使用 输出为 11","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python中对于文件的操作","slug":"python#11","date":"2021-03-19T15:57:01.000Z","updated":"2021-03-28T05:59:51.350Z","comments":true,"path":"posts/140ab620/","link":"","permalink":"http://penglaidoll.xyz/posts/140ab620/","excerpt":"","text":"对于文件的更改：Open函数：python中利用open函数来实现对文件的读取和更改举个栗子： 1234def main(): a &#x3D; open(&#39;a.txt&#39;,&#39;w&#39;,encoding&#x3D;utf-8) printf(a.read()) a.close() 这里我们用open()函数打开一个文件，注意open函数的返回值为一个对象，之后，我们对这个对象使用read方法来实现对文档的读取下面是对于传入的第二个参数的解释，其决定了open的操作模式| 操作模式 | 具体含义 || ——– | ——————————– || &#39;r&#39; | 读取 （默认） || &#39;w&#39; | 写入（会先截断之前的内容） || &#39;x&#39; | 写入，如果文件已经存在会产生异常 || &#39;a&#39; | 追加，将内容写入到已有文件的末尾 || &#39;b&#39; | 二进制模式 || &#39;t&#39; | 文本模式（默认） || &#39;+&#39; | 更新（既可以读又可以写） | With open as:当我们使用Open函数以后，我们不得不用close方法来对文件进行关闭，我们更常用的是这个 123def main(): with open(&#39;a.txt&#39;,&#39;w&#39;,encoding&#x3D;utf-8) as a: printf(a.read()) With open as 可以根据我们的使用情况(上下文环境)而适时关闭文件 Try:继续上面的代码，当我们当前目录的文件夹中无a.txt文件时，程序会报错，那么怎么避免这种情况呐 12345678910111213def main(): try: with open(&#39;a.txt&#39;,&#39;w&#39;,encoding&#x3D;utf-8) as a: printf(a.read()) except FileNotFoundError: print(&#39;无法打开指定的文件!&#39;) except LookupError: print(&#39;指定了未知的编码!&#39;) except UnicodeDecodeError: print(&#39;读取文件时解码错误!&#39;) finally: if a: print(&#39;Complete!&#39;) 这里引入了try except finally函数，这个函数可以根据不同的报错情况来选择性输出，属于选择结构，最后的finally又叫做“总要执行”，无论上述出现什么情况，这一语句总要执行，多用这个语句来保证程序的正确执行 For I in a.readlines():这一语句是用来整行遍历要读取的文件的内容","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python面向对象编程进阶③","slug":"python#10","date":"2021-03-19T14:47:37.000Z","updated":"2021-03-28T05:59:45.967Z","comments":true,"path":"posts/e04534a6/","link":"","permalink":"http://penglaidoll.xyz/posts/e04534a6/","excerpt":"","text":"静态方法与类方法静态方法：使用@staticmethod装饰器进行装饰可以直接被类调用而不用实例化假如我们要判定一个三角形是不是三角形 12345678910111213class San(): def __init__(self,a,b,c): self.__a &#x3D; a self.__b &#x3D; b self.__c &#x3D; c @staticmethod def is_right(a,b,c): if ((a+b&gt;c)&amp;(a+c&gt;b)&amp;(b+c&gt;a)): return True else: return Falses &#x3D; San(3,4,5)s.is_right() 这样我们会发现报错，显示 1is_right() missing 3 required positional arguments: &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; 这里我们就能看出，静态方法是不传入实例化参数的这样一来，我们可以在三角形S实例化之前用该方法判断S的三个边能否组成一个三角形静态方法的调用与实例化无关，只与该类和其定义有关 类方法使用@classmethod装饰器进行装饰传入的参数第一个必须为cls(表示传入类它自己)别的和普通方法差不多 三种方法的主要区别：普通方法第一个传入的参数是self，表示该方法引用的的有可能是类属性/方法，也有可能是实例属性/方法，实例的优先级大于类的类方法第一个传入的参数为cls，表示该方法引用的是类属性/方法静态方法类似于函数定义，只传入定义的东西","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"typedef与#define","slug":"CCpp#6","date":"2021-03-18T08:52:33.000Z","updated":"2021-03-28T06:00:32.062Z","comments":true,"path":"posts/3cbd2c1d/","link":"","permalink":"http://penglaidoll.xyz/posts/3cbd2c1d/","excerpt":"","text":"Typedef与#define几个区别： 1.typeof只能为类型定义一个别的符号名称，(#define)不仅能为类型定义别名，还能为数值定义别名2.typedef由编译器执行解释，(#define)由预编译器处理3.(#define)可以用其他类型说明符进行补充，而typeof不行 栗子： 1234#define p int;unsigned p n;&#x2F;&#x2F;可以typedef int p;unsigned p n;&#x2F;&#x2F;不可以 （这里可以看出，#define实际上起的是等量代换作用，而typedef不是）4.连续定义变量中#define的弱点栗子： 12#define a char *;a b,c; 等效于 1char *b,c; 也就是说，只有b被定义为了指针，c仍为字符变量 12typedef char* a;a b,c; 这里，可以将b,c都定义为字符变量指针","categories":[{"name":"C/C++语言学习","slug":"C-C-语言学习","permalink":"http://penglaidoll.xyz/categories/C-C-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"巧用异或交换数","slug":"CCpp#5","date":"2021-03-18T08:46:46.000Z","updated":"2021-03-28T06:00:28.153Z","comments":true,"path":"posts/994d2d1d/","link":"","permalink":"http://penglaidoll.xyz/posts/994d2d1d/","excerpt":"","text":"利用异或交换两个变量中存储的数正常情况下，我们通常定义swap利用地址交换两个变量中的值但如果我们只是交换两个整型变量的值呐？这里可以用到异或的小性质了 假设两个整形8bit的2进制数a,b交换的原理为 12a&#96;&#x3D;(a^b)^bb&#96;&#x3D;(a^b)^a&#96; 说说第一个的原理 12345a b a^b a&#96;1 1 0 11 0 1 10 1 1 00 0 0 0 由上推出，一个数，被同一个数异或两遍，数的大小不变","categories":[{"name":"C/C++语言学习","slug":"C-C-语言学习","permalink":"http://penglaidoll.xyz/categories/C-C-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"逻辑运算的短路性","slug":"CCpp#4","date":"2021-03-18T08:44:30.000Z","updated":"2021-03-28T06:00:24.786Z","comments":true,"path":"posts/d11843d/","link":"","permalink":"http://penglaidoll.xyz/posts/d11843d/","excerpt":"","text":"逻辑运算的短路性（表达式1）&amp;&amp;（表达式2）若表达式1为假，总式子一定为假，表达式2被短路（表达式1）||（表达式2）若表达式1为真，总式子一定为真，表达式2被短路 补充一下应用在网络上看到一个微软的面试题：求 1 + 2 + 3 + … + n要求：不能用乘除法，不能用if,while, switch,case, 不能用(a &lt; b ? a : b)三目运算符程序如下： 1234567891011121314#include &lt;stdio.h&gt;int fun(int n) &#123; int p&#x3D;0; int sum&#x3D;0; p &#x3D; n &amp;&amp; (sum&#x3D;n+fun(n-1)); return sum;&#125;int main() &#123; int a&#x3D;3,b; b &#x3D; fun(a); printf(&quot;%d&quot;,b); return 0; &#125; 这里面非常巧妙地用到了逻辑运算的短路原理，当n为0时，便不再执行后续语句，这上面的p只起到存储过程量的作用，可以忽略不看 原帖点这里","categories":[{"name":"C/C++语言学习","slug":"C-C-语言学习","permalink":"http://penglaidoll.xyz/categories/C-C-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"数据结构入门","slug":"data str#1","date":"2021-03-16T15:26:15.000Z","updated":"2021-03-16T15:47:36.098Z","comments":true,"path":"posts/4729e793/","link":"","permalink":"http://penglaidoll.xyz/posts/4729e793/","excerpt":"","text":"最近一段时间开始为了提高编程本领而开始学习数据结构了，据说学习好了不仅编程技巧直线上升，考试不挂科了，对Reverse也有好处(笑)便开始了万里长征的第一步 在网上搜索了一下关于数据结构的内容，大致这门课是学习如何更好的存储数据，据我自己感觉，学数据结构最大的作用就是让我们去获得更好的编程逻辑，以及我们日常用的如py中的dict,list，C中的链表，汇编经常用的栈等的实现原理也就是说，不学这个并不影响你去编程，但会决定你是不是一个好的程序员，而且，有了这些底层的理解，我们就更容易去理解他人的程序抱着成为更好的自己的信念，努力吧！ 数据结构的理解数据结构有两个要素，一个是数据元素的集合，另一个是关系的集合形式上，通常用二元组来表示 分类按照元素关系不同，分为以下四种 1234|--集合结构(元素属于同一集合)|--线性结构(元素一对一的关系)(常见列表，队列，栈等)|--树形结构(元素一对多的关系)(常见二叉树，二叉查找树，平衡二叉查找树等)|--图形结构(元素多对多的关系) 按照存储方式不同，分为以下两种 12|--顺序存储结构(数据元素在存储器中连续存储)|--链式存储结构(每个元素里设置了指向下一个元素的指针) 算法复杂度：时间频度，指算法中语句的执行次数，一般用T(n)表示，n为问题的规模有时，时间频度的表示方法过于复杂，于是又引入了时间复杂度，这个只关心算法中最耗时的部分，通常用时间频度中最能决定其大小的简单函数来表示空间复杂度指运行该算法所占用的存储空间大小，记为S(n)","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://penglaidoll.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://penglaidoll.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"记录一次作业","slug":"CCpp#3","date":"2021-03-14T23:26:54.000Z","updated":"2021-03-28T06:00:21.275Z","comments":true,"path":"posts/f5d29790/","link":"","permalink":"http://penglaidoll.xyz/posts/f5d29790/","excerpt":"","text":"学校开了C语言课，老师布置了一个简单的小程序，输入一个三位整数，然后分别输出这个数的个位，十位，百位，为了写出一个比较完善的代码，花了不少心思，也学了不少东西，在此记录一下： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void main() &#123; &#x2F;&#x2F;定义字符数组，以存储输入的数字 char strin[1024]; &#x2F;&#x2F;定义一个指针，以确保strlen函数的正常运行 char *strin_ptr; &#x2F;&#x2F;将i初始化为零，以防初始化导致i的随机定义进而导致内存中混进莫名的东西 &#x2F;&#x2F;其实这里也可以不初始化，因为if的第一个判断条件已经避免这个问题了 int i&#x3D;0,p; strin_ptr &#x3D; strin; &#x2F;&#x2F;do while将先执行一遍传入需要的数字，然后进行判断，若符合要求，则不再执行循环 do &#123; &#x2F;&#x2F;清空缓冲区 fflush(stdin); printf(&quot;Please input 3 integer:\\n&quot;); scanf(&quot;%d&quot;,&amp;i); &#x2F;&#x2F;itoa将整形转换为字符，以便存储和计数 itoa(i,strin,10); &#x2F;&#x2F;利用strlen判断输入数字的位数 p &#x3D; strlen(strin_ptr); &#x2F;&#x2F;判断位数、类型是否符合 if ((t &#x3D;&#x3D; 0)|| (strin[0]&#x3D;&#x3D;&#39;0&#39;) || (p !&#x3D; 3)) &#123; printf(&quot;This is ont a right integer,please input again!\\n&quot;); &#125; &#125; while ((t &#x3D;&#x3D; 0) || (strin[0]&#x3D;&#x3D;&#39;0&#39;) || (p !&#x3D; 3)); printf(&quot;Hundred position &#x3D; %c\\n&quot;,strin[0]); printf(&quot;Ten position &#x3D; %c\\n&quot;,strin[1]); printf(&quot;Individual position &#x3D; %c\\n&quot;,strin[2]); system(&quot;pause&quot;);&#125; 缓冲区问题：fflush(stdin)在此之前，我的代码是直接用的while循环且没有fflush(stdin)这一语句，如下： 1234while (((int)i!&#x3D;i) || (strin[0]&#x3D;&#x3D;&#39;0&#39;) || (p !&#x3D; 3)) &#123; printf(&quot;This is ont a right integer,please input again!\\n&quot;); scanf(&quot;%d,&amp;i&quot;); &#125; 大概就是上面这个样子造成的一个问题就是当第一次输入如abc这样不符合条件的字符类型的东西的时候，缓冲区存入‘abc’三个字符，第一个scanf读入因不符合类型要求而无法读取缓冲区的内容，之后执行while循环语句，输出“请重新输入”并再次执行scanf语句，我原本想着利用第二个scanf语句更改输入，结果scanf“不讲武德”，因为缓冲区已经有东西了(我们输入的不符合类型的内容)，所以scanf默认直接读取缓冲区的东西，导致进入了死循环为了解决上面这个问题，我改用了do while并在第一句直接加上了fflush(stdin)语句来清空标准输入的缓冲区，这样，每一次执行循环的开始，都会清空输入的缓冲区，防止进入死循环 字符串与字符问题：Gets():C语言中，其实不存在字符串这个东西，只有char类型来存储字符，能勉强算上存储字符的变量只有字符数组了，一个字符数组的名称相当于指向其首字母元素的指针，但很可惜，字符数组并不能作为变量传入scanf，会报错。所以，为了将缓冲区的字符串传入，不能用scanf,要用gets(),并将要传入的字符数组作为参数传入 判断类型是否正确：刚开始在while中我用了一个强制类型转换(int)i!=i来判断i是不是输入了正确类型，其实意义不大，因为在scanf中也有，只会读取缓冲区中的整型，如果我们输入了错误的类型，scanf压根不会读取，这里我们就要用到scanf的返回值了 scanf的返回值：scanf函数其实是存在返回值的，他返回读取到的匹配字符数目，比如我们输了3个%d,恰好缓冲区有三个整型的数与之匹配，那么就返回3，如果没有匹配的类型，scanf就不会读取缓冲区的任何内容，并返回0.在这里重新说一下scanf的作用，其读取缓冲区中的内容并将其赋值到传入的后续参数中去，读取的内容与传入的第一个参数中的%+字母有关，其决定了读取内容的类型 判断字符数组的长度我也不知道怎么回事，我试着将字符数组a作为参数传入strlen函数却发现编译器报错，后来查了一下,strlen函数的声明是这样的 1unsigned int strlen(char *s); 其传入的参数是指针，但理应传入数组应该也不会报错，最终我又加了一个指针来防止它报错 strlen函数和sizeof函数的区别sizeof函数和strlen函数一样，传入的参数类型须是指针，当然，当一个字符串被赋值进入一个指针后，该指针就指向了一个字符串，也可以说，字符串就相当于了一个指针的地位，所以可以直接作为参数传入这两个函数中去。strlen读取并返回字符串实际长度,而sizeof返回包括0/在内的所有字符细节，也就是在内存中的长度——————————————————对于上面的后续补充：get()函数有一个大缺点，他会无限读取stdin中的字符串直到遇见/0或换行符，也就是说，如果读取的字符串长度大于字符数组的长度，就会发生内存越界的坏情况为了防止这种情况，我们最好使用fget函数 1234格式fget(char* char,int n,FILE* stream)栗子fget(strlist,sizeof(strlist),stdin) 传入的第一个参数为指向字符串存储的变量的指针，第二个参数为读取字符串的长度，通常用sizeof来限制，传入的第三个参数为文件指针，以stdin使其读取输入缓冲区","categories":[{"name":"C/C++语言学习","slug":"C-C-语言学习","permalink":"http://penglaidoll.xyz/categories/C-C-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python基础进阶——list与dict","slug":"python#9","date":"2021-03-10T03:21:16.876Z","updated":"2021-03-28T05:59:41.648Z","comments":true,"path":"posts/8a0f52d1/","link":"","permalink":"http://penglaidoll.xyz/posts/8a0f52d1/","excerpt":"","text":"再补充一下关于list和dict的一些基础知识 不可变对象与可变对象：Str,dict的key等都是不可变对象比如我们调用replace函数 123&gt;&gt;A &#x3D; &#39;abc&#39;&gt;&gt;A.replace(&#39;a&#39;,&#39;A&#39;)&#39;Abc&#39; 看上去是变了，但当我们再次输入A时，我们发现： 12&gt;&gt;A&#39;abc&#39; 换种方式来看看： 123&gt;&gt;B &#x3D; A.replace(&#39;a&#39;,&#39;A&#39;)&gt;&gt;B&#39;Abc&#39; 为什么呢，因为str是不可变对象，当我们对一个str对象调用任何方法时，都不会改变这个不可变对象，而是创建新的不同的对象并返回现在我们去理解dict的key为什么时不可变对象 list和dict的优缺点：在理解key为不可变对象之前，我们先看一下list与dict的优缺点和list相比，dict查找和插入对象的速度更快，但消耗的内存更高，更浪费内存，也就是说,dict牺牲了内存来换取速度，之所以这个样子，就要谈到dict的原理了 关于list与链表以下的内容是我在网上查阅大佬资料时找到的list其实是用链表的方式存储的。假如我们有一个列表a =[1,2,3]，我们知道，链表的名称存储第一个元素的地址，也就是相当于名称是指向第一个元素的指针，第一个元素的指针再指向第二个元素，以此类推，我们便实现了元素的顺序排列。当我们想插入或删除一个元素，比如我们想在第一个和第二个元素之间插入一个5，我们可以直接通过链表的形式来实现。先通过添加一个链节5，让第一个元素的指针指向该链节，再让该链节的指针指向原来的第二个元素，这样便实现了插入，也就是说，在内存中，这些元素不一定是顺序排列的，但也可以实现顺序访问当我们想要查找某个元素时，因为是链表，所以我们不得不从头开始遍历，这也就是为什么list查找这么慢的原因 关于dict与哈希表dict的存储方式与list截然不同，dict采用了一种哈希算法，将key值利用哈希算法转换为一个数，再利用这个数找到相对应的值，不同的key通过哈希算法得到的值有很大概率不同，所以不同的key存储的地方不同，这才有了一一对应的原则。举个栗子：有一个字典{‘a’:1,’b’:2,’c’:3},我们想利用key’c’来查找，首先利用哈希算法将key’c’算出一个值，咱假设为233，再在内存空间开辟一个大空间0-1000出来，然后根据算出来的值将’c’的value存进对应的内存空间中去，所有的键值对都是这样存储的，因此，当我们想要取一个key的value时，没必要全部遍历，直接用哈希算法去算，然后找到对应的就可以了，所以dict的查找速度很快,但我们不得不得提前开辟一个大空间，所以dict又很消耗内存由上，我们可以推知为什么key为不可变对象了,dict通过key来存储值，假如key变了，那么下一次寻找时寻到的地址不同了，整个dict不就乱了吗补充一点：不同的key通过哈希算法得到的值有很大概率不同，也就是说，有小概率是相同的，这就要求设计哈希表时要尽量减少冲突，这个就是设计编译器的事情了。","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python面向对象编程进阶②","slug":"python#8","date":"2021-03-10T03:17:27.799Z","updated":"2021-03-28T05:59:36.541Z","comments":true,"path":"posts/794c651c/","link":"","permalink":"http://penglaidoll.xyz/posts/794c651c/","excerpt":"","text":"对于类的定制：str:用于返回当前类的自定义名称举个栗子： 1234class pp(): name &#x3D; &#39;ff&#39; passprint(pp()) 这样的话，会输出以下内容 1&lt;__main__.pp object at 0x0000023A8A958E50&gt; 假如说，我们加入__str__方法： 12345class pp(): name &#x3D; &#39;ff&#39; def __str__(self): return &#39;pp(name:%s)&#39; % &#39;ff&#39;print(pp()) 这样我们返回的就是： 1pp(name:ff) 也就是说，我们通过定义__str__方法，并返回我们想要输出的内容，那么当我们想要直接访问这个类时，系统会主动调用__str__方法，返回的不是类类型的标志语，而是我们自定义的内容 对于可迭代对象和迭代器的补充：之前我们说过，能被for直接作用的是可迭代对象，能使用next()方法的是迭代器，这里我们完善一下我们知道，一个对象中往往含有许多方法和属性，而dir函数可以帮助我们查看这些方法和属性。当我们对一个迭代器使用dir函数查看时，我们能看到其中有iter()和next()方法，这个很关键。在python中，若一个对象含有iter()方法，那么这个方法会返回一个可迭代对象，而若再含有__next__方法，那么这个对象就可以被调用next()方法，那么该对象就是迭代器由此，可迭代对象和迭代器都有__iter__方法，都可被for循环调用，迭代器中多了__next__方法，可用next()方法迭代由此，我们可以创建自己的可迭代对象了：以斐波那契数列为例： 12345678910class Fib(object): def __init__(self): self.a, self.b &#x3D; 0, 1 # 初始化两个计数器a，bdef __iter__(self): return self # 实例本身就是迭代对象，故返回自己def __next__(self): self.a, self.b &#x3D; self.b, self.a + self.b # 计算下一个值 if self.a &gt; 100: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 栗子中，我们定义了iter__方法使类实例化过程中返回一个可迭代对象，用__next__（）方法定义发生迭代的过程对于这个例子进行简单分析：__iter__使得一个对象成为可迭代对象__next__定义了该迭代器发生一次迭代的过程和结果StopIteration(终止异常):让一个迭代器终止迭代发生异常比如for循环自带异常处理，所以我们在遍历列表时不会因索引过大报错导致的程序终止,while循环则没有异常处理，所以我们在自定义可迭代对象时，为了防止无休止的迭代，要加上stopiteration异常，使之迭代到一定程度时触发异常，转而让异常处理来处理，从而终止迭代。在此处，并不是真的发生错误了，而是相当于换了一种方式告诉调用者已经迭代完毕。以上，我们发现自己所定义的迭代器并不支持索引调用其中的元素，这时，我们加入__getitem()方法的定义，这样，我们就可以通过访问下标索引的方式来访问可迭代对象中的元素 __getitem__方法当实例对象使用[]运算符取值时，会自动调用调用内建函数（方法）getitem()，并将[]中的内容作为一个参数传入__getitem__方法中。由此看出，当我们想通过访问下标的方式让自定义实例对象返回对应列表等可迭代对象或字典中的目标内容时，只需定义__getitem__对象使其返回就可举个栗子： 123456789class DataBase: def __init__(self): &#39;&#39;&#39;初始化方法&#39;&#39;&#39; self.lt &#x3D; [3,6,9] def __getitem__(self, key): return self.lt[key] data &#x3D; DataBase()print(data[1]) 输出： 1&gt;&gt;6 不难想到，列表的实现方式与这个如出一辙 __dict__属性之前我们用dir函数查看对象所含有或继承的方法和属性，现在我们介绍一个内置的__dict__属性，用它来查看某一对象自己的属性和方法，(当然，其作为对象的一个属性，它的作用之一也是存储这些信息)在这里，与dir有几点不同：1.dir函数生成的是list结构，其中只包括属性和方法的名称__dict__则展示了其作为dict的结构，key对应名称，value对应具体的值或方法定义2.dir函数生成全部的属性和方法(包括继承的)__dict__属性只展示部分属性或方法(不包括继承的)3.利用__dict__可以更改对象的属性，而dir不可栗子： 1Classname.__dict__[key] &#x3D; value 和正常的字典赋值差不多，就是多了一个类或实例访问另外，实例对象和类的__dict__属性有所不同举个栗子： 1234567891011class DataBase: def __init__(self): &#39;&#39;&#39;初始化方法&#39;&#39;&#39; self.lt &#x3D; [3,6,9] def __getitem__(self, key): return self.lt[key] def ff(self): return self.lt[2]data &#x3D; DataBase()print(data.__dict__)print(DataBase.__dict__) 返回 12&#123;&#39;lt&#39;: [3, 6, 9]&#125;&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;__init__&#39;: &lt;function DataBase.__init__ at 0x0000018994282040&gt;, &#39;__getitem__&#39;: &lt;function DataBase.__getitem__ at 0x00000189942820D0&gt;, &#39;ff&#39;: &lt;function DataBase.ff at 0x0000018994282160&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;DataBase&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;DataBase&#39; objects&gt;, &#39;__doc__&#39;: None&#125; 可见实例对象的__dict__属性仅包含self.xxx等的实例化属性，而类则相对包括更多的属性方法等(包括类函数，静态函数，全局变量等) 注意：如int,list,dict等的内置数据类型无__dict__属性 部分总结自点这里","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"几种特殊的数据类型","slug":"CCpp#2","date":"2021-03-08T02:52:23.000Z","updated":"2021-03-28T06:00:17.563Z","comments":true,"path":"posts/85a1c1ed/","link":"","permalink":"http://penglaidoll.xyz/posts/85a1c1ed/","excerpt":"","text":"size_t全称为size type,属于一种整型类型，能够保存一个整数，这个整数往往是一个大小(size)，也就是说，size_t是用来记录大小的数据类型类似的还有wchar_t,ptrdiff_t wchar_t即wide char type,是一种记录一个宽字符的数据类型 ptrdiff_t即pointer difference type,用来记录两个指针之间的距离的数据类型 补充：一般来说，以上三种数据类型均需要typedef来实现，而程序员们为了方便使用和记忆而人为规定了这么几种，但在较新的C/C++标准中，wchar_t已经被涵盖在数据类型中了可以直接使用了，其他的数据类型可以在其他常见的头文件的代码中看到定义","categories":[{"name":"C/C++语言学习","slug":"C-C-语言学习","permalink":"http://penglaidoll.xyz/categories/C-C-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python内置函数总结","slug":"python#7","date":"2021-03-04T01:08:21.000Z","updated":"2021-03-28T05:59:33.052Z","comments":true,"path":"posts/cf4bdb1c/","link":"","permalink":"http://penglaidoll.xyz/posts/cf4bdb1c/","excerpt":"","text":"Python内置的函数及其用法。 分类为了方便记忆，已经有很多开发者将这些内置函数进行了如下分类： 数学运算(7个)类型转换(24个)序列操作(8个)对象操作(7个)反射操作(8个)变量操作(2个)交互操作(2个)文件操作(1个)编译执行(4个)装饰器(3个) 汇总数学运算abs 求数值的绝对值divmod 返回两个数值的商和余数max 返回可迭代对象中的元素中的最大值或者所有参数的最大值min 返回可迭代对象中的元素中的最小值或者所有参数的最小值pow 返回两个数值的幂运算值或其与指定整数的模值round 对浮点数进行四舍五入求值sum 对元素类型是数值的可迭代对象中的每个元素求和 类型转换bool 根据传入的参数逻辑值，创建一个新的布尔值int 根据传入的参数，创建一个新的整数float 根据传入的参数，创建一个新的浮点数complex 根据传入参数，创建一个新的复数str 返回一个对象的字符串表现形式(给用户)bytearray 根据传入的参数，创建一个新的字节数组bytes 根据传入的参数，创建一个新的不可变字节数组memoryview 根据传入的参数，创建一个新的内存查看对象ord 返回Unicode字符对应的整数chr 返回整数所对应的Unicode字符bin 将整数转换成2进制字符串oct 将整数转化成8进制数字符串hex 将整数转换成16进制字符串tuple 根据传入的参数，创建一个新的元组list 根据传入的参数，创建一个新的列表dict 根据传入的参数，创建一个新的字典set 根据传入的参数，创建一个新的集合frozenset 根据传入的参数，创建一个新的不可变集合enumerate 根据可迭代对象创建枚举对象range 根据传入的参数，创建一个新的range对象iter 根据传入的参数，创建一个新的可迭代对象slice 根据传入的参数，创建一个新的切片对象super 根据传入的参数，创建一个新的子类和父类关系的代理对象object 创建一个新的object对象 序列操作all 判断可迭代对象的每个元素是否都为True值any 判断可迭代对象的元素是否有为True值的元素filter 使用指定方法过滤可迭代对象的元素map 使用指定方法去作用传入的每个可迭代对象的元素，生成新的可迭代对象next 返回可迭代对象中的下一个元素值reversed 反转序列生成新的可迭代对象sorted 对可迭代对象进行排序，返回一个新的列表zip 聚合传入的每个迭代器中相同位置的元素，返回一个新的元组类型迭代器 对象操作help 返回对象的帮助信息dir 返回对象或者当前作用域内的属性列表id 返回对象的唯一标识符hash 获取对象的哈希值type 返回对象的类型，或者根据传入的参数，创建一个新的类型len 返回对象的长度ascii 返回对象的可打印表字符串表现方式format 格式化显示值 反射操作vars 返回当前作用域内的局部变量，和其值组成的字典，或者返回对象的属性列表isinstance 判断对象是否是类或者类型元组中任意类元素的实例issubclass 判断类是否是另外一个类或者类型元组中任意类元素的子类hasattr 检查对象是否含有属性getattr 获取对象的属性值setattr 设置对象的属性值delattr 删除对象的属性callable 检测对象是否可被调用 变量操作globals 返回当前作用域内的全局变量，和其值组成的字典locals 返回当前作用域内的局部变量，和其值组成的字典 交互操作print 向标准输出对象打印输出input 读取用户输入值 文件操作open 使用指定的模式和编码打开文件，返回文件读写对象 编译执行compile 将字符串编译为代码或者AST对象，使之能够通过exec语句来执行或者eval进行求值eval 执行动态表达式求值exec 执行动态语句块repr 返回一个对象的字符串表现形式(给解释器) 装饰器property 标示属性的装饰器classmethod 标示方法为类方法的装饰器staticmethod 标示方法为静态方法的装饰器具体每个函数的解析如下： 数学运算abs：求数值的绝对值 1234&gt;&gt;&gt; abs(-1)1&gt;&gt;&gt; abs(1)1 divmod：返回两个数值的商和余数 1234&gt;&gt;&gt; divmod(5,2)(2, 1)&gt;&gt; divmod(5.5,2)(2.0, 1.5) max：返回可迭代对象中的元素中的最大值或者所有参数的最大值 12345678&gt;&gt;&gt; max(1,2) # 传入参数 取较大者2&gt;&gt;&gt; max(&#39;123&#39;) # 传入1个可迭代对象，取其最大元素值&#39;3&#39;&gt;&gt;&gt; max(-1,0) # 数值默认取数值较大者0&gt;&gt;&gt; max(-1,0,key &#x3D; abs) # 传入了求绝对值函数，则参数都会进行求绝对值后再取较大者-1min：返回可迭代对象中的元素中的最小值或者所有参数的最小值 12345678&gt;&gt;&gt; min(1,2) # 传入3个参数 取3个中较小者1&gt;&gt;&gt; min(&#39;123&#39;) # 传入1个可迭代对象，取其最小元素值&#39;1&#39;&gt;&gt;&gt; min(-1,-2) # 数值默认去数值较小者-2&gt;&gt;&gt; min(-1,-2,key &#x3D; abs) # 传入了求绝对值函数，则参数都会进行求绝对值后再取较小者-1 pow：返回两个数值的幂运算值或其与指定整数的模值 12345&gt;&gt;&gt; pow(2,3)&gt;&gt;&gt; 2**3&gt;&gt;&gt; pow(2,3,4)&gt;&gt;&gt; pow(2,3)%4 round：对浮点数进行四舍五入求值 12&gt;&gt;&gt; round(1.16,1)1.1 sum：对元素类型是数值的可迭代对象中的每个元素求和 123# 传入可迭代对象，要求是数字&gt;&gt;&gt; sum((1,2,3))6 ————————————————本文转载自CSDN大佬「Holidaylovesam」的博客原文链接：点这里```","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python面向对象编程进阶①","slug":"python#6","date":"2021-03-03T15:00:05.000Z","updated":"2021-03-28T05:59:28.520Z","comments":true,"path":"posts/e4b558a/","link":"","permalink":"http://penglaidoll.xyz/posts/e4b558a/","excerpt":"","text":"鸭子类型：存在于动态语言的一种现象，不用严格遵循继承体系也就是说，只要调用的对象中含有对应的方法，不用继承也可以实现多态的现象：如： 1234567891011121314class Person(): def wang(self): print(&#39;wang wang wang!&#39;) passclass Dog(): def wang(self): print(&#39;wang wang wang&#39;) passdef jiao(thing): thing.wang()p &#x3D; Dog()r &#x3D; Person()jiao(p)jiao(r) 其中，一个带感叹号，一个不带输出可以发现，二者均输出 12wang wang wangwang wang wang! 由此可知，python这样的动态语言注重的是方法，而不是繁杂的继承，有对应的方法就可以调用 1“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” 这就是鸭子测试 dir()函数——获得传入类内所有的属性和方法 实例属性和类属性：在类定义时定义的属性为类属性实例化时称为实例属性类属性归类所有，所有的实例均可访问若实例化时没有赋值那么默认属性则被赋值为类属性的值如有定义那么就赋值为实例属性的值 __slots__变量：给类绑定方法和属性：例子如下： 123456789class pp(): passpp.name &#x3D; &#39;pp&#39;o1 &#x3D; pp()print(o1.name)o1.tall &#x3D; 114514print(o1.tall)o2 &#x3D; pp()print(o2.tall) 如果我们将上面的代码输入，就可以观察到最后一行报错原因是tall实际上绑定到的是o1的实例而不是o类，所以实例化的o2没有tall属性，而name属性就是绑定到类上，所有实例化都可用 12345def f(self,x,y): print(x+y)from types import MethodType #从types包中引入methodtype函数，利用这个函数来绑定o1.f &#x3D; MethodType(f,o1) #函数的具体使用o1.f(3,5) 之后，我们再输入以上代码，向o1动态绑定f方法，同上面一样，这个是实例方法，无法在同类变量中使用，除非另行绑定加入我们想让一个类只能绑定我们规定好的属性或方法而无法绑定其他的属性或方法，该怎么办呢 __slots__变量：这个属于系统变量，用来限制该类能绑定的属性或方法举个栗子： 123456789class pp(): __slots__ &#x3D; (&#39;name&#39;) passpp.name &#x3D; &#39;pp&#39;def f(self,x,y): print(x+y)o1 &#x3D; pp()print(o1.name)o1.sound &#x3D; 114514 #(恶臭) 还是上面的代码，只不过我们加入了__slots__变量并规定了一个元组，其中包括了pp类可以绑定的name属性，当我们执行到o1.sound语句时，编译器报错，因为我们规定了除了name属性，其他都无法动态绑定再补充一点:__slots__变量只对当前类有用，对其子类无法起作用，除非子类再定义一个__slots__。如果子类再定义了，那么作为其父类中的__slots__也会得到继承，那么子类可以规定的属性和方法就是它及其父类__slots__变量中的和了 输入参数的检查：我们刚刚得知了给类绑定方法和属性的方法，可如果我们要求绑定的属性有个范围该怎么办呢。举个检查输入参数是否为int类型的例子吧 12if not isinstance(value,int) printf(&#39;error&#39;) isinstance函数可以帮助我们检验一个值是否为某一个类型，并返回true或false @property@property是python中的装饰器，可以用来创建只读属性，将一个方法转换为相同名称的只读属性 1.修饰方法，将其转换可以像属性一样访问1234class pp(): @property def ppff(self): return &#39;pp&#39; 假如没有@property,我们要想输出pp，则需输入 1pp().ppff() 但是有了@property，可以简化为 1pp().ppff 注意，用装饰器修改完之后，ppff函数将变成只读状态，无法再传入任何参数，如输入 1pp().ppff() 将会报错 2.与私有属性连用，防止私有属性被修改在之前我们先看一下私有属性的特点 123456class pp(): def __init__(self,name): self.__name &#x3D; name passp &#x3D; pp(&#39;p&#39;)print(p.__name) 以上，我们定义了一个私有属性__name在后面执行print语句时报错，说明我们无法访问__name这个私有属性，只能另行通过定义函数来返回__name属性的值，但如果我们在print语句前，pp类实例化语句之后加上这么一句 1p.__name &#x3D; &#39;pp&#39; 再执行后面的print语句，你会惊奇的发现，print语句正常执行了，我个人猜测，这个赋值语句改变了__name的私有属性状态而变成了普通的类属性为了防止其私有属性状态的改变和其值被更改，我们可以用@property 12345678910111213class DataSet(object): def __init__(self): self._images &#x3D; 1 self._labels &#x3D; 2 #定义属性的名称 @property def images(self): #方法加入@property后，这个方法相当于一个属性，这个属性可以让用户进行使用，而且用户有没办法随意修改。 return self._images @property def labels(self): return self._labelsl &#x3D; DataSet()#用户进行属性调用的时候，直接调用images即可，而不用知道属性名_images，因此用户无法更改属性，从而保护了类的属性。print(l.images) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（） 上面的例子我们可以将那两个方法改成其他的函数从而隐藏属性的名字而进行调用，让人以为是属性，而其实是方法变成的属性哒！","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"生成器与迭代器基础","slug":"python#5","date":"2021-03-01T14:25:20.000Z","updated":"2021-03-28T05:59:21.412Z","comments":true,"path":"posts/3d4ca4e0/","link":"","permalink":"http://penglaidoll.xyz/posts/3d4ca4e0/","excerpt":"","text":"列表生成式：当我们在用for循环来输出列表时，会很麻烦，特别是生成一些复杂的列表，除此之外，我们可以利用列表生成式如：要生成 1[1&#x3D;1,2&#x3D;2,3&#x3D;3.....] 可以用 1[x&#x3D;x for x in range(1,...)] 这样的式子我们称之为列表生成式还可以在第一个for后面跟上更多的循环来生成更复杂的全排列灵活运用列表生成式可以简化代码列表生成式的if：如: 1[x for x in range(1,11) if x%2&#x3D;&#x3D;0] 可以输出1到11的偶数这里if起的是筛选作用注意后面不可跟else，否则会报错如果在for前面放if则必须跟else表示条件不同，就一以不同的形式输出 生成器：上面我们解释了列表生成式，是把for循环放在列表标识符中的([]),如果我们把列表标识符改成()并且讲其赋值到一个变量中去，像是生成了一个元组一样，但实际上是创建了一个生成器(generator)并将其赋值到了变量之中生成器，顾名思义，可以将一种算法赋值到一个变量之中，根据算法来取到所需要的值。与列表生成器不同，不需要将所有元素都计算出来，而只在需要的时候才算出对应的元素，省去不必要的元素以节省空间使用next(generator)函数来求出下一个元素最好使用for循环来求出所需的元素举个栗子： 123g &#x3D; (x for x in range(1,10000))for i in g: print(i) 在这里，刚刚生成1到10000时，并不是直接占用了所有的内存，二十后面一步一步推算出来的这里之所以能用for，是因为生成器也是可迭代对象生成器的作用非常强大，可以实现算法的迭代当一个算法过于复杂而for列表生成器无法应对的时候比如生成斐波那契数列常规写法： 1234567def fib(max): n,a,b&#x3D;0,0,1 while n&lt;max: print(a) a,b &#x3D; b,a+b n&#x3D;n+1return &#39;done&#39; 由此观察a,b=b,a+b逻辑和生成器相近，都是走一步算一步（雾生成器写法： 1234567def fib(max): n,a,b&#x3D;0,0,1 while n&lt;max: yield b a,b&#x3D;b,a+b n&#x3D;n+1return &#39;done&#39; 解释：在函数定义过程中，只要加上了yield，就可以将函数变成生成器，正常函数为顺序执行，而生成器则会一直执行到首次遇见yield语句，并输出yield语句后面的参数，使用next()语句使其从当前的yield语句执行到下一条yield语句举个简单栗子： 12345def odd(): print &#39;step1&#39; yield 1 print &#39;step2&#39; yield(3) 调用时： 1234567&gt;&gt;o &#x3D; odd()&gt;&gt;next(o)step11&gt;&gt;next(o)step23 如上 注意：调用一个生成器时，会返回一个generate对象就像map一样，生成的是迭代器迭代器和可迭代对象：能被for循环直接作用的，我们称为可迭代对象而像生成器那样的，可以用next()函数调用并返回下一个值的我们称为迭代器，如map,generator。(迭代器也是可迭代对象)可以利用isinstance()来判断一个变量是否为迭代器迭代器对象表示的是一个数据流，我们不知道其有多长，知道数据全部输出完毕就会报错，而不是迭代器的可迭代对象我们往往知道其长度","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"C语言指针相关","slug":"CCpp#1","date":"2021-02-28T09:01:18.000Z","updated":"2021-03-28T06:00:12.264Z","comments":true,"path":"posts/34311c5c/","link":"","permalink":"http://penglaidoll.xyz/posts/34311c5c/","excerpt":"","text":"C指针：指针是一类储存地址的变量 指针数组：如果想让一个数组存储一组指向某一特定数据类型的地址，那么就能定义一个指针数组如：int *ptr[3];int var[]={10,100,200};for (i=0;i&lt;3;i++) { ptr[i] = var[i];}通过以上这段代码，var数组的每个值的每个地址都被存储在指针数组ptr中了 补充：“指针数组”和“数组指针”的区别：“指针数组”顾名思义，是指针的数组，他是元素均为指针的一个数组变量“数组指针”，则是指一个指向数组的指针变量，通常地址为数组第一个元素的地址。 指针函数：一个返回值为指针的函数C语言默认在调用函数时不可返回地址，除非讲局部变量定义为static变量具体的使用过程为——在函数定义声明返回值为指针，然后return一个相同类型的指针(具体的返回值为地址)例如： 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int * fhptr(int i) &#123; static int *s; s &#x3D; &amp;i; return s;&#125;void main() &#123; int *p; p &#x3D; fhptr(5); printf(&quot;%d %p&quot;,*p,p);&#125; 至于为什么要求局部变量要定义为static变量则是因为局部变量存储在内存的栈区，函数调用结束后，内存释放，函数内的变量便不再拥有那个内存地址，故指针无法返回。而static变量值存放在静态栈区，静态区只会在最初时初始化一回，之后便不会改变。 函数指针：指向函数的指针函数在编译后会占一部分内存，函数名则是函数的首地址(类似于数组)将一个指针赋以函数名的值则能让这个特殊的指针指向函数举个栗子： 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void func(int a) &#123; printf(&quot;%d&quot;,a);&#125;void main() &#123; int (*funcpointer)(int); funcpointer &#x3D; &amp;func; funcpointer(6);&#125; 注意：指向函数的指针不可自增运算也就是说，你能在此处通过调用函数指针来获得和调用该函数一样的效果(脱了裤子放屁)还记得当函数作为参数传入函数时需要将其转换为指针的形式吗，函数指针的真正作用则是用在这里 完善一下上面的例子： 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;&#x2F;&#x2F;定义一个 指向 返回类型为void，传入参数为一个Int类型的函数类型 的指针类型typedef void (*hhh) (int);void func(int a) &#123; printf(&quot;%d&quot;,a);&#125;void main() &#123; hhh p; p &#x3D; func; p(6);&#125; 函数指针数组：例子如下： 1int (*function_pointer)[N](int,int); 这个是其通用形式，分开来看 1Int (*function_pointer) [n] (int,int); 首先它是一个指针，指向的是一个数组，什么数组呢，存了n个 参数为两个int类型，返回值为int的函数 的地址","categories":[{"name":"C/C++语言学习","slug":"C-C-语言学习","permalink":"http://penglaidoll.xyz/categories/C-C-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python中的类，模块，包","slug":"python#4","date":"2021-02-24T07:38:16.000Z","updated":"2021-03-28T05:59:10.253Z","comments":true,"path":"posts/8a35e780/","link":"","permalink":"http://penglaidoll.xyz/posts/8a35e780/","excerpt":"","text":"类：Python被设计为一门面向对象的编程语言，同其他面向对象的编程语言一样，它也有类这个概念：类可以认为是一个集合，用来容纳众多的相近的属性和方法，方便随时调用其中的变量和函数；对象则是类的实例化(把类赋值到一个变量中)，一个对象(也可以说一个类)有其对应的属性和方法；属性可以认为是类中定义的变量，分为类的属性和实例对象的属性；方法则是在类中定义的函数；一个简单的类实例： 12345678910class Pp: def __init__(self,a,b): self.a &#x3D; a self.b &#x3D; b self.c &#x3D; a + b print(&quot;初始化完毕！&quot;) def outsc(self): print(self.c)X &#x3D; Pp(2,3)x.outsc() 关于init:在把对象实例化之后会默认执行__init__方法，结合对__init__方法的定义，通常用来对对象初始化。除此之外，若想在对象实例化时就传入参数，必须调用__init__方法，不带__init__方法的类默认无法传入参数。 对于self的解释：类在定义方法时，传入的参数第一个必须是self，即使没有参数时，也要传入self，这里有一种解释，比如上例，Pp类实例化为x，这里self的作用实际上是把变量x在类内以self指代，所以类不管实例化为什么，self总是能把变量的名称传入类内以便调用。 模块：在Python中，一个模块可以认为是一个.py文件，它可以被其他.py文件用import函数引入，以便使用之前定义好的函数，类，变量什么的。 包：当多个用处相近的模块组合在一起，放在同一个文件夹这样的文件夹可以称为一个包。多个这样的文件夹合成一个大文件夹也可以称为一个包，则小文件夹又称为子包。包同样可以用import引入，其往往是一些制作者为了提供一系列的模块所制成，以方便调用。包内必须要有init.py文件、一个包的组成往往如下：Package1:|-init.py|-Module1.py|-Module2.py|-……调用方法为: 1From package1 import module1: 或 1Import package1.module1: 若包中一个模块需调用其他目录的模块，可在当前包目录下的init.py文件中添加sys.path.append(‘调用模块位置’)，然后再import __init__就可以了。","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"格式化字符串的三种方法","slug":"python#3","date":"2021-02-24T07:26:07.000Z","updated":"2021-03-28T05:58:56.872Z","comments":true,"path":"posts/6d69b5ea/","link":"","permalink":"http://penglaidoll.xyz/posts/6d69b5ea/","excerpt":"","text":"最古老的方法：——%-formatting格式化字符串类似于C语言，它是这么用的： 输入： 123Name &#x3D; &#39;world&#39;Id &#x3D; &#39;10&#39;Print(&#39;Hello %s,id&#x3D;%s&#39; % (name,id)) 输出： 1&#39;Hello world,id&#x3D;10&#39; 对于字典，同样适用：格式(%(key)s/d/g) 输入： 1Print(&#39;Hello %(name)s,id&#x3D;%(name)s&#39; % &#123;&#39;id&#39;:10 , &#39;name&#39; : &#39;world&#39;&#125;) 输出： 1Hello World,id&#x3D;10 后来的方法：——str.format()方法格式化字符串常规方法：输入： 12Name &#x3D; &#39;World&#39;Print(&#39;Hello &#123;&#125;&#39; % (name)) 输出： 1Hello World 通过位置访问的方法：输入： 1Print(&#39;&#123;2&#125;,&#123;1&#125;,&#123;0&#125;&#39;.format(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) 输出： 1C,b,a 通过关键字访问的方法：输入： 1Print(&#39;hi &#123;name&#125;&#39;.format(name &#x3D; &#39;howdy!&#39;)) 输出： 1Hi howdy! 新的方法：f-string格式化字符串Python3.6版本更新这一种方法，性能更优： 输入: 12345name &#x3D; &#39;hello world!&#39;D &#x3D; &#123;&#39;id&#39;:&#39;1&#39;,&#39;page&#39;:&#39;2&#39;&#125;Print(f&#39;print &#123;name&#125;&#39;)Print(f&#39;print &#123;name.upper()&#125;)Print(f&#39;turn to &#123;d[&quot;page&quot;]&#125;) 输出： 123Print hello worldPrint HELLO WORLDTurn to 2","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python中的交叉排序问题","slug":"python#2","date":"2021-02-22T03:12:17.000Z","updated":"2021-03-28T05:58:45.317Z","comments":true,"path":"posts/51641b53/","link":"","permalink":"http://penglaidoll.xyz/posts/51641b53/","excerpt":"","text":"在计蒜客中学习Python时，遇到了一个很有趣的排序问题： 输入一行 kk 个用空格分隔开的整数，依次为 n_1, n_2 … n_kn 1 ,n 2…n k。请将所有下标不能被 3 但可以被 2 整除的数在这些数字原有的位置上进行升序排列，此外，将余下下标能被 3 整除的数在这些数字原有的位置上进行降序排列。输出包括一行，与输入相对应的若干个整数，为排序后的结果，整数之间用空格分隔。 自己琢磨了很长时间，其中也发现了各种各样的问题，下面分享一下： 输入例：1 5 4 3 10 7 19输出例：1 3 7 5 10 4 19 程序样例1234567891011121314151617181920212223242526272829n = [int(x) for x in input().split(&#x27; &#x27;)]n1 = []n2 = []n3 = []nc= []# 将满足下标不同条件的列表中的数放入不同的空列表中for index in range(len(n)): if ((index+1) % 3 != 0) and ((index+1) % 2 == 0): n1.append(n[index]) elif ((index+1) % 3 ==0): n2.append(n[index]) else: n3.append(n[index])# 列表排序n1.sort()n2.sort(reverse = True)# 再将列表元素按照原序依次放回for index in range(len(n)): if ((index+1) % 3 != 0) and ((index+1) % 2 == 0) and n1: nc.append(n1.pop(0)) elif ((index+1) % 3 ==0) and n2: nc.append(n2.pop(0)) elif n3: nc.append(n3.pop(0))# 按照格式输出for i in range(len(n)): print(nc[i],end=&#x27; &#x27;) 格式化输入比如以空格相间隔的数据的输入：100 200 300可以用下面的方式读取 12345678# example 1x = [int(i) for i in input().split(&#x27; &#x27;)# exapmle 2x = map(int,input().split(&#x27; &#x27;)) 其中，input().split(‘ ‘)是将输入的数据以split函数传入的参数为标志进行分割并返回分割后的列表(注：split函数返回的列表为字符串列表！！！）example 2是一种比较巧妙的方法 判断列表是否为空1234567a = []if a: print(&#x27;YES&#x27;)else: print(&#x27;NO&#x27;) 以上只是个例子，是为了说明若一个列表为空，则其对应布尔值为False可以利用这个来判断一个列表是否为空程序例子中使用这个判断来防止列表空时pop()函数对空列表使用报错 参考：点这里 [点这里](https://blog.csdn.net/weixin_43113241/article/details/109965485）","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python中的_name_属性","slug":"python#1","date":"2021-02-19T11:36:03.000Z","updated":"2021-03-28T05:58:33.191Z","comments":true,"path":"posts/e599f77d/","link":"","permalink":"http://penglaidoll.xyz/posts/e599f77d/","excerpt":"","text":"刚开始学习python，接触到 1If _name_ == &#x27;_main_&#x27;: 这句话并不是很了解，以下是解答： Python中的模块与C,C++的头文件python如同C，C++等其他编程语言相似，可以引入(import)外部文件，在python中，引入的每个文件，以及自身的代码文件又叫模块，不同于C和C++，python中的模块可以独立运行，而C和C++中的头文件会首先执行 _name_属性1.name_是一个系统定义的变量，用来存储模块的名字或状态，假如一个模块为主函数(通常为引入其他模块的模块)则其模块内包含的_name_变量被赋值为“_main_”；若该模块是被引入的模块，则其_name_变量被赋值为(模块名无后缀)2.通过判断_name_所被赋的值的方式，可以判断该模块是否被引入或为主函数3.通常与if _name ==’main‘结合使用减少bug 总结自：点这里","categories":[{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"}]}],"categories":[{"name":"C/C++语言学习","slug":"C-C-语言学习","permalink":"http://penglaidoll.xyz/categories/C-C-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"Django学习","slug":"Django学习","permalink":"http://penglaidoll.xyz/categories/Django%E5%AD%A6%E4%B9%A0/"},{"name":"逆向学习","slug":"逆向学习","permalink":"http://penglaidoll.xyz/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"逆向学习——OD脱壳","slug":"逆向学习——OD脱壳","permalink":"http://penglaidoll.xyz/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94OD%E8%84%B1%E5%A3%B3/"},{"name":"逆向学习——OD","slug":"逆向学习——OD","permalink":"http://penglaidoll.xyz/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94OD/"},{"name":"Python语言学习","slug":"Python语言学习","permalink":"http://penglaidoll.xyz/categories/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"算法学习","slug":"算法学习","permalink":"http://penglaidoll.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://penglaidoll.xyz/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://penglaidoll.xyz/tags/C-%E5%AD%A6%E4%B9%A0/"},{"name":"web学习","slug":"web学习","permalink":"http://penglaidoll.xyz/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"web后端","slug":"web后端","permalink":"http://penglaidoll.xyz/tags/web%E5%90%8E%E7%AB%AF/"},{"name":"Python学习，MongoDB学习","slug":"Python学习，MongoDB学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0%EF%BC%8CMongoDB%E5%AD%A6%E4%B9%A0/"},{"name":"逆向","slug":"逆向","permalink":"http://penglaidoll.xyz/tags/%E9%80%86%E5%90%91/"},{"name":"MIPS","slug":"MIPS","permalink":"http://penglaidoll.xyz/tags/MIPS/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://penglaidoll.xyz/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://penglaidoll.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"AT&T","slug":"AT-T","permalink":"http://penglaidoll.xyz/tags/AT-T/"},{"name":"c语言编译","slug":"c语言编译","permalink":"http://penglaidoll.xyz/tags/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91/"},{"name":"PE File","slug":"PE-File","permalink":"http://penglaidoll.xyz/tags/PE-File/"},{"name":"OD","slug":"OD","permalink":"http://penglaidoll.xyz/tags/OD/"},{"name":"脱壳","slug":"脱壳","permalink":"http://penglaidoll.xyz/tags/%E8%84%B1%E5%A3%B3/"},{"name":"UPX壳","slug":"UPX壳","permalink":"http://penglaidoll.xyz/tags/UPX%E5%A3%B3/"},{"name":"Aspack壳","slug":"Aspack壳","permalink":"http://penglaidoll.xyz/tags/Aspack%E5%A3%B3/"},{"name":"oep","slug":"oep","permalink":"http://penglaidoll.xyz/tags/oep/"},{"name":"Python学习","slug":"Python学习","permalink":"http://penglaidoll.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://penglaidoll.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}